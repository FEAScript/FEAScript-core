{"version":3,"file":"feascript.cjs.js","sources":["../src/methods/euclideanNormScript.js","../src/utilities/loggingScript.js","../src/vendor/comlink.mjs","../src/methods/linearSystemSolverScript.js","../src/methods/jacobiSolverScript.js","../src/mesh/basisFunctionsScript.js","../src/mesh/meshGenerationScript.js","../src/methods/numericalIntegrationScript.js","../src/mesh/meshUtilsScript.js","../src/models/thermalBoundaryConditionsScript.js","../src/models/heatConductionScript.js","../src/models/genericBoundaryConditionsScript.js","../src/models/frontPropagationScript.js","../src/methods/frontalSolverScript.js","../src/methods/newtonRaphsonScript.js","../src/models/flowBoundaryConditions.js","../src/visualization/plotSolutionScript.js","../src/FEAScript.js","../src/models/generalFormPDEScript.js","../src/models/stokesScript.js","../src/workers/workerScript.js","../src/readers/gmshReaderScript.js","../src/index.js"],"sourcesContent":["/**\n * ════════════════════════════════════════════════════════════════\n *  FEAScript Core Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.2.0 | https://feascript.com\n *  MIT License © 2023–2026 FEAScript\n * ════════════════════════════════════════════════════════════════\n */\n\n/**\n * Function to calculate the Euclidean norm of a vector\n * @param {array} vector - The input vector\n * @returns {number} The Euclidean norm of the vector\n */\nexport function euclideanNorm(vector) {\n  let norm = 0;\n  for (let i = 0; i < vector.length; i++) {\n    norm += vector[i] * vector[i];\n  }\n  norm = Math.sqrt(norm);\n  return norm;\n}\n","/**\n * ════════════════════════════════════════════════════════════════\n *  FEAScript Core Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.2.0 | https://feascript.com\n *  MIT License © 2023–2026 FEAScript\n * ════════════════════════════════════════════════════════════════\n */\n\n// Global logging level\nlet currentLogLevel = \"basic\";\n\n/**\n * Function to set the logging system level\n * @param {string} level - Logging level (basic, debug)\n */\nexport function logSystem(level) {\n  if (level !== \"basic\" && level !== \"debug\") {\n    console.log(\n      \"%c[WARN] Invalid log level: \" + level + \". Using basic instead.\",\n      \"color: #FFC107; font-weight: bold;\"\n    ); // Yellow for warnings\n    currentLogLevel = \"basic\";\n  } else {\n    currentLogLevel = level;\n    basicLog(`Log level set to: ${level}`);\n  }\n}\n\n/**\n * Function to log debug messages - only logs if level is 'debug'\n * @param {string} message - Message to log\n */\nexport function debugLog(message) {\n  if (currentLogLevel === \"debug\") {\n    console.log(\"%c[DEBUG] \" + message, \"color: #2196F3; font-weight: bold;\");\n  }\n}\n\n/**\n * Function to log basic information - always logs\n * @param {string} message - Message to log\n */\nexport function basicLog(message) {\n  console.log(\"%c[INFO] \" + message, \"color: #4CAF50; font-weight: bold;\");\n}\n\n/**\n * Function to log error messages\n * @param {string} message - Message to log\n */\nexport function errorLog(message) {\n  console.log(\"%c[ERROR] \" + message, \"color: #F44336; font-weight: bold;\");\n}\n\n/**\n * Function to log warning messages\n * @param {string} message - Message to log\n */\nexport function warnLog(message) {\n  console.log(\"%c[WARN] \" + message, \"color: #FF9800; font-weight: bold;\");\n}\n\n/**\n * Function to handle version information and fetch the latest update date and release from GitHub\n */\nexport async function printVersionInformation() {\n  basicLog(\"Fetching latest FEAScript version information...\");\n  try {\n    const commitResponse = await fetch(\"https://api.github.com/repos/FEAScript/FEAScript/commits/main\");\n    const commitData = await commitResponse.json();\n    const latestCommitDate = new Date(commitData.commit.committer.date).toLocaleString();\n    basicLog(`Latest FEAScript update: ${latestCommitDate}`);\n    return latestCommitDate;\n  } catch (error) {\n    errorLog(\"Failed to fetch version information: \" + error);\n    return \"Version information unavailable\";\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    [\"proxy\", proxyTransferHandler],\n    [\"throw\", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case \"GET\" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction wrap(ep, target) {\n    const pendingListeners = new Map();\n    ep.addEventListener(\"message\", function handleMessage(ev) {\n        const { data } = ev;\n        if (!data || !data.id) {\n            return;\n        }\n        const resolver = pendingListeners.get(data.id);\n        if (!resolver) {\n            return;\n        }\n        try {\n            resolver(data);\n        }\n        finally {\n            pendingListeners.delete(data.id);\n        }\n    });\n    return createProxy(ep, pendingListeners, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, new Map(), {\n        type: \"RELEASE\" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, pendingListeners, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    pendingListeners.clear();\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, pendingListeners, {\n                    type: \"GET\" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, pendingListeners, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"SET\" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, pendingListeners, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didn’t happen.\n            if (last === \"bind\") {\n                return createProxy(ep, pendingListeners, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"APPLY\" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case \"HANDLER\" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, pendingListeners, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        pendingListeners.set(id, resolve);\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join(\"-\");\n}\n\nexport { createEndpoint, expose, finalizer, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n","/**\n * ════════════════════════════════════════════════════════════════\n *  FEAScript Core Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.2.0 | https://feascript.com\n *  MIT License © 2023–2026 FEAScript\n * ════════════════════════════════════════════════════════════════\n */\n\n// Internal imports\nimport { jacobiSolver } from \"./jacobiSolverScript.js\";\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\nimport * as Comlink from \"../vendor/comlink.mjs\";\n\n/**\n * Function to solve a system of linear equations using different solver methods\n * @param {string} solverMethod - The solver method to use (\"lusolve\" or \"jacobi\")\n * @param {Array} jacobianMatrix - The coefficient matrix\n * @param {Array} residualVector - The right-hand side vector\n * @param {object} [options] - Optional parameters for the solver, such as `maxIterations` and `tolerance`\n * @returns {object} An object containing:\n *  - solutionVector: The solution vector\n *  - converged: Boolean indicating whether the method converged (for iterative methods)\n *  - iterations: Number of iterations performed (for iterative methods)\n */\nexport function solveLinearSystem(solverMethod, jacobianMatrix, residualVector, options = {}) {\n\n  // Extract options\n  const { maxIterations = 10000, tolerance = 1e-4 } = options;\n\n  let solutionVector = [];\n  let converged = true;\n  let iterations = 0;\n\n  // Solve the linear system based on the specified solver method\n  basicLog(`Solving system using ${solverMethod}...`);\n  console.time(\"systemSolving\");\n\n  if (solverMethod === \"lusolve\") {\n    // Use LU decomposition method\n    const jacobianMatrixSparse = math.sparse(jacobianMatrix);\n    const luFactorization = math.slu(jacobianMatrixSparse, 1, 1); // order=1, threshold=1 for pivoting\n    let solutionMatrix = math.lusolve(luFactorization, residualVector);\n    solutionVector = math.squeeze(solutionMatrix).valueOf();\n    //solutionVector = math.lusolve(jacobianMatrix, residualVector); // In the case of a dense matrix\n  } else if (solverMethod === \"jacobi\") {\n    // Use Jacobi method\n    const initialGuess = new Array(residualVector.length).fill(0);\n    const jacobiSolverResult = jacobiSolver(jacobianMatrix, residualVector, initialGuess, {\n      maxIterations,\n      tolerance,\n    });\n\n    // Log convergence information\n    if (jacobiSolverResult.converged) {\n      debugLog(`Jacobi method converged in ${jacobiSolverResult.iterations} iterations`);\n    } else {\n      errorLog(`Jacobi method did not converge after ${jacobiSolverResult.iterations} iterations`);\n    }\n\n    solutionVector = jacobiSolverResult.solutionVector;\n    converged = jacobiSolverResult.converged;\n    iterations = jacobiSolverResult.iterations;\n  } else {\n    errorLog(`Unknown solver method: ${solverMethod}`);\n  }\n\n  console.timeEnd(\"systemSolving\");\n  basicLog(\"System solved successfully\");\n\n  return { solutionVector, converged, iterations };\n}\n\n// Helper to lazily create a default WebGPU compute engine (Comlink + worker)\nasync function createDefaultComputeEngine() {\n  const worker = new Worker(new URL(\"../workers/webgpuWorkerScript.js\", import.meta.url), {\n    type: \"module\",\n  });\n  const computeEngine = Comlink.wrap(worker);\n  await computeEngine.initialize();\n  return { computeEngine, worker };\n}\n\n/**\n * Function to solve asynchronously a system of linear equations using different solver methods\n * @param {string} solverMethod - The solver method to use (e.g., \"jacobi-gpu\")\n * @param {array} jacobianMatrix - The coefficient matrix\n * @param {array} residualVector - The right-hand side vector\n * @param {object} [options] - Optional parameters for the solver, such as `maxIterations` and `tolerance`\n * @returns {Promise<object>} A promise that resolves to an object containing:\n *  - solutionVector: The solution vector\n *  - converged: Boolean indicating whether the method converged (for iterative methods)\n *  - iterations: Number of iterations performed (for iterative methods)\n */\nexport async function solveLinearSystemAsync(solverMethod, jacobianMatrix, residualVector, options = {}) {\n  \n  // Extract options\n  const { maxIterations = 10000, tolerance = 1e-4 } = options;\n\n  basicLog(`Solving system using ${solverMethod}...`);\n  console.time(\"systemSolving\");\n\n  // Normalize inputs\n  const A = Array.isArray(jacobianMatrix) ? jacobianMatrix : jacobianMatrix?.toArray?.() ?? jacobianMatrix;\n  const b = Array.isArray(residualVector) ? residualVector : residualVector?.toArray?.() ?? residualVector;\n\n  let created = null;\n  let computeEngine = null;\n\n  let solutionVector = [];\n  let converged = true;\n  let iterations;\n\n  if (solverMethod === \"jacobi-gpu\") {\n    // Spin up a worker-backed compute engine\n    created = await createDefaultComputeEngine();\n    computeEngine = created.computeEngine;\n\n    const x0 = new Array(b.length).fill(0);\n    let result;\n\n    result = await computeEngine.webgpuJacobiSolver(A, b, x0, { maxIterations, tolerance });\n    solutionVector = result.solutionVector;\n    converged = result.converged;\n    iterations = result.iterations;\n\n    // Log convergence information\n    if (converged) {\n      debugLog(`Jacobi method converged in ${iterations} iterations`);\n    } else {\n      errorLog(`Jacobi method did not converge after ${iterations} iterations`);\n    }\n  } else {\n    errorLog(`Unknown solver method: ${solverMethod}`);\n  }\n\n  console.timeEnd(\"systemSolving\");\n  basicLog(`System solved successfully (${solverMethod})`);\n\n  if (created) {\n    await computeEngine?.destroy?.().catch(() => { });\n    created.worker.terminate();\n  }\n\n  return { solutionVector, converged, iterations };\n}\n","/**\n * ════════════════════════════════════════════════════════════════\n *  FEAScript Core Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.2.0 | https://feascript.com\n *  MIT License © 2023–2026 FEAScript\n * ════════════════════════════════════════════════════════════════\n */\n\n/**\n * Function to solve a system of linear equations using the Jacobi iterative method (CPU synchronous version)\n * @param {array} A - The system matrix\n * @param {array} b - The right-hand side vector\n * @param {array} x0 - Initial guess for solution vector\n * @param {object} [options] - Optional parameters for the solver, such as `maxIterations` and `tolerance`\n * @returns {object} An object containing:\n *  - solutionVector: The solution vector\n *  - iterations: The number of iterations performed\n *  - converged: Boolean indicating whether the method converged\n */\nexport function jacobiSolver(A, b, x0, options = {}) {\n  // Extract options\n  const { maxIterations, tolerance } = options;\n\n  const n = A.length;\n  let x = [...x0];\n  let xNew = new Array(n);\n\n  // Jacobi update: xNew[i] = (b[i] - sum(A[i][j] * x[j] for j != i)) / A[i][i]\n  for (let iter = 0; iter < maxIterations; iter++) {\n    for (let i = 0; i < n; i++) {\n      let sum = 0;\n      for (let j = 0; j < n; j++) {\n        if (i !== j) {\n          sum += A[i][j] * x[j];\n        }\n      }\n      xNew[i] = (b[i] - sum) / A[i][i];\n    }\n\n    // Check convergence based on maximum difference in solution vector\n    let maxDiff = 0;\n    for (let i = 0; i < n; i++) {\n      maxDiff = Math.max(maxDiff, Math.abs(xNew[i] - x[i]));\n    }\n\n    // Copy new solution for the next iteration\n    x = [...xNew];\n\n    if (maxDiff < tolerance) {\n      return { solutionVector: x, iterations: iter + 1, converged: true };\n    }\n  }\n\n  return { solutionVector: x, iterations: maxIterations, converged: false };\n}\n","/**\n * ════════════════════════════════════════════════════════════════\n *  FEAScript Core Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.2.0 | https://feascript.com\n *  MIT License © 2023–2026 FEAScript\n * ════════════════════════════════════════════════════════════════\n */\n\n// Internal imports\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Class to handle basis functions and their derivatives based on element configuration\n */\nexport class BasisFunctions {\n  /**\n   * Constructor to initialize the BasisFunctions class\n   * @param {string} meshDimension - The dimension of the mesh\n   * @param {string} elementOrder - The order of elements\n   */\n  constructor({ meshDimension, elementOrder }) {\n    this.meshDimension = meshDimension;\n    this.elementOrder = elementOrder;\n  }\n\n  /**\n   * Function to calculate basis functions and their derivatives based on the dimension and order\n   * @param {number} ksi - Natural coordinate (for both 1D and 2D)\n   * @param {number} [eta] - Second natural coordinate (only for 2D elements)\n   * @returns {object} An object containing:\n   *  - basisFunction: Array of evaluated basis functions\n   *  - basisFunctionDerivKsi: Array of derivatives of basis functions with respect to ksi\n   *  - basisFunctionDerivEta: Array of derivatives of basis functions with respect to eta (only for 2D elements)\n   */\n  getBasisFunctions(ksi, eta = null) {\n    let basisFunction = [];\n    let basisFunctionDerivKsi = [];\n    let basisFunctionDerivEta = [];\n\n    if (this.meshDimension === \"1D\") {\n      if (this.elementOrder === \"linear\") {\n        // Linear basis functions for 1D elements\n        basisFunction[0] = 1 - ksi;\n        basisFunction[1] = ksi;\n\n        // Derivatives of basis functions with respect to ksi\n        basisFunctionDerivKsi[0] = -1;\n        basisFunctionDerivKsi[1] = 1;\n      } else if (this.elementOrder === \"quadratic\") {\n        // Quadratic basis functions for 1D elements\n        basisFunction[0] = 1 - 3 * ksi + 2 * ksi ** 2;\n        basisFunction[1] = 4 * ksi - 4 * ksi ** 2;\n        basisFunction[2] = -ksi + 2 * ksi ** 2;\n\n        // Derivatives of basis functions with respect to ksi\n        basisFunctionDerivKsi[0] = -3 + 4 * ksi;\n        basisFunctionDerivKsi[1] = 4 - 8 * ksi;\n        basisFunctionDerivKsi[2] = -1 + 4 * ksi;\n      }\n    } else if (this.meshDimension === \"2D\") {\n      if (eta === null) {\n        errorLog(\"Eta coordinate is required for 2D elements\");\n        return;\n      }\n\n      if (this.elementOrder === \"linear\") {\n        // Linear basis functions for 2D elements\n        function l1(c) {\n          return 1 - c;\n        }\n        function l2(c) {\n          return c;\n        }\n        function dl1() {\n          return -1;\n        }\n        function dl2() {\n          return 1;\n        }\n\n        // Evaluate basis functions at (ksi, eta)\n        basisFunction[0] = l1(ksi) * l1(eta);\n        basisFunction[1] = l1(ksi) * l2(eta);\n        basisFunction[2] = l2(ksi) * l1(eta);\n        basisFunction[3] = l2(ksi) * l2(eta);\n\n        // Derivatives with respect to ksi\n        basisFunctionDerivKsi[0] = dl1() * l1(eta);\n        basisFunctionDerivKsi[1] = dl1() * l2(eta);\n        basisFunctionDerivKsi[2] = dl2() * l1(eta);\n        basisFunctionDerivKsi[3] = dl2() * l2(eta);\n\n        // Derivatives with respect to eta\n        basisFunctionDerivEta[0] = l1(ksi) * dl1();\n        basisFunctionDerivEta[1] = l1(ksi) * dl2();\n        basisFunctionDerivEta[2] = l2(ksi) * dl1();\n        basisFunctionDerivEta[3] = l2(ksi) * dl2();\n      } else if (this.elementOrder === \"quadratic\") {\n        // Quadratic basis functions for 2D elements\n        function l1(c) {\n          return 2 * c ** 2 - 3 * c + 1;\n        }\n        function l2(c) {\n          return -4 * c ** 2 + 4 * c;\n        }\n        function l3(c) {\n          return 2 * c ** 2 - c;\n        }\n        function dl1(c) {\n          return 4 * c - 3;\n        }\n        function dl2(c) {\n          return -8 * c + 4;\n        }\n        function dl3(c) {\n          return 4 * c - 1;\n        }\n\n        // Evaluate basis functions at (ksi, eta)\n        basisFunction[0] = l1(ksi) * l1(eta);\n        basisFunction[1] = l1(ksi) * l2(eta);\n        basisFunction[2] = l1(ksi) * l3(eta);\n        basisFunction[3] = l2(ksi) * l1(eta);\n        basisFunction[4] = l2(ksi) * l2(eta);\n        basisFunction[5] = l2(ksi) * l3(eta);\n        basisFunction[6] = l3(ksi) * l1(eta);\n        basisFunction[7] = l3(ksi) * l2(eta);\n        basisFunction[8] = l3(ksi) * l3(eta);\n\n        // Derivatives with respect to ksi\n        basisFunctionDerivKsi[0] = dl1(ksi) * l1(eta);\n        basisFunctionDerivKsi[1] = dl1(ksi) * l2(eta);\n        basisFunctionDerivKsi[2] = dl1(ksi) * l3(eta);\n        basisFunctionDerivKsi[3] = dl2(ksi) * l1(eta);\n        basisFunctionDerivKsi[4] = dl2(ksi) * l2(eta);\n        basisFunctionDerivKsi[5] = dl2(ksi) * l3(eta);\n        basisFunctionDerivKsi[6] = dl3(ksi) * l1(eta);\n        basisFunctionDerivKsi[7] = dl3(ksi) * l2(eta);\n        basisFunctionDerivKsi[8] = dl3(ksi) * l3(eta);\n\n        // Derivatives with respect to eta\n        basisFunctionDerivEta[0] = l1(ksi) * dl1(eta);\n        basisFunctionDerivEta[1] = l1(ksi) * dl2(eta);\n        basisFunctionDerivEta[2] = l1(ksi) * dl3(eta);\n        basisFunctionDerivEta[3] = l2(ksi) * dl1(eta);\n        basisFunctionDerivEta[4] = l2(ksi) * dl2(eta);\n        basisFunctionDerivEta[5] = l2(ksi) * dl3(eta);\n        basisFunctionDerivEta[6] = l3(ksi) * dl1(eta);\n        basisFunctionDerivEta[7] = l3(ksi) * dl2(eta);\n        basisFunctionDerivEta[8] = l3(ksi) * dl3(eta);\n      }\n    }\n\n    return { basisFunction, basisFunctionDerivKsi, basisFunctionDerivEta };\n  }\n}\n","/**\n * ════════════════════════════════════════════════════════════════\n *  FEAScript Core Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.2.0 | https://feascript.com\n *  MIT License © 2023–2026 FEAScript\n * ════════════════════════════════════════════════════════════════\n */\n\n// Internal imports\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Basic structure for the mesh\n */\nexport class Mesh {\n  /**\n   * Constructor to initialize the Mesh class\n   * @param {object} config - Configuration object for the mesh\n   * @param {number} [config.numElementsX] - Number of elements along the x-axis (required for geometry-based mesh)\n   * @param {number} [config.maxX] - Maximum x-coordinate of the mesh (required for geometry-based mesh)\n   * @param {number} [config.numElementsY=1] - Number of elements along the y-axis (for 1D meshes)\n   * @param {number} [config.maxY=0] - Maximum y-coordinate of the mesh (for 1D meshes)\n   * @param {string} [config.meshDimension='2D'] - The dimension of the mesh, either 1D or 2D\n   * @param {string} [config.elementOrder='linear'] - The order of elements, either 'linear' or 'quadratic'\n   * @param {object} [config.parsedMesh=null] - Optional pre-parsed mesh data\n   */\n  constructor({\n    numElementsX = null,\n    maxX = null,\n    numElementsY = null,\n    maxY = null,\n    meshDimension = null,\n    elementOrder = \"linear\",\n    parsedMesh = null,\n  }) {\n    this.numElementsX = numElementsX;\n    this.numElementsY = numElementsY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n    this.meshDimension = meshDimension;\n    this.elementOrder = elementOrder;\n    this.parsedMesh = parsedMesh;\n\n    this.boundaryElementsProcessed = false;\n\n    if (this.parsedMesh) {\n      basicLog(\"Using pre-parsed mesh from gmshReader data for mesh generation.\");\n      this.parseMeshFromGmsh();\n    }\n  }\n\n  /**\n   * Method to parse the mesh from the Gmsh format to the FEAScript format\n   */\n  parseMeshFromGmsh() {\n    if (!this.parsedMesh.nodalNumbering) {\n      errorLog(\"No valid nodal numbering found in the parsed mesh.\");\n    }\n\n    // If this parsed mesh was already converted in a previous run, don't re-process it.\n    // Just mark this Mesh instance as ready so prepareMesh() doesn't fall back to generateMesh().\n    if (Array.isArray(this.parsedMesh.nodalNumbering)) {\n      this.boundaryElementsProcessed = true;\n      this.parsedMesh.boundaryElementsProcessed = true;\n      return this.parsedMesh;\n    }\n\n    if (\n      typeof this.parsedMesh.nodalNumbering === \"object\" &&\n      !Array.isArray(this.parsedMesh.nodalNumbering)\n    ) {\n      // Store the nodal numbering structure before converting\n      const quadElements = this.parsedMesh.nodalNumbering.quadElements || [];\n      const triangleElements = this.parsedMesh.nodalNumbering.triangleElements || [];\n\n      debugLog(\n        \"Initial parsed mesh nodal numbering from Gmsh format: \" +\n          JSON.stringify(this.parsedMesh.nodalNumbering)\n      );\n\n      // Check if it has quadElements or triangleElements structure from gmshReader\n      if (this.parsedMesh.elementTypes[3] || this.parsedMesh.elementTypes[10]) {\n        // Map nodal numbering from Gmsh format to FEAScript format for quad elements\n        const mappedNodalNumbering = [];\n\n        for (let elementIndex = 0; elementIndex < quadElements.length; elementIndex++) {\n          const gmshNodes = quadElements[elementIndex];\n          const FEAScriptNodes = new Array(gmshNodes.length);\n\n          // Check for element type based on number of nodes\n          if (gmshNodes.length === 4) {\n            // Simple mapping for linear quad elements (4 nodes)\n            // Gmsh:         FEAScript:\n            // 3 --- 2       1 --- 3\n            // |     |  -->  |     |\n            // 0 --- 1       0 --- 2\n\n            FEAScriptNodes[0] = gmshNodes[0]; // 0 -> 0\n            FEAScriptNodes[1] = gmshNodes[3]; // 3 -> 1\n            FEAScriptNodes[2] = gmshNodes[1]; // 1 -> 2\n            FEAScriptNodes[3] = gmshNodes[2]; // 2 -> 3\n          } else if (gmshNodes.length === 9) {\n            // Mapping for quadratic quad elements (9 nodes)\n            // Gmsh:         FEAScript:\n            // 3--6--2       2--5--8\n            // |     |       |     |\n            // 7  8  5  -->  1  4  7\n            // |     |       |     |\n            // 0--4--1       0--3--6\n\n            FEAScriptNodes[0] = gmshNodes[0]; // 0 -> 0\n            FEAScriptNodes[1] = gmshNodes[7]; // 7 -> 1\n            FEAScriptNodes[2] = gmshNodes[3]; // 3 -> 2\n            FEAScriptNodes[3] = gmshNodes[4]; // 4 -> 3\n            FEAScriptNodes[4] = gmshNodes[8]; // 8 -> 4\n            FEAScriptNodes[5] = gmshNodes[6]; // 6 -> 5\n            FEAScriptNodes[6] = gmshNodes[1]; // 1 -> 6\n            FEAScriptNodes[7] = gmshNodes[5]; // 5 -> 7\n            FEAScriptNodes[8] = gmshNodes[2]; // 2 -> 8\n          }\n\n          mappedNodalNumbering.push(FEAScriptNodes);\n        }\n\n        this.parsedMesh.nodalNumbering = mappedNodalNumbering;\n      } else if (this.parsedMesh.elementTypes[2]) {\n        errorLog(\"Element type is neither triangle nor quad; mapping for this type is not implemented yet.\");\n      }\n\n      debugLog(\n        \"Nodal numbering after mapping from Gmsh to FEAScript format: \" +\n          JSON.stringify(this.parsedMesh.nodalNumbering)\n      );\n\n      // Process boundary elements if they exist and if physical property mapping exists\n      if (this.parsedMesh.physicalPropMap && this.parsedMesh.boundaryElements) {\n        // Check if boundary elements need to be processed\n        if (\n          Array.isArray(this.parsedMesh.boundaryElements) &&\n          this.parsedMesh.boundaryElements.length > 0 &&\n          this.parsedMesh.boundaryElements[0] === undefined\n        ) {\n          // Create a new array without the empty first element\n          const fixedBoundaryElements = [];\n          for (let i = 1; i < this.parsedMesh.boundaryElements.length; i++) {\n            if (this.parsedMesh.boundaryElements[i]) {\n              fixedBoundaryElements.push(this.parsedMesh.boundaryElements[i]);\n            }\n          }\n          this.parsedMesh.boundaryElements = fixedBoundaryElements;\n        }\n\n        // If boundary node pairs exist but boundary elements haven't been processed\n        if (this.parsedMesh.boundaryNodePairs && !this.parsedMesh.boundaryElementsProcessed) {\n          // Reset boundary elements array\n          this.parsedMesh.boundaryElements = [];\n\n          // Process each physical property from the Gmsh file\n          this.parsedMesh.physicalPropMap.forEach((prop) => {\n            // Only process 1D physical entities (boundary lines)\n            if (prop.dimension === 1) {\n              // Get all node pairs for this boundary\n              const boundaryNodePairs = this.parsedMesh.boundaryNodePairs[prop.tag] || [];\n\n              if (boundaryNodePairs.length > 0) {\n                // Initialize array for this boundary tag\n                if (!this.parsedMesh.boundaryElements[prop.tag]) {\n                  this.parsedMesh.boundaryElements[prop.tag] = [];\n                }\n\n                // For each boundary line segment (defined by a pair of nodes)\n                boundaryNodePairs.forEach((nodesPair) => {\n                  const node1 = nodesPair[0]; // First node in the pair\n                  const node2 = nodesPair[1]; // Second node in the pair\n\n                  debugLog(\n                    `Processing boundary node pair: [${node1}, ${node2}] for boundary ${prop.tag} (${\n                      prop.name || \"unnamed\"\n                    })`\n                  );\n\n                  // Search through all elements to find which one contains both nodes\n                  let foundElement = false;\n\n                  // Loop through all elements in the mesh\n                  for (\n                    let elementIndex = 0;\n                    elementIndex < this.parsedMesh.nodalNumbering.length;\n                    elementIndex++\n                  ) {\n                    const elementConnectivity = this.parsedMesh.nodalNumbering[elementIndex];\n\n                    // For linear quadrilateral linear elements (4 nodes)\n                    if (elementConnectivity.length === 4) {\n                      // Check if both boundary nodes are in this element\n                      if (elementConnectivity.includes(node1) && elementConnectivity.includes(node2)) {\n                        // Find which side of the element these nodes form\n                        let side;\n\n                        const node1Index = elementConnectivity.indexOf(node1);\n                        const node2Index = elementConnectivity.indexOf(node2);\n\n                        debugLog(\n                          `  Found element ${elementIndex} containing boundary nodes. Element nodes: [${elementConnectivity.join(\n                            \", \"\n                          )}]`\n                        );\n                        debugLog(\n                          `  Node ${node1} is at index ${node1Index}, Node ${node2} is at index ${node2Index} in the element`\n                        );\n\n                        // Based on FEAScript linear quadrilateral numbering:\n                        // 1 --- 3\n                        // |     |\n                        // 0 --- 2\n\n                        if (\n                          (node1Index === 0 && node2Index === 2) ||\n                          (node1Index === 2 && node2Index === 0)\n                        ) {\n                          side = 0; // Bottom side\n                          debugLog(`  These nodes form the BOTTOM side (${side}) of element ${elementIndex}`);\n                        } else if (\n                          (node1Index === 0 && node2Index === 1) ||\n                          (node1Index === 1 && node2Index === 0)\n                        ) {\n                          side = 1; // Left side\n                          debugLog(`  These nodes form the LEFT side (${side}) of element ${elementIndex}`);\n                        } else if (\n                          (node1Index === 1 && node2Index === 3) ||\n                          (node1Index === 3 && node2Index === 1)\n                        ) {\n                          side = 2; // Top side\n                          debugLog(`  These nodes form the TOP side (${side}) of element ${elementIndex}`);\n                        } else if (\n                          (node1Index === 2 && node2Index === 3) ||\n                          (node1Index === 3 && node2Index === 2)\n                        ) {\n                          side = 3; // Right side\n                          debugLog(`  These nodes form the RIGHT side (${side}) of element ${elementIndex}`);\n                        }\n\n                        // Add the element and side to the boundary elements array\n                        this.parsedMesh.boundaryElements[prop.tag].push([elementIndex, side]);\n                        debugLog(\n                          `  Added element-side pair [${elementIndex}, ${side}] to boundary tag ${prop.tag}`\n                        );\n                        foundElement = true;\n                        break;\n                      }\n                    } else if (elementConnectivity.length === 9) {\n                      // For quadratic quadrilateral elements (9 nodes)\n                      // Check if both boundary nodes are in this element\n                      if (elementConnectivity.includes(node1) && elementConnectivity.includes(node2)) {\n                        // Find which side of the element these nodes form\n                        let side;\n\n                        const node1Index = elementConnectivity.indexOf(node1);\n                        const node2Index = elementConnectivity.indexOf(node2);\n\n                        debugLog(\n                          `  Found element ${elementIndex} containing boundary nodes. Element nodes: [${elementConnectivity.join(\n                            \", \"\n                          )}]`\n                        );\n                        debugLog(\n                          `  Node ${node1} is at index ${node1Index}, Node ${node2} is at index ${node2Index} in the element`\n                        );\n\n                        // Based on FEAScript quadratic quadrilateral numbering:\n                        // 2--5--8\n                        // |     |\n                        // 1  4  7\n                        // |     |\n                        // 0--3--6\n\n                        // TODO: Transform into dictionaries for better readability\n                        if (\n                          (node1Index === 0 && node2Index === 6) ||\n                          (node1Index === 6 && node2Index === 0) ||\n                          (node1Index === 0 && node2Index === 3) ||\n                          (node1Index === 3 && node2Index === 0) ||\n                          (node1Index === 3 && node2Index === 6) ||\n                          (node1Index === 6 && node2Index === 3)\n                        ) {\n                          side = 0; // Bottom side (nodes 0, 3, 6)\n                          debugLog(`  These nodes form the BOTTOM side (${side}) of element ${elementIndex}`);\n                        } else if (\n                          (node1Index === 0 && node2Index === 2) ||\n                          (node1Index === 2 && node2Index === 0) ||\n                          (node1Index === 0 && node2Index === 1) ||\n                          (node1Index === 1 && node2Index === 0) ||\n                          (node1Index === 1 && node2Index === 2) ||\n                          (node1Index === 2 && node2Index === 1)\n                        ) {\n                          side = 1; // Left side (nodes 0, 1, 2)\n                          debugLog(`  These nodes form the LEFT side (${side}) of element ${elementIndex}`);\n                        } else if (\n                          (node1Index === 2 && node2Index === 8) ||\n                          (node1Index === 8 && node2Index === 2) ||\n                          (node1Index === 2 && node2Index === 5) ||\n                          (node1Index === 5 && node2Index === 2) ||\n                          (node1Index === 5 && node2Index === 8) ||\n                          (node1Index === 8 && node2Index === 5)\n                        ) {\n                          side = 2; // Top side (nodes 2, 5, 8)\n                          debugLog(`  These nodes form the TOP side (${side}) of element ${elementIndex}`);\n                        } else if (\n                          (node1Index === 6 && node2Index === 8) ||\n                          (node1Index === 8 && node2Index === 6) ||\n                          (node1Index === 6 && node2Index === 7) ||\n                          (node1Index === 7 && node2Index === 6) ||\n                          (node1Index === 7 && node2Index === 8) ||\n                          (node1Index === 8 && node2Index === 7)\n                        ) {\n                          side = 3; // Right side (nodes 6, 7, 8)\n                          debugLog(`  These nodes form the RIGHT side (${side}) of element ${elementIndex}`);\n                        }\n\n                        // Add the element and side to the boundary elements array\n                        this.parsedMesh.boundaryElements[prop.tag].push([elementIndex, side]);\n                        debugLog(\n                          `  Added element-side pair [${elementIndex}, ${side}] to boundary tag ${prop.tag}`\n                        );\n                        foundElement = true;\n                        break;\n                      }\n                    }\n                  }\n\n                  if (!foundElement) {\n                    errorLog(\n                      `Could not find element containing boundary nodes ${node1} and ${node2}. Boundary may be incomplete.`\n                    );\n                  }\n                });\n              }\n            }\n          });\n\n          // Mark as processed\n          this.boundaryElementsProcessed = true;\n\n          // Fix boundary elements array - remove undefined entries\n          if (\n            this.parsedMesh.boundaryElements.length > 0 &&\n            this.parsedMesh.boundaryElements[0] === undefined\n          ) {\n            const fixedBoundaryElements = [];\n            for (let i = 1; i < this.parsedMesh.boundaryElements.length; i++) {\n              if (this.parsedMesh.boundaryElements[i]) {\n                fixedBoundaryElements.push(this.parsedMesh.boundaryElements[i]);\n              }\n            }\n            this.parsedMesh.boundaryElements = fixedBoundaryElements;\n          }\n        }\n      }\n    }\n\n    return this.parsedMesh;\n  }\n}\n\nexport class Mesh1D extends Mesh {\n  /**\n   * Constructor to initialize the 1D mesh\n   * @param {object} config - Configuration object for the 1D mesh\n   * @param {number} [config.numElementsX] - Number of elements along the x-axis (required for geometry-based mesh)\n   * @param {number} [config.maxX] - Maximum x-coordinate of the mesh (required for geometry-based mesh)\n   * @param {string} [config.elementOrder='linear'] - The order of elements, either 'linear' or 'quadratic'\n   * @param {object} [config.parsedMesh=null] - Optional pre-parsed mesh data\n   */\n  constructor({ numElementsX = null, maxX = null, elementOrder = \"linear\", parsedMesh = null }) {\n    super({\n      numElementsX,\n      maxX,\n      numElementsY: 1,\n      maxY: 0,\n      meshDimension: \"1D\",\n      elementOrder,\n      parsedMesh,\n    });\n\n    if (this.numElementsX === null || this.maxX === null) {\n      errorLog(\"numElementsX and maxX are required parameters when generating a 1D mesh from geometry\");\n    }\n  }\n\n  generateMesh() {\n    let nodesXCoordinates = [];\n    const xStart = 0;\n    let totalNodesX, deltaX;\n\n    if (this.elementOrder === \"linear\") {\n      totalNodesX = this.numElementsX + 1;\n      deltaX = (this.maxX - xStart) / this.numElementsX;\n\n      nodesXCoordinates[0] = xStart;\n      for (let nodeIndex = 1; nodeIndex < totalNodesX; nodeIndex++) {\n        nodesXCoordinates[nodeIndex] = nodesXCoordinates[nodeIndex - 1] + deltaX;\n      }\n    } else if (this.elementOrder === \"quadratic\") {\n      totalNodesX = 2 * this.numElementsX + 1;\n      deltaX = (this.maxX - xStart) / this.numElementsX;\n\n      nodesXCoordinates[0] = xStart;\n      for (let nodeIndex = 1; nodeIndex < totalNodesX; nodeIndex++) {\n        nodesXCoordinates[nodeIndex] = nodesXCoordinates[nodeIndex - 1] + deltaX / 2;\n      }\n    }\n    // Generate nodal numbering (NOP) array\n    const nodalNumbering = this.generateNodalNumbering1D(this.numElementsX, totalNodesX, this.elementOrder);\n    // Find boundary elements\n    const boundaryElements = this.findBoundaryElements();\n\n    debugLog(\"Generated node X coordinates: \" + JSON.stringify(nodesXCoordinates));\n\n    // Return x coordinates of nodes, total nodes, NOP array, and boundary elements\n    return {\n      nodesXCoordinates,\n      totalNodesX,\n      nodalNumbering,\n      boundaryElements,\n    };\n  }\n\n  /**\n   * Function to generate the nodal numbering (NOP) array for a structured mesh\n   * This array represents the connectivity between elements and their corresponding nodes\n   * @param {number} numElementsX - Number of elements along the x-axis\n   * @param {number} totalNodesX - Total number of nodes along the x-axis\n   * @param {string} elementOrder - The order of elements, either 'linear' or 'quadratic'\n   * @returns {array} NOP - A two-dimensional array which represents the element-to-node connectivity for the entire mesh\n   */\n  generateNodalNumbering1D(numElementsX, totalNodesX, elementOrder) {\n    // TODO: The totalNodesX is not used in the original function. Verify if\n    // there is a multiple calculation on the totalNodes.\n\n    let elementIndex = 0;\n    let nop = [];\n\n    if (elementOrder === \"linear\") {\n      /**\n       * Linear 1D elements with the following nodes representation:\n       *\n       *   1 --- 2\n       *\n       */\n      for (let elementIndex = 0; elementIndex < numElementsX; elementIndex++) {\n        nop[elementIndex] = [];\n        for (let nodeIndex = 1; nodeIndex <= 2; nodeIndex++) {\n          nop[elementIndex][nodeIndex - 1] = elementIndex + nodeIndex;\n        }\n      }\n    } else if (elementOrder === \"quadratic\") {\n      /**\n       * Quadratic 1D elements with the following nodes representation:\n       *\n       *   1--2--3\n       *\n       */\n      let columnCounter = 0;\n      for (let elementIndex = 0; elementIndex < numElementsX; elementIndex++) {\n        nop[elementIndex] = [];\n        for (let nodeIndex = 1; nodeIndex <= 3; nodeIndex++) {\n          nop[elementIndex][nodeIndex - 1] = elementIndex + nodeIndex + columnCounter;\n        }\n        columnCounter += 1;\n      }\n    }\n\n    return nop;\n  }\n\n  /**\n   * Function to find the elements that belong to each boundary of an 1D domain\n   * @returns {array} An array containing arrays of elements and their adjacent boundary side for each boundary\n   * Each element in the array is of the form [elementIndex, side], where 'side' indicates which side\n   * of the reference element is in contact with the physical boundary:\n   * 0 - Left node of reference element (maps to physical left endpoint)\n   * 1 - Right node of reference element (maps to physical right endpoint)\n   */\n  findBoundaryElements() {\n    const boundaryElements = [];\n    const maxSides = 2; // Two sides for 1D case (left and right)\n    for (let sideIndex = 0; sideIndex < maxSides; sideIndex++) {\n      boundaryElements.push([]);\n    }\n\n    // Left boundary (element 0, side 0)\n    boundaryElements[0].push([0, 0]);\n\n    // Right boundary (last element, side 1)\n    boundaryElements[1].push([this.numElementsX - 1, 1]);\n\n    debugLog(\"Identified boundary elements by side: \" + JSON.stringify(boundaryElements));\n    this.boundaryElementsProcessed = true;\n    return boundaryElements;\n  }\n}\n\nexport class Mesh2D extends Mesh {\n  /**\n   * Constructor to initialize the 2D mesh\n   * @param {object} config - Configuration object for the 2D mesh\n   * @param {number} [config.numElementsX] - Number of elements along the x-axis (required for geometry-based mesh)\n   * @param {number} [config.maxX] - Maximum x-coordinate of the mesh (required for geometry-based mesh)\n   * @param {number} [config.numElementsY] - Number of elements along the y-axis (required for geometry-based mesh)\n   * @param {number} [config.maxY] - Maximum y-coordinate of the mesh (required for geometry-based mesh)\n   * @param {string} [config.elementOrder='linear'] - The order of elements, either 'linear' or 'quadratic'\n   * @param {object} [config.parsedMesh=null] - Optional pre-parsed mesh data\n   * @param {number} [config.angleLeft=90] - Left side skew angle in degrees (90 = vertical)\n   * @param {number} [config.angleRight=90] - Right side skew angle in degrees (90 = vertical)\n   */\n  constructor({\n    numElementsX = null,\n    maxX = null,\n    numElementsY = null,\n    maxY = null,\n    elementOrder = \"linear\",\n    parsedMesh = null,\n    angleLeft = 90,\n    angleRight = 90,\n  }) {\n    super({\n      numElementsX,\n      maxX,\n      numElementsY,\n      maxY,\n      meshDimension: \"2D\",\n      elementOrder,\n      parsedMesh,\n    });\n\n    this.angleLeft = angleLeft;\n    this.angleRight = angleRight;\n\n    // Validate geometry parameters (when not using a parsed mesh)\n    if (\n      !parsedMesh &&\n      (this.numElementsX === null || this.maxX === null || this.numElementsY === null || this.maxY === null)\n    ) {\n      errorLog(\n        \"numElementsX, maxX, numElementsY, and maxY are required parameters when generating a 2D mesh from geometry\"\n      );\n    }\n  }\n\n  generateMesh() {\n    let nodesXCoordinates = [];\n    let nodesYCoordinates = [];\n    const xStart = 0;\n    const yStart = 0;\n    let totalNodesX, totalNodesY, deltaX, deltaY;\n\n    if (this.elementOrder === \"linear\") {\n      totalNodesX = this.numElementsX + 1;\n      totalNodesY = this.numElementsY + 1;\n      deltaX = (this.maxX - xStart) / this.numElementsX;\n      deltaY = (this.maxY - yStart) / this.numElementsY;\n\n      nodesXCoordinates[0] = xStart;\n      nodesYCoordinates[0] = yStart;\n      for (let nodeIndexY = 1; nodeIndexY < totalNodesY; nodeIndexY++) {\n        nodesXCoordinates[nodeIndexY] = nodesXCoordinates[0];\n        nodesYCoordinates[nodeIndexY] = nodesYCoordinates[0] + nodeIndexY * deltaY;\n      }\n      for (let nodeIndexX = 1; nodeIndexX < totalNodesX; nodeIndexX++) {\n        const nnode = nodeIndexX * totalNodesY;\n        nodesXCoordinates[nnode] = nodesXCoordinates[0] + nodeIndexX * deltaX;\n        nodesYCoordinates[nnode] = nodesYCoordinates[0];\n        for (let nodeIndexY = 1; nodeIndexY < totalNodesY; nodeIndexY++) {\n          nodesXCoordinates[nnode + nodeIndexY] = nodesXCoordinates[nnode];\n          nodesYCoordinates[nnode + nodeIndexY] = nodesYCoordinates[nnode] + nodeIndexY * deltaY;\n        }\n      }\n    } else if (this.elementOrder === \"quadratic\") {\n      totalNodesX = 2 * this.numElementsX + 1;\n      totalNodesY = 2 * this.numElementsY + 1;\n      deltaX = (this.maxX - xStart) / this.numElementsX;\n      deltaY = (this.maxY - yStart) / this.numElementsY;\n\n      nodesXCoordinates[0] = xStart;\n      nodesYCoordinates[0] = yStart;\n      for (let nodeIndexY = 1; nodeIndexY < totalNodesY; nodeIndexY++) {\n        nodesXCoordinates[nodeIndexY] = nodesXCoordinates[0];\n        nodesYCoordinates[nodeIndexY] = nodesYCoordinates[0] + (nodeIndexY * deltaY) / 2;\n      }\n      for (let nodeIndexX = 1; nodeIndexX < totalNodesX; nodeIndexX++) {\n        const nnode = nodeIndexX * totalNodesY;\n        nodesXCoordinates[nnode] = nodesXCoordinates[0] + (nodeIndexX * deltaX) / 2;\n        nodesYCoordinates[nnode] = nodesYCoordinates[0];\n        for (let nodeIndexY = 1; nodeIndexY < totalNodesY; nodeIndexY++) {\n          nodesXCoordinates[nnode + nodeIndexY] = nodesXCoordinates[nnode];\n          nodesYCoordinates[nnode + nodeIndexY] = nodesYCoordinates[nnode] + (nodeIndexY * deltaY) / 2;\n        }\n      }\n    }\n\n    // Angles are measured from the positive X-axis:\n    // 90° = vertical sides (rectangle)\n    // angleLeft < 90°  => left side leans right as y increases\n    // angleLeft > 90°  => left side leans left\n    // angleRight < 90° => right side leans left\n    // angleRight > 90° => right side leans right\n    if (this.angleLeft !== 90 || this.angleRight !== 90) {\n      const degToRad = Math.PI / 180;\n      const tanLeft = Math.tan(this.angleLeft * degToRad);\n      const tanRight = Math.tan(this.angleRight * degToRad);\n      const epsilon = 1e-12;\n\n      for (let nodeIndexY = 0; nodeIndexY < totalNodesY; nodeIndexY++) {\n        const rowBaseIndex = nodeIndexY;\n        const y = nodesYCoordinates[rowBaseIndex];\n        const xLeft = Math.abs(tanLeft) < epsilon ? 0 : y / tanLeft;\n        const xRight = Math.abs(tanRight) < epsilon ? this.maxX : this.maxX - y / tanRight;\n\n        for (let nodeIndexX = 0; nodeIndexX < totalNodesX; nodeIndexX++) {\n          const nnode = nodeIndexX * totalNodesY + nodeIndexY;\n          const t = totalNodesX === 1 ? 0 : nodeIndexX / (totalNodesX - 1);\n          nodesXCoordinates[nnode] = xLeft + (xRight - xLeft) * t;\n        }\n      }\n    }\n\n    // Generate nodal numbering (NOP) array\n    const nodalNumbering = this.generateNodalNumbering2D(\n      this.numElementsX,\n      this.numElementsY,\n      totalNodesY,\n      this.elementOrder\n    );\n\n    // Find boundary elements\n    const boundaryElements = this.findBoundaryElements();\n\n    debugLog(\"Generated node X coordinates: \" + JSON.stringify(nodesXCoordinates));\n    debugLog(\"Generated node Y coordinates: \" + JSON.stringify(nodesYCoordinates));\n\n    // Return statement\n    return {\n      nodesXCoordinates,\n      nodesYCoordinates,\n      totalNodesX,\n      totalNodesY,\n      nodalNumbering,\n      boundaryElements,\n    };\n  }\n\n  /**\n   * Function to generate the nodal numbering (NOP) array for a structured mesh\n   * This array represents the connectivity between elements and their corresponding nodes\n   * @param {number} numElementsX - Number of elements along the x-axis\n   * @param {number} [numElementsY] - Number of elements along the y-axis (optional for 1D)\n   * @param {number} totalNodesX - Total number of nodes along the x-axis\n   * @param {number} [totalNodesY] - Total number of nodes along the y-axis (optional for 1D)\n   * @param {string} elementOrder - The order of elements, either 'linear' or 'quadratic'\n   * @returns {array} NOP - A two-dimensional array which represents the element-to-node connectivity for the entire mesh\n   */\n  generateNodalNumbering2D(numElementsX, numElementsY, totalNodesY, elementOrder) {\n    let elementIndex = 0;\n    let nop = [];\n\n    if (elementOrder === \"linear\") {\n      /**\n       * Linear rectangular elements with the following nodes representation:\n       *\n       *   1 --- 3\n       *   |     |\n       *   0 --- 2\n       *\n       */\n      let rowCounter = 0;\n      let columnCounter = 2;\n      for (let elementIndex = 0; elementIndex < numElementsX * numElementsY; elementIndex++) {\n        rowCounter += 1;\n        nop[elementIndex] = [];\n        nop[elementIndex][0] = elementIndex + columnCounter - 1;\n        nop[elementIndex][1] = elementIndex + columnCounter;\n        nop[elementIndex][2] = elementIndex + columnCounter + numElementsY;\n        nop[elementIndex][3] = elementIndex + columnCounter + numElementsY + 1;\n        if (rowCounter === numElementsY) {\n          columnCounter += 1;\n          rowCounter = 0;\n        }\n      }\n    } else if (elementOrder === \"quadratic\") {\n      /**\n       * Quadratic rectangular elements with the following nodes representation:\n       *\n       *   2--5--8\n       *   |     |\n       *   1  4  7\n       *   |     |\n       *   0--3--6\n       *\n       */\n      for (let elementIndexX = 1; elementIndexX <= numElementsX; elementIndexX++) {\n        for (let elementIndexY = 1; elementIndexY <= numElementsY; elementIndexY++) {\n          nop[elementIndex] = [];\n          for (let nodeIndex1 = 1; nodeIndex1 <= 3; nodeIndex1++) {\n            let nodeIndex2 = 3 * nodeIndex1 - 2;\n            nop[elementIndex][nodeIndex2 - 1] =\n              totalNodesY * (2 * elementIndexX + nodeIndex1 - 3) + 2 * elementIndexY - 1;\n            nop[elementIndex][nodeIndex2] = nop[elementIndex][nodeIndex2 - 1] + 1;\n            nop[elementIndex][nodeIndex2 + 1] = nop[elementIndex][nodeIndex2 - 1] + 2;\n          }\n          elementIndex = elementIndex + 1;\n        }\n      }\n    }\n\n    return nop;\n  }\n\n  /**\n   * Function to find the elements that belong to each boundary of a 2D domain\n   * @returns {array} An array containing arrays of elements and their adjacent boundary side for each boundary\n   * Each element in the array is of the form [elementIndex, side], where 'side' indicates which side\n   * of the reference element is in contact with the physical boundary:\n   * 0 - Bottom side of reference element (maps to physical bottom boundary in the case of a rectangular domain)\n   * 1 - Left side of reference element (maps to physical left boundary in the case of a rectangular domain)\n   * 2 - Top side of reference element (maps to physical top boundary in the case of a rectangular domain)\n   * 3 - Right side of reference element (maps to physical right boundary in the case of a rectangular domain)\n   */\n  findBoundaryElements() {\n    const boundaryElements = [];\n    const maxSides = 4; // Four sides for a rectangle 2D case (left, right, bottom, top)\n\n    for (let sideIndex = 0; sideIndex < maxSides; sideIndex++) {\n      boundaryElements.push([]);\n    }\n\n    // TODO: Why to loop through all elements? Is it not better to loop over only the\n    // elements that are on the boundary? eg: [0, this.numElementsX - 1] on x and\n    // [0, this.numElementsY - 1] on y\n    for (let elementIndexX = 0; elementIndexX < this.numElementsX; elementIndexX++) {\n      for (let elementIndexY = 0; elementIndexY < this.numElementsY; elementIndexY++) {\n        const elementIndex = elementIndexX * this.numElementsY + elementIndexY;\n\n        // Bottom boundary\n        if (elementIndexY === 0) {\n          boundaryElements[0].push([elementIndex, 0]);\n        }\n\n        // Left boundary\n        if (elementIndexX === 0) {\n          boundaryElements[1].push([elementIndex, 1]);\n        }\n\n        // Top boundary\n        if (elementIndexY === this.numElementsY - 1) {\n          boundaryElements[2].push([elementIndex, 2]);\n        }\n\n        // Right boundary\n        if (elementIndexX === this.numElementsX - 1) {\n          boundaryElements[3].push([elementIndex, 3]);\n        }\n      }\n    }\n\n    debugLog(\"Identified boundary elements by side: \" + JSON.stringify(boundaryElements));\n    this.boundaryElementsProcessed = true;\n    return boundaryElements;\n  }\n}\n","/**\n * ════════════════════════════════════════════════════════════════\n *  FEAScript Core Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.2.0 | https://feascript.com\n *  MIT License © 2023–2026 FEAScript\n * ════════════════════════════════════════════════════════════════\n */\n\n/**\n * Class to handle numerical integration using Gauss quadrature\n */\nexport class NumericalIntegration {\n  /**\n   * Constructor to initialize the NumericalIntegration class\n   * @param {string} meshDimension - The dimension of the mesh\n   * @param {string} elementOrder - The order of elements\n   */\n  constructor({ meshDimension, elementOrder }) {\n    this.meshDimension = meshDimension;\n    this.elementOrder = elementOrder;\n  }\n\n  /**\n   * Function to return Gauss points and weights based on element configuration\n   * @returns {object} An object containing:\n   *  - gaussPoints: Array of Gauss points\n   *  - gaussWeights: Array of Gauss weights\n   */\n  getGaussPointsAndWeights() {\n    let gaussPoints = []; // Gauss points\n    let gaussWeights = []; // Gauss weights\n\n    if (this.elementOrder === \"linear\") {\n      // For linear elements, use 1-point Gauss quadrature\n      gaussPoints[0] = 0.5;\n      gaussWeights[0] = 1;\n    } else if (this.elementOrder === \"quadratic\") {\n      // For quadratic elements, use 3-point Gauss quadrature\n      gaussPoints[0] = (1 - Math.sqrt(3 / 5)) / 2;\n      gaussPoints[1] = 0.5;\n      gaussPoints[2] = (1 + Math.sqrt(3 / 5)) / 2;\n      gaussWeights[0] = 5 / 18;\n      gaussWeights[1] = 8 / 18;\n      gaussWeights[2] = 5 / 18;\n    }\n\n    return { gaussPoints, gaussWeights };\n  }\n}\n","/**\n * ════════════════════════════════════════════════════════════════\n *  FEAScript Core Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.2.0 | https://feascript.com\n *  MIT License © 2023–2026 FEAScript\n * ════════════════════════════════════════════════════════════════\n */\n\n// Internal imports\nimport { BasisFunctions } from \"./basisFunctionsScript.js\";\nimport { Mesh1D, Mesh2D } from \"./meshGenerationScript.js\";\nimport { NumericalIntegration } from \"../methods/numericalIntegrationScript.js\";\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Function to prepare the mesh for finite element analysis\n * @param {object} meshConfig - Object containing computational mesh details\n * @returns {object} An object containing all mesh-related data\n */\nexport function prepareMesh(meshConfig) {\n  const {\n    meshDimension,\n    numElementsX,\n    numElementsY,\n    maxX,\n    maxY,\n    elementOrder,\n    parsedMesh,\n    angleLeft,\n    angleRight,\n  } = meshConfig;\n\n  // Create a new instance of the Mesh class\n  let mesh;\n  if (meshDimension === \"1D\") {\n    mesh = new Mesh1D({ numElementsX, maxX, elementOrder, parsedMesh });\n  } else if (meshDimension === \"2D\") {\n    mesh = new Mesh2D({\n      numElementsX,\n      maxX,\n      numElementsY,\n      maxY,\n      elementOrder,\n      parsedMesh,\n      angleLeft,\n      angleRight,\n    });\n  } else {\n    errorLog(\"Mesh dimension must be either '1D' or '2D'\");\n  }\n\n  // Use the parsed mesh (e.g., from a Gmsh .msh import) if provided. Otherwise, generate a structured mesh\n  const nodesCoordinatesAndNumbering = mesh.boundaryElementsProcessed ? mesh.parsedMesh : mesh.generateMesh();\n\n  // Extract nodes coordinates and nodal numbering (NOP) from the mesh data\n  let nodesXCoordinates = nodesCoordinatesAndNumbering.nodesXCoordinates;\n  let nodesYCoordinates = nodesCoordinatesAndNumbering.nodesYCoordinates;\n  let totalNodesX = nodesCoordinatesAndNumbering.totalNodesX;\n  let totalNodesY = nodesCoordinatesAndNumbering.totalNodesY;\n  let nop = nodesCoordinatesAndNumbering.nodalNumbering;\n  let boundaryElements = nodesCoordinatesAndNumbering.boundaryElements;\n\n  // Check the mesh type\n  const isParsedMesh = parsedMesh !== undefined && parsedMesh !== null;\n\n  // Calculate totalElements and totalNodes based on mesh type\n  let totalElements, totalNodes;\n\n  if (isParsedMesh) {\n    totalElements = nop.length; // Number of elements is the length of the nodal numbering array\n    totalNodes = nodesXCoordinates.length; // Number of nodes is the length of the coordinates array\n    debugLog(`Using parsed mesh with ${totalElements} elements and ${totalNodes} nodes`);\n  } else {\n    // For structured mesh, calculate based on dimensions\n    totalElements = numElementsX * (meshDimension === \"2D\" ? numElementsY : 1);\n    totalNodes = totalNodesX * (meshDimension === \"2D\" ? totalNodesY : 1);\n    debugLog(`Using mesh generated from geometry with ${totalElements} elements and ${totalNodes} nodes`);\n  }\n\n  return {\n    nodesXCoordinates,\n    nodesYCoordinates,\n    totalNodesX,\n    totalNodesY,\n    nop,\n    boundaryElements,\n    totalElements,\n    totalNodes,\n    meshDimension,\n    elementOrder,\n  };\n}\n\n/**\n * Function to initialize the FEA matrices and numerical tools\n * @param {object} meshData - Object containing mesh data from prepareMesh()\n * @returns {object} An object containing initialized matrices and numerical tools\n */\nexport function initializeFEA(meshData) {\n  const { totalNodes, nop, meshDimension, elementOrder } = meshData;\n\n  // Initialize variables for matrix assembly\n  let residualVector = [];\n  let jacobianMatrix = [];\n  let localToGlobalMap = [];\n\n  // Initialize jacobianMatrix and residualVector arrays\n  for (let nodeIndex = 0; nodeIndex < totalNodes; nodeIndex++) {\n    residualVector[nodeIndex] = 0;\n    jacobianMatrix.push([]);\n    for (let colIndex = 0; colIndex < totalNodes; colIndex++) {\n      jacobianMatrix[nodeIndex][colIndex] = 0;\n    }\n  }\n\n  // Initialize the BasisFunctions class\n  const basisFunctions = new BasisFunctions({\n    meshDimension,\n    elementOrder,\n  });\n\n  // Initialize the NumericalIntegration class\n  const numericalIntegration = new NumericalIntegration({\n    meshDimension,\n    elementOrder,\n  });\n\n  // Calculate Gauss points and weights\n  let gaussPointsAndWeights = numericalIntegration.getGaussPointsAndWeights();\n  let gaussPoints = gaussPointsAndWeights.gaussPoints;\n  let gaussWeights = gaussPointsAndWeights.gaussWeights;\n\n  // Determine the number of nodes in the reference element based on the first element in the nop array\n  const nodesPerElement = nop[0].length;\n\n  return {\n    residualVector,\n    jacobianMatrix,\n    localToGlobalMap,\n    basisFunctions,\n    gaussPoints,\n    gaussWeights,\n    nodesPerElement,\n  };\n}\n\n/**\n * Function to perform isoparametric mapping for 1D elements\n * @param {object} params - Parameters for the mapping\n * @returns {object} An object containing the mapped data\n */\nexport function performIsoparametricMapping1D(params) {\n  const { basisFunction, basisFunctionDerivKsi, nodesXCoordinates, localToGlobalMap, nodesPerElement } =\n    params;\n\n  let xCoordinates = 0;\n  let ksiDerivX = 0;\n\n  // Isoparametric mapping\n  for (let localNodeIndex = 0; localNodeIndex < nodesPerElement; localNodeIndex++) {\n    xCoordinates += nodesXCoordinates[localToGlobalMap[localNodeIndex]] * basisFunction[localNodeIndex];\n    ksiDerivX += nodesXCoordinates[localToGlobalMap[localNodeIndex]] * basisFunctionDerivKsi[localNodeIndex];\n  }\n  let detJacobian = ksiDerivX;\n\n  // Compute x-derivative of basis functions\n  let basisFunctionDerivX = [];\n  for (let localNodeIndex = 0; localNodeIndex < nodesPerElement; localNodeIndex++) {\n    basisFunctionDerivX[localNodeIndex] = basisFunctionDerivKsi[localNodeIndex] / detJacobian;\n  }\n\n  return {\n    xCoordinates,\n    detJacobian,\n    basisFunctionDerivX,\n  };\n}\n\n/**\n * Function to perform isoparametric mapping for 2D elements\n * @param {object} params - Parameters for the mapping\n * @returns {object} An object containing the mapped data\n */\nexport function performIsoparametricMapping2D(params) {\n  const {\n    basisFunction,\n    basisFunctionDerivKsi,\n    basisFunctionDerivEta,\n    nodesXCoordinates,\n    nodesYCoordinates,\n    localToGlobalMap,\n    nodesPerElement,\n  } = params;\n\n  let xCoordinates = 0;\n  let yCoordinates = 0;\n  let ksiDerivX = 0;\n  let etaDerivX = 0;\n  let ksiDerivY = 0;\n  let etaDerivY = 0;\n\n  // Isoparametric mapping\n  for (let localNodeIndex = 0; localNodeIndex < nodesPerElement; localNodeIndex++) {\n    xCoordinates += nodesXCoordinates[localToGlobalMap[localNodeIndex]] * basisFunction[localNodeIndex];\n    yCoordinates += nodesYCoordinates[localToGlobalMap[localNodeIndex]] * basisFunction[localNodeIndex];\n    ksiDerivX += nodesXCoordinates[localToGlobalMap[localNodeIndex]] * basisFunctionDerivKsi[localNodeIndex];\n    etaDerivX += nodesXCoordinates[localToGlobalMap[localNodeIndex]] * basisFunctionDerivEta[localNodeIndex];\n    ksiDerivY += nodesYCoordinates[localToGlobalMap[localNodeIndex]] * basisFunctionDerivKsi[localNodeIndex];\n    etaDerivY += nodesYCoordinates[localToGlobalMap[localNodeIndex]] * basisFunctionDerivEta[localNodeIndex];\n  }\n  let detJacobian = ksiDerivX * etaDerivY - etaDerivX * ksiDerivY;\n\n  // Compute x-derivative and y-derivative of basis functions\n  let basisFunctionDerivX = [];\n  let basisFunctionDerivY = [];\n  for (let localNodeIndex = 0; localNodeIndex < nodesPerElement; localNodeIndex++) {\n    // The x-derivative of the n basis function\n    basisFunctionDerivX[localNodeIndex] =\n      (etaDerivY * basisFunctionDerivKsi[localNodeIndex] -\n        ksiDerivY * basisFunctionDerivEta[localNodeIndex]) /\n      detJacobian;\n    // The y-derivative of the n basis function\n    basisFunctionDerivY[localNodeIndex] =\n      (ksiDerivX * basisFunctionDerivEta[localNodeIndex] -\n        etaDerivX * basisFunctionDerivKsi[localNodeIndex]) /\n      detJacobian;\n  }\n\n  return {\n    xCoordinates,\n    yCoordinates,\n    detJacobian,\n    basisFunctionDerivX,\n    basisFunctionDerivY,\n  };\n}\n\n/**\n * Function to test if a point is inside a triangle using barycentric coordinates,\n * also returning the natural coordinates (ksi, eta).\n * @param {number} x - X-coordinate of the point\n * @param {number} y - Y-coordinate of the point\n * @param {array} vertices - Triangle vertices [[x0,y0],[x1,y1],[x2,y2]]\n * @returns {object} Object containing inside boolean and natural coordinates {inside, ksi, eta}\n */\nexport function pointInsideTriangle(x, y, vertices) {\n  const tolerance = 1e-12;\n  const [v0, v1, v2] = vertices;\n\n  const denom = (v1[1] - v2[1]) * (v0[0] - v2[0]) + (v2[0] - v1[0]) * (v0[1] - v2[1]);\n\n  const ksi = ((v1[1] - v2[1]) * (x - v2[0]) + (v2[0] - v1[0]) * (y - v2[1])) / denom;\n  const eta = ((v2[1] - v0[1]) * (x - v2[0]) + (v0[0] - v2[0]) * (y - v2[1])) / denom;\n  const gamma = 1 - ksi - eta;\n\n  const inside = ksi >= -tolerance && eta >= -tolerance && gamma >= -tolerance;\n  return { inside, ksi, eta };\n}\n\n/**\n * Function to test if a point is inside a quadrilateral by spliting it into triangles and using barycentric coordinates\n * @param {number} x - X-coordinate of the point\n * @param {number} y - Y-coordinate of the point\n * @param {array} vertices - Quadrilateral vertices [[x0,y0],[x1,y1],[x2,y2],[x3,y3]]\n * @returns {object} Object containing inside boolean and natural coordinates {inside, ksi, eta}\n */\nexport function pointInsideQuadrilateral(x, y, vertices) {\n  const [firstTriangleVertices, secondTriangleVertices] = splitQuadrilateral(vertices);\n  const pointInsideFirstTriangle = pointInsideTriangle(x, y, firstTriangleVertices);\n  const pointInsideSecondTriangle = pointInsideTriangle(x, y, secondTriangleVertices);\n\n  const inside = pointInsideFirstTriangle.inside || pointInsideSecondTriangle.inside;\n  let ksi = 0;\n  let eta = 0;\n\n  if (inside) {\n    const [v0, v1, v2, v3] = vertices;\n\n    // Function to calculate distance from point to line segment\n    const getDistanceFromLine = (p1, p2) => {\n      const num = Math.abs((p2[0] - p1[0]) * (p1[1] - y) - (p1[0] - x) * (p2[1] - p1[1]));\n      const den = Math.sqrt((p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2);\n      return num / den;\n    };\n\n    // Calculate distances to edges based on vertex order:\n    //   1 (v1) --- 3 (v3)\n    //   |          |\n    //   0 (v0) --- 2 (v2)\n\n    const distLeft = getDistanceFromLine(v0, v1);\n    const distRight = getDistanceFromLine(v2, v3);\n    const distBottom = getDistanceFromLine(v0, v2);\n    const distTop = getDistanceFromLine(v1, v3);\n\n    ksi = distLeft / (distLeft + distRight);\n    eta = distBottom / (distBottom + distTop);\n  }\n\n  return { inside, ksi, eta };\n}\n\n/**\n * Function to split the quadrilateral elements into two triangles\n * @param {array} vertices - Quadrilateral vertices [[x0,y0],[x1,y1],[x2,y2],[x3,y3]]\n * @returns {array} Array of triangle vertices: [[v0,v1,v3], [v0,v2,v3]]\n */\nexport function splitQuadrilateral(vertices) {\n  const [v0, v1, v2, v3] = vertices;\n  // Vertices order:\n  //   1 --- 3\n  //   |     |\n  //   0 --- 2\n  return [\n    [v0, v1, v3],\n    [v0, v2, v3],\n  ];\n}\n\n/**\n * Function that finds the list of adjacent elements for each node in the mesh\n * @param {object} meshData - Object containing nodal numbering (NOP)\n * @returns {object} Object containing:\n *  - nodeNeighbors: Indices of neighboring elements per node\n *  - neighborCount: Total number of neighboring elements per node\n */\nexport function computeNodeNeighbors(meshData) {\n  const { nop, nodesXCoordinates } = meshData;\n  const totalNodes = nodesXCoordinates.length;\n  const nodesPerElement = nop[0].length;\n\n  // Initialize arrays\n  const nodeNeighbors = Array.from({ length: totalNodes }, () => []);\n  const neighborCount = Array(totalNodes).fill(0);\n\n  // Loop through all elements\n  for (let elemIndex = 0; elemIndex < nop.length; elemIndex++) {\n    for (let localNodeIndex = 0; localNodeIndex < nodesPerElement; localNodeIndex++) {\n      const nodeIndex = nop[elemIndex][localNodeIndex] - 1;\n\n      // Increment the total number of neighboring elements for this node\n      neighborCount[nodeIndex] = neighborCount[nodeIndex] + 1;\n\n      // Store the element index as a neighbor of this node\n      nodeNeighbors[nodeIndex].push(elemIndex);\n    }\n  }\n\n  return { nodeNeighbors, neighborCount };\n}\n\n/**\n * Function to extracts boundary line segments for ray casting\n * @param {object} meshData - Object containing mesh data\n * @returns {array} Array of segments\n */\nexport function getBoundarySegments(meshData) {\n  let boundaryLineElements = [];\n  let boundaryNodesSegments = [];\n  let boundaryGlobalElementIndex = 0;\n  let boundarySides;\n  const { nodesXCoordinates, nodesYCoordinates, nop, boundaryElements, meshDimension, elementOrder } =\n    meshData;\n\n  if (meshDimension === \"1D\") {\n    if (elementOrder === \"linear\") {\n      boundarySides = {\n        0: [0], // Node at the left side of the reference element\n        1: [1], // Node at the right side of the reference element\n      };\n    } else if (elementOrder === \"quadratic\") {\n      boundarySides = {\n        0: [0], // Node at the left side of the reference element\n        1: [1], // Node at the right side of the reference element\n      };\n    }\n  } else if (meshDimension === \"2D\") {\n    if (elementOrder === \"linear\") {\n      boundarySides = {\n        0: [0, 2], // Nodes at the bottom side of the reference element\n        1: [0, 1], // Nodes at the left side of the reference element\n        2: [1, 3], // Nodes at the top side of the reference element\n        3: [2, 3], // Nodes at the right side of the reference element\n      };\n    } else if (elementOrder === \"quadratic\") {\n      boundarySides = {\n        0: [0, 3, 6], // Nodes at the bottom side of the reference element\n        1: [0, 1, 2], // Nodes at the left side of the reference element\n        2: [2, 5, 8], // Nodes at the top side of the reference element\n        3: [6, 7, 8], // Nodes at the right side of the reference element\n      };\n    }\n  }\n\n  // Iterate over all boundaries\n  for (let boundaryIndex = 0; boundaryIndex < boundaryElements.length; boundaryIndex++) {\n    // Iterate over all elements in the current boundary\n    for (\n      let boundaryLocalElementIndex = 0;\n      boundaryLocalElementIndex < boundaryElements[boundaryIndex].length;\n      boundaryLocalElementIndex++\n    ) {\n      boundaryLineElements[boundaryGlobalElementIndex] =\n        boundaryElements[boundaryIndex][boundaryLocalElementIndex];\n      boundaryGlobalElementIndex++;\n      // Retrieve the element index and the side\n      const [elementIndex, side] = boundaryElements[boundaryIndex][boundaryLocalElementIndex];\n      let boundaryLocalNodeIndices = boundarySides[side];\n      let currentElementNodesX = [];\n      let currentElementNodesY = [];\n\n      for (\n        let boundaryLocalNodeIndex = 0;\n        boundaryLocalNodeIndex < boundaryLocalNodeIndices.length;\n        boundaryLocalNodeIndex++\n      ) {\n        const globalNodeIndex = nop[elementIndex][boundaryLocalNodeIndices[boundaryLocalNodeIndex]] - 1;\n\n        currentElementNodesX.push(nodesXCoordinates[globalNodeIndex]);\n        currentElementNodesY.push(nodesYCoordinates[globalNodeIndex]);\n      }\n\n      // Create segments for this element\n      for (let k = 0; k < currentElementNodesX.length - 1; k++) {\n        boundaryNodesSegments.push([\n          [currentElementNodesX[k], currentElementNodesY[k]],\n          [currentElementNodesX[k + 1], currentElementNodesY[k + 1]],\n        ]);\n      }\n    }\n  }\n  return boundaryNodesSegments;\n}\n","/**\n * ════════════════════════════════════════════════════════════════\n *  FEAScript Core Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.2.0 | https://feascript.com\n *  MIT License © 2023–2026 FEAScript\n * ════════════════════════════════════════════════════════════════\n */\n\n// Internal imports\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Class to handle thermal boundary conditions application\n */\nexport class ThermalBoundaryConditions {\n  /**\n   * Constructor to initialize the ThermalBoundaryConditions class\n   * @param {object} boundaryConditions - Object containing boundary conditions for the finite element analysis\n   * @param {array} boundaryElements - Array containing elements that belong to each boundary\n   * @param {array} nop - Nodal numbering (NOP) array representing the connectivity between elements and nodes\n   * @param {string} meshDimension - The dimension of the mesh (e.g., \"2D\")\n   * @param {string} elementOrder - The order of elements (e.g., \"linear\", \"quadratic\")\n   */\n  constructor(boundaryConditions, boundaryElements, nop, meshDimension, elementOrder) {\n    this.boundaryConditions = boundaryConditions;\n    this.boundaryElements = boundaryElements;\n    this.nop = nop;\n    this.meshDimension = meshDimension;\n    this.elementOrder = elementOrder;\n  }\n\n  /**\n   * Function to impose constant temperature boundary conditions (Dirichlet type)\n   * @param {array} residualVector - The residual vector to be modified\n   * @param {array} jacobianMatrix - The Jacobian matrix to be modified\n   *\n   * For consistency across both linear and nonlinear formulations,\n   * this project always refers to the assembled right-hand side vector\n   * as `residualVector` and the assembled system matrix as `jacobianMatrix`.\n   *\n   * In linear problems `jacobianMatrix` is equivalent to the\n   * classic stiffness/conductivity matrix and `residualVector`\n   * corresponds to the traditional load (RHS) vector.\n   */\n  imposeConstantTempBoundaryConditions(residualVector, jacobianMatrix) {\n    if (this.meshDimension === \"1D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        if (this.boundaryConditions[boundaryKey][0] === \"constantTemp\") {\n          const tempValue = this.boundaryConditions[boundaryKey][1];\n          debugLog(\n            `Boundary ${boundaryKey}: Applying constant temperature of ${tempValue} K (Dirichlet condition)`\n          );\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            if (this.elementOrder === \"linear\") {\n              const boundarySides = {\n                0: [0], // Node at the left side of the reference element\n                1: [1], // Node at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant temperature to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                // Set the residual vector to the ConstantTemp value\n                residualVector[globalNodeIndex] = tempValue;\n                // Set the Jacobian matrix row to zero\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\n                }\n                // Set the diagonal entry of the Jacobian matrix to one\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\n              });\n            } else if (this.elementOrder === \"quadratic\") {\n              const boundarySides = {\n                0: [0], // Node at the left side of the reference element\n                1: [2], // Node at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant temperature to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                // Set the residual vector to the ConstantTemp value\n                residualVector[globalNodeIndex] = tempValue;\n                // Set the Jacobian matrix row to zero\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\n                }\n                // Set the diagonal entry of the Jacobian matrix to one\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\n              });\n            }\n          });\n        }\n      });\n    } else if (this.meshDimension === \"2D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        if (this.boundaryConditions[boundaryKey][0] === \"constantTemp\") {\n          const tempValue = this.boundaryConditions[boundaryKey][1];\n          debugLog(\n            `Boundary ${boundaryKey}: Applying constant temperature of ${tempValue} K (Dirichlet condition)`\n          );\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            if (this.elementOrder === \"linear\") {\n              const boundarySides = {\n                0: [0, 2], // Nodes at the bottom side of the reference element\n                1: [0, 1], // Nodes at the left side of the reference element\n                2: [1, 3], // Nodes at the top side of the reference element\n                3: [2, 3], // Nodes at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant temperature to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                // Set the residual vector to the ConstantTemp value\n                residualVector[globalNodeIndex] = tempValue;\n                // Set the Jacobian matrix row to zero\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\n                }\n                // Set the diagonal entry of the Jacobian matrix to one\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\n              });\n            } else if (this.elementOrder === \"quadratic\") {\n              const boundarySides = {\n                0: [0, 3, 6], // Nodes at the bottom side of the reference element\n                1: [0, 1, 2], // Nodes at the left side of the reference element\n                2: [2, 5, 8], // Nodes at the top side of the reference element\n                3: [6, 7, 8], // Nodes at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant temperature to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                // Set the residual vector to the ConstantTemp value\n                residualVector[globalNodeIndex] = tempValue;\n                // Set the Jacobian matrix row to zero\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\n                }\n                // Set the diagonal entry of the Jacobian matrix to one\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\n              });\n            }\n          });\n        }\n      });\n    }\n  }\n\n  /**\n   * Function to impose constant temperature boundary conditions for the frontal solver\n   * @param {array} nodeConstraintCode - Array indicating boundary condition code for each node\n   * @param {array} boundaryValues - Array containing boundary condition values\n   */\n  imposeConstantTempBoundaryConditionsFront(nodeConstraintCode, boundaryValues) {\n    if (this.meshDimension === \"1D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        if (this.boundaryConditions[boundaryKey][0] === \"constantTemp\") {\n          const tempValue = this.boundaryConditions[boundaryKey][1];\n          debugLog(\n            `Boundary ${boundaryKey}: Applying constant temperature of ${tempValue} K (Dirichlet condition)`\n          );\n\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            if (this.elementOrder === \"linear\") {\n              const boundarySides = {\n                0: [0], // Node at the left side of the reference element\n                1: [1], // Node at the right side of the reference element\n              };\n\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant temperature to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n\n                // Set boundary condition code and value\n                nodeConstraintCode[globalNodeIndex] = 1;\n                boundaryValues[globalNodeIndex] = tempValue;\n              });\n            } else if (this.elementOrder === \"quadratic\") {\n              const boundarySides = {\n                0: [0], // Node at the left side of the reference element\n                2: [2], // Node at the right side of the reference element\n              };\n\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant temperature to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n\n                // Set boundary condition code and value\n                nodeConstraintCode[globalNodeIndex] = 1;\n                boundaryValues[globalNodeIndex] = tempValue;\n              });\n            }\n          });\n        }\n      });\n    } else if (this.meshDimension === \"2D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        if (this.boundaryConditions[boundaryKey][0] === \"constantTemp\") {\n          const tempValue = this.boundaryConditions[boundaryKey][1];\n          debugLog(\n            `Boundary ${boundaryKey}: Applying constant temperature of ${tempValue} K (Dirichlet condition)`\n          );\n\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            if (this.elementOrder === \"linear\") {\n              const boundarySides = {\n                0: [0, 2], // Nodes at the bottom side of the reference element\n                1: [0, 1], // Nodes at the left side of the reference element\n                2: [1, 3], // Nodes at the top side of the reference element\n                3: [2, 3], // Nodes at the right side of the reference element\n              };\n\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant temperature to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n\n                // Set boundary condition code and value\n                nodeConstraintCode[globalNodeIndex] = 1;\n                boundaryValues[globalNodeIndex] = tempValue;\n              });\n            } else if (this.elementOrder === \"quadratic\") {\n              const boundarySides = {\n                0: [0, 3, 6], // Nodes at the bottom side of the reference element\n                1: [0, 1, 2], // Nodes at the left side of the reference element\n                2: [2, 5, 8], // Nodes at the top side of the reference element\n                3: [6, 7, 8], // Nodes at the right side of the reference element\n              };\n\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant temperature to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n\n                // Set boundary condition code and value\n                nodeConstraintCode[globalNodeIndex] = 1;\n                boundaryValues[globalNodeIndex] = tempValue;\n              });\n            }\n          });\n        }\n      });\n    }\n  }\n\n  /**\n   * Function to impose convection boundary conditions (Robin type)\n   * @param {array} residualVector - The residual vector to be modified\n   * @param {array} jacobianMatrix - The Jacobian matrix to be modified\n   * @param {array} gaussPoints - Array of Gauss points for numerical integration\n   * @param {array} gaussWeights - Array of Gauss weights for numerical integration\n   * @param {array} nodesXCoordinates - Array of x-coordinates of nodes\n   * @param {array} nodesYCoordinates - Array of y-coordinates of nodes\n   * @param {object} basisFunctions - Object containing basis functions and their derivatives\n   */\n  imposeConvectionBoundaryConditions(\n    residualVector,\n    jacobianMatrix,\n    gaussPoints,\n    gaussWeights,\n    nodesXCoordinates,\n    nodesYCoordinates,\n    basisFunctions\n  ) {\n    // Extract convection parameters from boundary conditions\n    let convectionHeatTranfCoeff = [];\n    let convectionExtTemp = [];\n    Object.keys(this.boundaryConditions).forEach((key) => {\n      const boundaryCondition = this.boundaryConditions[key];\n      if (boundaryCondition[0] === \"convection\") {\n        convectionHeatTranfCoeff[key] = boundaryCondition[1];\n        convectionExtTemp[key] = boundaryCondition[2];\n      }\n    });\n\n    if (this.meshDimension === \"1D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        if (this.boundaryConditions[boundaryKey][0] === \"convection\") {\n          const convectionCoeff = convectionHeatTranfCoeff[boundaryKey];\n          const extTemp = convectionExtTemp[boundaryKey];\n          debugLog(\n            `Boundary ${boundaryKey}: Applying convection with heat transfer coefficient h=${convectionCoeff} W/(m²·K) and external temperature T∞=${extTemp} K`\n          );\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            let nodeIndex;\n            if (this.elementOrder === \"linear\") {\n              if (side === 0) {\n                // Node at the left side of the reference element\n                nodeIndex = 0;\n              } else {\n                // Node at the right side of the reference element\n                nodeIndex = 1;\n              }\n            } else if (this.elementOrder === \"quadratic\") {\n              if (side === 0) {\n                // Node at the left side of the reference element\n                nodeIndex = 0;\n              } else {\n                // Node at the right side of the reference element\n                nodeIndex = 2;\n              }\n            }\n\n            const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n            debugLog(\n              `  - Applied convection boundary condition to node ${globalNodeIndex + 1} (element ${\n                elementIndex + 1\n              }, local node ${nodeIndex + 1})`\n            );\n            residualVector[globalNodeIndex] += -convectionCoeff * extTemp;\n            jacobianMatrix[globalNodeIndex][globalNodeIndex] += convectionCoeff;\n          });\n        }\n      });\n    } else if (this.meshDimension === \"2D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        if (this.boundaryConditions[boundaryKey][0] === \"convection\") {\n          const convectionCoeff = convectionHeatTranfCoeff[boundaryKey];\n          const extTemp = convectionExtTemp[boundaryKey];\n          debugLog(\n            `Boundary ${boundaryKey}: Applying convection with heat transfer coefficient h=${convectionCoeff} W/(m²·K) and external temperature T∞=${extTemp} K`\n          );\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            if (this.elementOrder === \"linear\") {\n              let gaussPoint1, gaussPoint2, firstNodeIndex, lastNodeIndex, nodeIncrement;\n              if (side === 0) {\n                // Nodes at the bottom side of the reference element\n                gaussPoint1 = gaussPoints[0];\n                gaussPoint2 = 0;\n                firstNodeIndex = 0;\n                lastNodeIndex = 3;\n                nodeIncrement = 2;\n              } else if (side === 1) {\n                // Nodes at the left side of the reference element\n                gaussPoint1 = 0;\n                gaussPoint2 = gaussPoints[0];\n                firstNodeIndex = 0;\n                lastNodeIndex = 2;\n                nodeIncrement = 1;\n              } else if (side === 2) {\n                // Nodes at the top side of the reference element\n                gaussPoint1 = gaussPoints[0];\n                gaussPoint2 = 1;\n                firstNodeIndex = 1;\n                lastNodeIndex = 4;\n                nodeIncrement = 2;\n              } else if (side === 3) {\n                // Nodes at the right side of the reference element\n                gaussPoint1 = 1;\n                gaussPoint2 = gaussPoints[0];\n                firstNodeIndex = 2;\n                lastNodeIndex = 4;\n                nodeIncrement = 1;\n              }\n\n              let basisFunctionsAndDerivatives = basisFunctions.getBasisFunctions(gaussPoint1, gaussPoint2);\n              let basisFunction = basisFunctionsAndDerivatives.basisFunction;\n              let basisFunctionDerivKsi = basisFunctionsAndDerivatives.basisFunctionDerivKsi;\n              let basisFunctionDerivEta = basisFunctionsAndDerivatives.basisFunctionDerivEta;\n\n              let ksiDerivX = 0;\n              let ksiDerivY = 0;\n              let etaDerivX = 0;\n              let etaDerivY = 0;\n              const nodesPerElement = this.nop[elementIndex].length;\n              for (let nodeIndex = 0; nodeIndex < nodesPerElement; nodeIndex++) {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n\n                // For boundaries along Ksi (horizontal), use Ksi derivatives\n                if (side === 0 || side === 2) {\n                  ksiDerivX += nodesXCoordinates[globalNodeIndex] * basisFunctionDerivKsi[nodeIndex];\n                  ksiDerivY += nodesYCoordinates[globalNodeIndex] * basisFunctionDerivKsi[nodeIndex];\n                }\n                // For boundaries along Eta (vertical), use Eta derivatives\n                else if (side === 1 || side === 3) {\n                  etaDerivX += nodesXCoordinates[globalNodeIndex] * basisFunctionDerivEta[nodeIndex];\n                  etaDerivY += nodesYCoordinates[globalNodeIndex] * basisFunctionDerivEta[nodeIndex];\n                }\n              }\n\n              // Compute the length of tangent vector\n              let tangentVectorLength;\n              if (side === 0 || side === 2) {\n                tangentVectorLength = Math.sqrt(ksiDerivX ** 2 + ksiDerivY ** 2);\n              } else {\n                tangentVectorLength = Math.sqrt(etaDerivX ** 2 + etaDerivY ** 2);\n              }\n\n              for (\n                let localNodeIndex = firstNodeIndex;\n                localNodeIndex < lastNodeIndex;\n                localNodeIndex += nodeIncrement\n              ) {\n                let globalNodeIndex = this.nop[elementIndex][localNodeIndex] - 1;\n                debugLog(\n                  `  - Applied convection boundary condition to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${localNodeIndex + 1})`\n                );\n\n                // Apply boundary condition with proper Jacobian for all sides\n                residualVector[globalNodeIndex] +=\n                  -gaussWeights[0] *\n                  tangentVectorLength *\n                  basisFunction[localNodeIndex] *\n                  convectionCoeff *\n                  extTemp;\n\n                for (\n                  let localNodeIndex2 = firstNodeIndex;\n                  localNodeIndex2 < lastNodeIndex;\n                  localNodeIndex2 += nodeIncrement\n                ) {\n                  let globalNodeIndex2 = this.nop[elementIndex][localNodeIndex2] - 1;\n                  jacobianMatrix[globalNodeIndex][globalNodeIndex2] +=\n                    -gaussWeights[0] *\n                    tangentVectorLength *\n                    basisFunction[localNodeIndex] *\n                    basisFunction[localNodeIndex2] *\n                    convectionCoeff;\n                }\n              }\n            } else if (this.elementOrder === \"quadratic\") {\n              for (let gaussPointIndex = 0; gaussPointIndex < 3; gaussPointIndex++) {\n                let gaussPoint1, gaussPoint2, firstNodeIndex, lastNodeIndex, nodeIncrement;\n                if (side === 0) {\n                  // Nodes at the bottom side of the reference element\n                  gaussPoint1 = gaussPoints[gaussPointIndex];\n                  gaussPoint2 = 0;\n                  firstNodeIndex = 0;\n                  lastNodeIndex = 7;\n                  nodeIncrement = 3;\n                } else if (side === 1) {\n                  // Nodes at the left side of the reference element\n                  gaussPoint1 = 0;\n                  gaussPoint2 = gaussPoints[gaussPointIndex];\n                  firstNodeIndex = 0;\n                  lastNodeIndex = 3;\n                  nodeIncrement = 1;\n                } else if (side === 2) {\n                  // Nodes at the top side of the reference element\n                  gaussPoint1 = gaussPoints[gaussPointIndex];\n                  gaussPoint2 = 1;\n                  firstNodeIndex = 2;\n                  lastNodeIndex = 9;\n                  nodeIncrement = 3;\n                } else if (side === 3) {\n                  // Nodes at the right side of the reference element\n                  gaussPoint1 = 1;\n                  gaussPoint2 = gaussPoints[gaussPointIndex];\n                  firstNodeIndex = 6;\n                  lastNodeIndex = 9;\n                  nodeIncrement = 1;\n                }\n                let basisFunctionsAndDerivatives = basisFunctions.getBasisFunctions(gaussPoint1, gaussPoint2);\n                let basisFunction = basisFunctionsAndDerivatives.basisFunction;\n                let basisFunctionDerivKsi = basisFunctionsAndDerivatives.basisFunctionDerivKsi;\n                let basisFunctionDerivEta = basisFunctionsAndDerivatives.basisFunctionDerivEta;\n\n                let ksiDerivX = 0;\n                let ksiDerivY = 0;\n                let etaDerivX = 0;\n                let etaDerivY = 0;\n                const nodesPerElement = this.nop[elementIndex].length;\n                for (let nodeIndex = 0; nodeIndex < nodesPerElement; nodeIndex++) {\n                  const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n\n                  // For boundaries along Ksi (horizontal), use Ksi derivatives\n                  if (side === 0 || side === 2) {\n                    ksiDerivX += nodesXCoordinates[globalNodeIndex] * basisFunctionDerivKsi[nodeIndex];\n                    ksiDerivY += nodesYCoordinates[globalNodeIndex] * basisFunctionDerivKsi[nodeIndex];\n                  }\n                  // For boundaries along Eta (vertical), use Eta derivatives\n                  else if (side === 1 || side === 3) {\n                    etaDerivX += nodesXCoordinates[globalNodeIndex] * basisFunctionDerivEta[nodeIndex];\n                    etaDerivY += nodesYCoordinates[globalNodeIndex] * basisFunctionDerivEta[nodeIndex];\n                  }\n                }\n\n                // Compute the length of tangent vector\n                let tangentVectorLength;\n                if (side === 0 || side === 2) {\n                  tangentVectorLength = Math.sqrt(ksiDerivX ** 2 + ksiDerivY ** 2);\n                } else {\n                  tangentVectorLength = Math.sqrt(etaDerivX ** 2 + etaDerivY ** 2);\n                }\n\n                for (\n                  let localNodeIndex = firstNodeIndex;\n                  localNodeIndex < lastNodeIndex;\n                  localNodeIndex += nodeIncrement\n                ) {\n                  let globalNodeIndex = this.nop[elementIndex][localNodeIndex] - 1;\n                  debugLog(\n                    `  - Applied convection boundary condition to node ${globalNodeIndex + 1} (element ${\n                      elementIndex + 1\n                    }, local node ${localNodeIndex + 1})`\n                  );\n\n                  // Apply boundary condition with proper Jacobian for all sides\n                  residualVector[globalNodeIndex] +=\n                    -gaussWeights[gaussPointIndex] *\n                    tangentVectorLength *\n                    basisFunction[localNodeIndex] *\n                    convectionCoeff *\n                    extTemp;\n\n                  for (\n                    let localNodeIndex2 = firstNodeIndex;\n                    localNodeIndex2 < lastNodeIndex;\n                    localNodeIndex2 += nodeIncrement\n                  ) {\n                    let globalNodeIndex2 = this.nop[elementIndex][localNodeIndex2] - 1;\n                    jacobianMatrix[globalNodeIndex][globalNodeIndex2] +=\n                      -gaussWeights[gaussPointIndex] *\n                      tangentVectorLength *\n                      basisFunction[localNodeIndex] *\n                      basisFunction[localNodeIndex2] *\n                      convectionCoeff;\n                  }\n                }\n              }\n            }\n          });\n        }\n      });\n    }\n  }\n\n  /**\n   * Function to impose convection boundary conditions for the frontal solver\n   * @param {number} elementIndex - Index of the element being processed\n   * @param {array} nodesXCoordinates - Array of x-coordinates of nodes\n   * @param {array} nodesYCoordinates - Array of y-coordinates of nodes\n   * @param {array} gaussPoints - Array of Gauss points for numerical integration\n   * @param {array} gaussWeights - Array of Gauss weights for numerical integration\n   * @param {object} basisFunctions - Object containing basis functions and their derivatives\n   * @returns {object} An object containing:\n   *  - localJacobianMatrix: Local Jacobian matrix with convection contributions\n   *  - localResidualVector: Residual vector with convection contributions\n   */\n  imposeConvectionBoundaryConditionsFront(\n    elementIndex,\n    nodesXCoordinates,\n    nodesYCoordinates,\n    gaussPoints,\n    gaussWeights,\n    basisFunctions\n  ) {\n    // Extract convection parameters from boundary conditions\n    let convectionHeatTranfCoeff = [];\n    let convectionExtTemp = [];\n    Object.keys(this.boundaryConditions).forEach((key) => {\n      const boundaryCondition = this.boundaryConditions[key];\n      if (boundaryCondition[0] === \"convection\") {\n        convectionHeatTranfCoeff[key] = boundaryCondition[1];\n        convectionExtTemp[key] = boundaryCondition[2];\n      }\n    });\n\n    // Initialize local Jacobian matrix and local residual vector\n    const nodesPerElement = this.nop[elementIndex].length;\n    const localJacobianMatrix = Array(nodesPerElement)\n      .fill()\n      .map(() => Array(nodesPerElement).fill(0));\n    const localResidualVector = Array(nodesPerElement).fill(0);\n\n    // Check if this element is on a convection boundary\n    for (const boundaryKey in this.boundaryElements) {\n      if (this.boundaryConditions[boundaryKey]?.[0] === \"convection\") {\n        const convectionCoeff = convectionHeatTranfCoeff[boundaryKey];\n        const extTemp = convectionExtTemp[boundaryKey];\n        debugLog(\n          `Boundary ${boundaryKey}: Applying convection with heat transfer coefficient h=${convectionCoeff} W/(m²·K) and external temperature T∞=${extTemp} K`\n        );\n\n        // Find if this element is on this boundary and which side\n        const boundaryElement = this.boundaryElements[boundaryKey].find(\n          ([boundaryElementIndex, _]) => boundaryElementIndex === elementIndex\n        );\n\n        if (boundaryElement) {\n          const side = boundaryElement[1];\n\n          if (this.meshDimension === \"1D\") {\n            // Handle 1D case\n            let nodeIndex;\n            if (this.elementOrder === \"linear\") {\n              nodeIndex = side === 0 ? 0 : 1;\n            } else if (this.elementOrder === \"quadratic\") {\n              nodeIndex = side === 0 ? 0 : 2;\n            }\n\n            // Add contribution to local Jacobian matrix and local residual vector\n            debugLog(\n              `  - Applied convection boundary condition to node ${nodeIndex + 1} (element ${\n                elementIndex + 1\n              }, local node ${nodeIndex + 1})`\n            );\n            localResidualVector[nodeIndex] += -convectionCoeff * extTemp;\n            localJacobianMatrix[nodeIndex][nodeIndex] += convectionCoeff;\n          } else if (this.meshDimension === \"2D\") {\n            // Handle 2D case\n            if (this.elementOrder === \"linear\") {\n              let gaussPoint1, gaussPoint2, firstNodeIndex, lastNodeIndex, nodeIncrement;\n\n              if (side === 0) {\n                // Nodes at the bottom side of the reference element\n                gaussPoint1 = gaussPoints[0];\n                gaussPoint2 = 0;\n                firstNodeIndex = 0;\n                lastNodeIndex = 3;\n                nodeIncrement = 2;\n              } else if (side === 1) {\n                // Nodes at the left side of the reference element\n                gaussPoint1 = 0;\n                gaussPoint2 = gaussPoints[0];\n                firstNodeIndex = 0;\n                lastNodeIndex = 2;\n                nodeIncrement = 1;\n              } else if (side === 2) {\n                // Nodes at the top side of the reference element\n                gaussPoint1 = gaussPoints[0];\n                gaussPoint2 = 1;\n                firstNodeIndex = 1;\n                lastNodeIndex = 4;\n                nodeIncrement = 2;\n              } else if (side === 3) {\n                // Nodes at the right side of the reference element\n                gaussPoint1 = 1;\n                gaussPoint2 = gaussPoints[0];\n                firstNodeIndex = 2;\n                lastNodeIndex = 4;\n                nodeIncrement = 1;\n              }\n\n              // Get basis functions\n              const basisFunctionsAndDerivatives = basisFunctions.getBasisFunctions(gaussPoint1, gaussPoint2);\n              const basisFunction = basisFunctionsAndDerivatives.basisFunction;\n              const basisFunctionDerivKsi = basisFunctionsAndDerivatives.basisFunctionDerivKsi;\n              const basisFunctionDerivEta = basisFunctionsAndDerivatives.basisFunctionDerivEta;\n\n              // Calculate tangent vector components\n              let ksiDerivX = 0,\n                ksiDerivY = 0,\n                etaDerivX = 0,\n                etaDerivY = 0;\n              for (let nodeIndex = 0; nodeIndex < nodesPerElement; nodeIndex++) {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n\n                if (side === 0 || side === 2) {\n                  ksiDerivX += nodesXCoordinates[globalNodeIndex] * basisFunctionDerivKsi[nodeIndex];\n                  ksiDerivY += nodesYCoordinates[globalNodeIndex] * basisFunctionDerivKsi[nodeIndex];\n                } else if (side === 1 || side === 3) {\n                  etaDerivX += nodesXCoordinates[globalNodeIndex] * basisFunctionDerivEta[nodeIndex];\n                  etaDerivY += nodesYCoordinates[globalNodeIndex] * basisFunctionDerivEta[nodeIndex];\n                }\n              }\n\n              // Compute tangent vector length\n              let tangentVectorLength;\n              if (side === 0 || side === 2) {\n                tangentVectorLength = Math.sqrt(ksiDerivX ** 2 + ksiDerivY ** 2);\n              } else {\n                tangentVectorLength = Math.sqrt(etaDerivX ** 2 + etaDerivY ** 2);\n              }\n\n              // Apply boundary conditions to local matrices\n              for (\n                let localNodeIndex = firstNodeIndex;\n                localNodeIndex < lastNodeIndex;\n                localNodeIndex += nodeIncrement\n              ) {\n                localResidualVector[localNodeIndex] +=\n                  -gaussWeights[0] *\n                  tangentVectorLength *\n                  basisFunction[localNodeIndex] *\n                  convectionCoeff *\n                  extTemp;\n\n                for (\n                  let localNodeIndex2 = firstNodeIndex;\n                  localNodeIndex2 < lastNodeIndex;\n                  localNodeIndex2 += nodeIncrement\n                ) {\n                  localJacobianMatrix[localNodeIndex][localNodeIndex2] +=\n                    -gaussWeights[0] *\n                    tangentVectorLength *\n                    basisFunction[localNodeIndex] *\n                    basisFunction[localNodeIndex2] *\n                    convectionCoeff;\n                }\n              }\n            } else if (this.elementOrder === \"quadratic\") {\n              // Handle quadratic elements (similar pattern but with more Gauss points)\n              for (let gaussPointIndex = 0; gaussPointIndex < 3; gaussPointIndex++) {\n                let gaussPoint1, gaussPoint2, firstNodeIndex, lastNodeIndex, nodeIncrement;\n\n                if (side === 0) {\n                  // Nodes at the bottom side of the reference element\n                  gaussPoint1 = gaussPoints[gaussPointIndex];\n                  gaussPoint2 = 0;\n                  firstNodeIndex = 0;\n                  lastNodeIndex = 7;\n                  nodeIncrement = 3;\n                } else if (side === 1) {\n                  // Nodes at the left side of the reference element\n                  gaussPoint1 = 0;\n                  gaussPoint2 = gaussPoints[gaussPointIndex];\n                  firstNodeIndex = 0;\n                  lastNodeIndex = 3;\n                  nodeIncrement = 1;\n                } else if (side === 2) {\n                  // Nodes at the top side of the reference element\n                  gaussPoint1 = gaussPoints[gaussPointIndex];\n                  gaussPoint2 = 1;\n                  firstNodeIndex = 2;\n                  lastNodeIndex = 9;\n                  nodeIncrement = 3;\n                } else if (side === 3) {\n                  // Nodes at the right side of the reference element\n                  gaussPoint1 = 1;\n                  gaussPoint2 = gaussPoints[gaussPointIndex];\n                  firstNodeIndex = 6;\n                  lastNodeIndex = 9;\n                  nodeIncrement = 1;\n                }\n                let basisFunctionsAndDerivatives = basisFunctions.getBasisFunctions(gaussPoint1, gaussPoint2);\n                let basisFunction = basisFunctionsAndDerivatives.basisFunction;\n                let basisFunctionDerivKsi = basisFunctionsAndDerivatives.basisFunctionDerivKsi;\n                let basisFunctionDerivEta = basisFunctionsAndDerivatives.basisFunctionDerivEta;\n\n                let ksiDerivX = 0;\n                let ksiDerivY = 0;\n                let etaDerivX = 0;\n                let etaDerivY = 0;\n                const nodesPerElement = this.nop[elementIndex].length;\n                for (let nodeIndex = 0; nodeIndex < nodesPerElement; nodeIndex++) {\n                  const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n\n                  // For boundaries along Ksi (horizontal), use Ksi derivatives\n                  if (side === 0 || side === 2) {\n                    ksiDerivX += nodesXCoordinates[globalNodeIndex] * basisFunctionDerivKsi[nodeIndex];\n                    ksiDerivY += nodesYCoordinates[globalNodeIndex] * basisFunctionDerivKsi[nodeIndex];\n                  }\n                  // For boundaries along Eta (vertical), use Eta derivatives\n                  else if (side === 1 || side === 3) {\n                    etaDerivX += nodesXCoordinates[globalNodeIndex] * basisFunctionDerivEta[nodeIndex];\n                    etaDerivY += nodesYCoordinates[globalNodeIndex] * basisFunctionDerivEta[nodeIndex];\n                  }\n                }\n\n                // Compute the length of tangent vector\n                let tangentVectorLength;\n                if (side === 0 || side === 2) {\n                  tangentVectorLength = Math.sqrt(ksiDerivX ** 2 + ksiDerivY ** 2);\n                } else {\n                  tangentVectorLength = Math.sqrt(etaDerivX ** 2 + etaDerivY ** 2);\n                }\n\n                // Apply boundary conditions to local matrices\n                for (\n                  let localNodeIndex = firstNodeIndex;\n                  localNodeIndex < lastNodeIndex;\n                  localNodeIndex += nodeIncrement\n                ) {\n                  localResidualVector[localNodeIndex] +=\n                    -gaussWeights[gaussPointIndex] *\n                    tangentVectorLength *\n                    basisFunction[localNodeIndex] *\n                    convectionCoeff *\n                    extTemp;\n\n                  for (\n                    let localNodeIndex2 = firstNodeIndex;\n                    localNodeIndex2 < lastNodeIndex;\n                    localNodeIndex2 += nodeIncrement\n                  ) {\n                    localJacobianMatrix[localNodeIndex][localNodeIndex2] +=\n                      -gaussWeights[gaussPointIndex] *\n                      tangentVectorLength *\n                      basisFunction[localNodeIndex] *\n                      basisFunction[localNodeIndex2] *\n                      convectionCoeff;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return { localJacobianMatrix, localResidualVector };\n  }\n}\n","/**\n * ════════════════════════════════════════════════════════════════\n *  FEAScript Core Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.2.0 | https://feascript.com\n *  MIT License © 2023–2026 FEAScript\n * ════════════════════════════════════════════════════════════════\n */\n\n// Internal imports\nimport {\n  initializeFEA,\n  performIsoparametricMapping1D,\n  performIsoparametricMapping2D,\n} from \"../mesh/meshUtilsScript.js\";\nimport { ThermalBoundaryConditions } from \"./thermalBoundaryConditionsScript.js\";\nimport { basicLog, debugLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Function to assemble the Jacobian matrix and residuals vector for the solid heat transfer model\n * @param {object} meshData - Object containing prepared mesh data\n * @param {object} boundaryConditions - Object containing boundary conditions for the finite element analysis\n * @returns {object} An object containing:\n *  - jacobianMatrix: The assembled Jacobian matrix\n *  - residualVector: The assembled residual vector\n *\n * For consistency across both linear and nonlinear formulations,\n * this project always refers to the assembled right-hand side vector\n * as `residualVector` and the assembled system matrix as `jacobianMatrix`.\n *\n * In linear problems `jacobianMatrix` is equivalent to the\n * classic stiffness/conductivity matrix and `residualVector`\n * corresponds to the traditional load (RHS) vector.\n */\nexport function assembleHeatConductionMat(meshData, boundaryConditions) {\n  basicLog(\"Starting solid heat transfer matrix assembly...\");\n\n  // Extract mesh data\n  const {\n    nodesXCoordinates,\n    nodesYCoordinates,\n    nop,\n    boundaryElements,\n    totalElements,\n    meshDimension,\n    elementOrder,\n  } = meshData;\n\n  // Initialize FEA components\n  const FEAData = initializeFEA(meshData);\n  const {\n    residualVector,\n    jacobianMatrix,\n    localToGlobalMap,\n    basisFunctions,\n    gaussPoints,\n    gaussWeights,\n    nodesPerElement,\n  } = FEAData;\n\n  // Matrix assembly\n  for (let elementIndex = 0; elementIndex < totalElements; elementIndex++) {\n    // Map local element nodes to global mesh nodes\n    for (let localNodeIndex = 0; localNodeIndex < nodesPerElement; localNodeIndex++) {\n      // Subtract 1 from nop in order to start numbering from 0\n      localToGlobalMap[localNodeIndex] = nop[elementIndex][localNodeIndex] - 1;\n    }\n\n    // Loop over Gauss points\n    for (let gaussPointIndex1 = 0; gaussPointIndex1 < gaussPoints.length; gaussPointIndex1++) {\n      // 1D solid heat transfer\n      if (meshDimension === \"1D\") {\n        // Get basis functions for the current Gauss point\n        const basisFunctionsAndDerivatives = basisFunctions.getBasisFunctions(gaussPoints[gaussPointIndex1]);\n\n        // Perform isoparametric mapping\n        const mappingResult = performIsoparametricMapping1D({\n          basisFunction: basisFunctionsAndDerivatives.basisFunction,\n          basisFunctionDerivKsi: basisFunctionsAndDerivatives.basisFunctionDerivKsi,\n          nodesXCoordinates,\n          localToGlobalMap,\n          nodesPerElement,\n        });\n\n        // Extract mapping results\n        const { detJacobian, basisFunctionDerivX } = mappingResult;\n\n        // Computation of Galerkin's residuals and Jacobian matrix\n        for (let localNodeIndex1 = 0; localNodeIndex1 < nodesPerElement; localNodeIndex1++) {\n          let localToGlobalMap1 = localToGlobalMap[localNodeIndex1];\n          // residualVector is zero for this case\n\n          for (let localNodeIndex2 = 0; localNodeIndex2 < nodesPerElement; localNodeIndex2++) {\n            let localToGlobalMap2 = localToGlobalMap[localNodeIndex2];\n            jacobianMatrix[localToGlobalMap1][localToGlobalMap2] +=\n              -gaussWeights[gaussPointIndex1] *\n              detJacobian *\n              (basisFunctionDerivX[localNodeIndex1] * basisFunctionDerivX[localNodeIndex2]);\n          }\n        }\n      }\n      // 2D solid heat transfer\n      else if (meshDimension === \"2D\") {\n        for (let gaussPointIndex2 = 0; gaussPointIndex2 < gaussPoints.length; gaussPointIndex2++) {\n          // Get basis functions for the current Gauss point\n          const basisFunctionsAndDerivatives = basisFunctions.getBasisFunctions(\n            gaussPoints[gaussPointIndex1],\n            gaussPoints[gaussPointIndex2]\n          );\n\n          // Perform isoparametric mapping\n          const mappingResult = performIsoparametricMapping2D({\n            basisFunction: basisFunctionsAndDerivatives.basisFunction,\n            basisFunctionDerivKsi: basisFunctionsAndDerivatives.basisFunctionDerivKsi,\n            basisFunctionDerivEta: basisFunctionsAndDerivatives.basisFunctionDerivEta,\n            nodesXCoordinates,\n            nodesYCoordinates,\n            localToGlobalMap,\n            nodesPerElement,\n          });\n\n          // Extract mapping results\n          const { detJacobian, basisFunctionDerivX, basisFunctionDerivY } = mappingResult;\n\n          // Computation of Galerkin's residuals and Jacobian matrix\n          for (let localNodeIndex1 = 0; localNodeIndex1 < nodesPerElement; localNodeIndex1++) {\n            let localToGlobalMap1 = localToGlobalMap[localNodeIndex1];\n            // residualVector is zero for this case\n\n            for (let localNodeIndex2 = 0; localNodeIndex2 < nodesPerElement; localNodeIndex2++) {\n              let localToGlobalMap2 = localToGlobalMap[localNodeIndex2];\n              jacobianMatrix[localToGlobalMap1][localToGlobalMap2] +=\n                -gaussWeights[gaussPointIndex1] *\n                gaussWeights[gaussPointIndex2] *\n                detJacobian *\n                (basisFunctionDerivX[localNodeIndex1] * basisFunctionDerivX[localNodeIndex2] +\n                  basisFunctionDerivY[localNodeIndex1] * basisFunctionDerivY[localNodeIndex2]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Apply boundary conditions\n  const thermalBoundaryConditions = new ThermalBoundaryConditions(\n    boundaryConditions,\n    boundaryElements,\n    nop,\n    meshDimension,\n    elementOrder\n  );\n\n  // Impose Convection boundary conditions\n  thermalBoundaryConditions.imposeConvectionBoundaryConditions(\n    residualVector,\n    jacobianMatrix,\n    gaussPoints,\n    gaussWeights,\n    nodesXCoordinates,\n    nodesYCoordinates,\n    basisFunctions\n  );\n\n  // Impose ConstantTemp boundary conditions\n  thermalBoundaryConditions.imposeConstantTempBoundaryConditions(residualVector, jacobianMatrix);\n  basicLog(\"Solid heat transfer matrix assembly completed\");\n\n  return {\n    jacobianMatrix,\n    residualVector,\n  };\n}\n\n/**\n * Function to assemble the local Jacobian matrix and residual vector for the solid heat transfer model when using the frontal system solver\n * @param {number} elementIndex - Index of the element being processed\n * @param {array} nop - Nodal connectivity array (element-to-node mapping)\n * @param {object} meshData - Object containing prepared mesh data\n * @param {object} basisFunctions - Object containing basis functions and their derivatives\n * @param {object} FEAData - Object containing FEA-related data\n * @returns {object} An object containing:\n *  - localJacobianMatrix: Local Jacobian matrix\n *  - localResidualVector: Residual vector contributions\n *  - ngl: Array mapping local node indices to global node indices\n */\nexport function assembleHeatConductionFront({ elementIndex, nop, meshData, basisFunctions, FEAData }) {\n  // Extract numerical integration parameters and mesh coordinates\n  const { gaussPoints, gaussWeights, nodesPerElement } = FEAData;\n  const { nodesXCoordinates, nodesYCoordinates, meshDimension } = meshData;\n\n  // Initialize local Jacobian matrix and local residual vector\n  const localJacobianMatrix = Array(nodesPerElement)\n    .fill()\n    .map(() => Array(nodesPerElement).fill(0));\n  const localResidualVector = Array(nodesPerElement).fill(0);\n\n  // Build the mapping from local node indices to global node indices\n  const ngl = Array(nodesPerElement);\n  const localToGlobalMap = Array(nodesPerElement);\n  for (let localNodeIndex = 0; localNodeIndex < nodesPerElement; localNodeIndex++) {\n    ngl[localNodeIndex] = Math.abs(nop[elementIndex][localNodeIndex]);\n    localToGlobalMap[localNodeIndex] = Math.abs(nop[elementIndex][localNodeIndex]) - 1;\n  }\n\n  // Loop over Gauss points\n  if (meshDimension === \"1D\") {\n    // 1D solid heat transfer\n    for (let gaussPointIndex1 = 0; gaussPointIndex1 < gaussPoints.length; gaussPointIndex1++) {\n      // Get basis functions for the current Gauss point\n      const { basisFunction, basisFunctionDerivKsi } = basisFunctions.getBasisFunctions(\n        gaussPoints[gaussPointIndex1]\n      );\n\n      // Perform isoparametric mapping\n      const { detJacobian, basisFunctionDerivX } = performIsoparametricMapping1D({\n        basisFunction,\n        basisFunctionDerivKsi,\n        nodesXCoordinates,\n        localToGlobalMap,\n        nodesPerElement,\n      });\n\n      // Computation of Galerkin's residuals and local Jacobian matrix\n      for (let localNodeIndex1 = 0; localNodeIndex1 < nodesPerElement; localNodeIndex1++) {\n        for (let localNodeIndex2 = 0; localNodeIndex2 < nodesPerElement; localNodeIndex2++) {\n          localJacobianMatrix[localNodeIndex1][localNodeIndex2] -=\n            gaussWeights[gaussPointIndex1] *\n            detJacobian *\n            (basisFunctionDerivX[localNodeIndex1] * basisFunctionDerivX[localNodeIndex2]);\n        }\n      }\n    }\n  } else if (meshDimension === \"2D\") {\n    // 2D solid heat transfer\n    for (let gaussPointIndex1 = 0; gaussPointIndex1 < gaussPoints.length; gaussPointIndex1++) {\n      for (let gaussPointIndex2 = 0; gaussPointIndex2 < gaussPoints.length; gaussPointIndex2++) {\n        // Get basis functions for the current Gauss point\n        const { basisFunction, basisFunctionDerivKsi, basisFunctionDerivEta } =\n          basisFunctions.getBasisFunctions(gaussPoints[gaussPointIndex1], gaussPoints[gaussPointIndex2]);\n\n        // Create mapping from local element space to global mesh (convert to 0-based indexing)\n        const localToGlobalMap = ngl.map((globalIndex) => globalIndex - 1);\n\n        // Perform isoparametric mapping\n        const { detJacobian, basisFunctionDerivX, basisFunctionDerivY } = performIsoparametricMapping2D({\n          basisFunction,\n          basisFunctionDerivKsi,\n          basisFunctionDerivEta,\n          nodesXCoordinates,\n          nodesYCoordinates,\n          localToGlobalMap,\n          nodesPerElement,\n        });\n\n        // Computation of Galerkin's residuals and local Jacobian matrix\n        for (let localNodeIndex1 = 0; localNodeIndex1 < nodesPerElement; localNodeIndex1++) {\n          for (let localNodeIndex2 = 0; localNodeIndex2 < nodesPerElement; localNodeIndex2++) {\n            localJacobianMatrix[localNodeIndex1][localNodeIndex2] -=\n              gaussWeights[gaussPointIndex1] *\n              gaussWeights[gaussPointIndex2] *\n              detJacobian *\n              (basisFunctionDerivX[localNodeIndex1] * basisFunctionDerivX[localNodeIndex2] +\n                basisFunctionDerivY[localNodeIndex1] * basisFunctionDerivY[localNodeIndex2]);\n          }\n        }\n      }\n    }\n  }\n\n  return { localJacobianMatrix, localResidualVector, ngl };\n}\n","/**\n * ════════════════════════════════════════════════════════════════\n *  FEAScript Core Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.2.0 | https://feascript.com\n *  MIT License © 2023–2026 FEAScript\n * ════════════════════════════════════════════════════════════════\n */\n\n// Internal imports\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Class to handle generic boundary conditions application\n */\nexport class GenericBoundaryConditions {\n  /**\n   * Constructor to initialize the GenericBoundaryConditions class\n   * @param {object} boundaryConditions - Object containing boundary conditions for the finite element analysis\n   * @param {array} boundaryElements - Array containing elements that belong to each boundary\n   * @param {array} nop - Nodal numbering (NOP) array representing the connectivity between elements and nodes\n   * @param {string} meshDimension - The dimension of the mesh (e.g., \"2D\")\n   * @param {string} elementOrder - The order of elements (e.g., \"linear\", \"quadratic\")\n   */\n  constructor(boundaryConditions, boundaryElements, nop, meshDimension, elementOrder) {\n    this.boundaryConditions = boundaryConditions;\n    this.boundaryElements = boundaryElements;\n    this.nop = nop;\n    this.meshDimension = meshDimension;\n    this.elementOrder = elementOrder;\n  }\n\n  /**\n   * Function to impose Dirichlet boundary conditions\n   * @param {array} residualVector - The residual vector to be modified\n   * @param {array} jacobianMatrix - The Jacobian matrix to be modified\n   *\n   * For consistency across both linear and nonlinear formulations,\n   * this project always refers to the assembled right-hand side vector\n   * as `residualVector` and the assembled system matrix as `jacobianMatrix`.\n   *\n   * In linear problems `jacobianMatrix` is equivalent to the\n   * classic stiffness/conductivity matrix and `residualVector`\n   * corresponds to the traditional load (RHS) vector.\n   */\n  imposeDirichletBoundaryConditions(residualVector, jacobianMatrix) {\n    if (this.meshDimension === \"1D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        if (this.boundaryConditions[boundaryKey][0] === \"constantValue\") {\n          const value = this.boundaryConditions[boundaryKey][1];\n          debugLog(`Boundary ${boundaryKey}: Applying constant value of ${value} (Dirichlet condition)`);\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            if (this.elementOrder === \"linear\") {\n              const boundarySides = {\n                0: [0], // Node at the left side of the reference element\n                1: [1], // Node at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant value to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                // Set the residual vector to the value\n                residualVector[globalNodeIndex] = value;\n                // Set the Jacobian matrix row to zero\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\n                }\n                // Set the diagonal entry of the Jacobian matrix to one\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\n              });\n            } else if (this.elementOrder === \"quadratic\") {\n              const boundarySides = {\n                0: [0], // Node at the left side of the reference element\n                1: [2], // Node at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant value to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                // Set the residual vector to the value\n                residualVector[globalNodeIndex] = value;\n                // Set the Jacobian matrix row to zero\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\n                }\n                // Set the diagonal entry of the Jacobian matrix to one\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\n              });\n            }\n          });\n        }\n      });\n    } else if (this.meshDimension === \"2D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        if (this.boundaryConditions[boundaryKey][0] === \"constantValue\") {\n          const value = this.boundaryConditions[boundaryKey][1];\n          debugLog(`Boundary ${boundaryKey}: Applying constant value of ${value} (Dirichlet condition)`);\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            if (this.elementOrder === \"linear\") {\n              const boundarySides = {\n                0: [0, 2], // Nodes at the bottom side of the reference element\n                1: [0, 1], // Nodes at the left side of the reference element\n                2: [1, 3], // Nodes at the top side of the reference element\n                3: [2, 3], // Nodes at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant value to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                // Set the residual vector to the value\n                residualVector[globalNodeIndex] = value;\n                // Set the Jacobian matrix row to zero\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\n                }\n                // Set the diagonal entry of the Jacobian matrix to one\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\n              });\n            } else if (this.elementOrder === \"quadratic\") {\n              const boundarySides = {\n                0: [0, 3, 6], // Nodes at the bottom side of the reference element\n                1: [0, 1, 2], // Nodes at the left side of the reference element\n                2: [2, 5, 8], // Nodes at the top side of the reference element\n                3: [6, 7, 8], // Nodes at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant value to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                // Set the residual vector to the value\n                residualVector[globalNodeIndex] = value;\n                // Set the Jacobian matrix row to zero\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\n                }\n                // Set the diagonal entry of the Jacobian matrix to one\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\n              });\n            }\n          });\n        }\n      });\n    }\n  }\n\n  /**\n   * Function to impose constant value (Dirichlet) boundary conditions for the frontal solver\n   * @param {array} nodeConstraintCode - Array indicating boundary condition code for each node\n   * @param {array} boundaryValues - Array containing boundary condition values\n   */\n  imposeConstantValueBoundaryConditionsFront(nodeConstraintCode, boundaryValues) {\n    if (this.meshDimension === \"1D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        if (this.boundaryConditions[boundaryKey][0] === \"constantValue\") {\n          const value = this.boundaryConditions[boundaryKey][1];\n          debugLog(`Boundary ${boundaryKey}: Applying constant value of ${value} (Dirichlet condition)`);\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            if (this.elementOrder === \"linear\") {\n              const boundarySides = {\n                0: [0], // Node at the left side of the reference element\n                1: [1], // Node at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant value to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                nodeConstraintCode[globalNodeIndex] = 1;\n                boundaryValues[globalNodeIndex] = value;\n              });\n            } else if (this.elementOrder === \"quadratic\") {\n              const boundarySides = {\n                0: [0], // Node at the left side of the reference element\n                2: [2], // Node at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant value to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                nodeConstraintCode[globalNodeIndex] = 1;\n                boundaryValues[globalNodeIndex] = value;\n              });\n            }\n          });\n        }\n      });\n    } else if (this.meshDimension === \"2D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        if (this.boundaryConditions[boundaryKey][0] === \"constantValue\") {\n          const value = this.boundaryConditions[boundaryKey][1];\n          debugLog(`Boundary ${boundaryKey}: Applying constant value of ${value} (Dirichlet condition)`);\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            if (this.elementOrder === \"linear\") {\n              const boundarySides = {\n                0: [0, 2], // Nodes at the bottom side of the reference element\n                1: [0, 1], // Nodes at the left side of the reference element\n                2: [1, 3], // Nodes at the top side of the reference element\n                3: [2, 3], // Nodes at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant value to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                nodeConstraintCode[globalNodeIndex] = 1;\n                boundaryValues[globalNodeIndex] = value;\n              });\n            } else if (this.elementOrder === \"quadratic\") {\n              const boundarySides = {\n                0: [0, 3, 6], // Nodes at the bottom side of the reference element\n                1: [0, 1, 2], // Nodes at the left side of the reference element\n                2: [2, 5, 8], // Nodes at the top side of the reference element\n                3: [6, 7, 8], // Nodes at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant value to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                nodeConstraintCode[globalNodeIndex] = 1;\n                boundaryValues[globalNodeIndex] = value;\n              });\n            }\n          });\n        }\n      });\n    }\n  }\n}\n","/**\n * ════════════════════════════════════════════════════════════════\n *  FEAScript Core Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.2.0 | https://feascript.com\n *  MIT License © 2023–2026 FEAScript\n * ════════════════════════════════════════════════════════════════\n */\n\n// Internal imports\nimport { GenericBoundaryConditions } from \"./genericBoundaryConditionsScript.js\";\nimport {\n  initializeFEA,\n  performIsoparametricMapping1D,\n  performIsoparametricMapping2D,\n} from \"../mesh/meshUtilsScript.js\";\nimport { basicLog, debugLog } from \"../utilities/loggingScript.js\";\n\n// Base viscous term that remains when eikonal equation is fully activated\nconst baseEikonalViscousTerm = 1e-2;\n\n/**\n * Function to assemble the Jacobian matrix and residuals vector for the front propagation model\n * @param {object} meshData - Object containing prepared mesh data\n * @param {object} boundaryConditions - Object containing boundary conditions for the finite element analysis\n * @param {array} solutionVector - The solution vector for non-linear equations\n * @param {number} eikonalActivationFlag - Activation parameter for the eikonal equation\n * @returns {object}  An object containing:\n *  - jacobianMatrix: The assembled Jacobian matrix\n *  - residualVector: The assembled residual vector\n */\nexport function assembleFrontPropagationMat(\n  meshData,\n  boundaryConditions,\n  solutionVector,\n  eikonalActivationFlag\n) {\n  basicLog(\"Starting front propagation matrix assembly...\");\n\n  // Calculate eikonal viscous term\n  let eikonalViscousTerm = 1 - eikonalActivationFlag + baseEikonalViscousTerm; // Viscous term for the front propagation (eikonal) equation\n  debugLog(`eikonalViscousTerm: ${eikonalViscousTerm}`);\n  debugLog(`eikonalActivationFlag: ${eikonalActivationFlag}`);\n\n  // Extract mesh data\n  const {\n    nodesXCoordinates,\n    nodesYCoordinates,\n    nop,\n    boundaryElements,\n    totalElements,\n    meshDimension,\n    elementOrder,\n  } = meshData;\n\n  // Initialize FEA components\n  const FEAData = initializeFEA(meshData);\n  const {\n    residualVector,\n    jacobianMatrix,\n    localToGlobalMap,\n    basisFunctions,\n    gaussPoints,\n    gaussWeights,\n    nodesPerElement,\n  } = FEAData;\n\n  // Matrix assembly\n  for (let elementIndex = 0; elementIndex < totalElements; elementIndex++) {\n    // Map local element nodes to global mesh nodes\n    for (let localNodeIndex = 0; localNodeIndex < nodesPerElement; localNodeIndex++) {\n      // Subtract 1 from nop in order to start numbering from 0\n      localToGlobalMap[localNodeIndex] = nop[elementIndex][localNodeIndex] - 1;\n    }\n\n    // Loop over Gauss points\n    for (let gaussPointIndex1 = 0; gaussPointIndex1 < gaussPoints.length; gaussPointIndex1++) {\n      // 1D front propagation (eikonal) equation\n      if (meshDimension === \"1D\") {\n        // Unsupported 1D front propagation\n        errorLog(\"1D front propagation is not yet supported\");\n\n        // Get basis functions for the current Gauss point\n        let basisFunctionsAndDerivatives = basisFunctions.getBasisFunctions(gaussPoints[gaussPointIndex1]);\n\n        // Perform isoparametric mapping\n        const mappingResult = performIsoparametricMapping1D({\n          basisFunction: basisFunctionsAndDerivatives.basisFunction,\n          basisFunctionDerivKsi: basisFunctionsAndDerivatives.basisFunctionDerivKsi,\n          nodesXCoordinates,\n          localToGlobalMap,\n          nodesPerElement,\n        });\n\n        // Extract mapping results\n        const { detJacobian, basisFunctionDerivX } = mappingResult;\n        const basisFunction = basisFunctionsAndDerivatives.basisFunction;\n\n        // Calculate solution derivative\n        let solutionDerivX = 0;\n        for (let localNodeIndex = 0; localNodeIndex < nodesPerElement; localNodeIndex++) {\n          solutionDerivX +=\n            solutionVector[localToGlobalMap[localNodeIndex]] * basisFunctionDerivX[localNodeIndex];\n        }\n\n        // Computation of Galerkin's residuals and Jacobian matrix\n        for (let localNodeIndex1 = 0; localNodeIndex1 < nodesPerElement; localNodeIndex1++) {\n          let localToGlobalMap1 = localToGlobalMap[localNodeIndex1];\n          // residualVector\n          // TODO residualVector calculation here\n\n          for (let localNodeIndex2 = 0; localNodeIndex2 < nodesPerElement; localNodeIndex2++) {\n            let localToGlobalMap2 = localToGlobalMap[localNodeIndex2];\n            // jacobianMatrix\n            // TODO jacobianMatrix calculation here\n          }\n        }\n      }\n      // 2D front propagation (eikonal) equation\n      else if (meshDimension === \"2D\") {\n        for (let gaussPointIndex2 = 0; gaussPointIndex2 < gaussPoints.length; gaussPointIndex2++) {\n          // Get basis functions for the current Gauss point\n          let basisFunctionsAndDerivatives = basisFunctions.getBasisFunctions(\n            gaussPoints[gaussPointIndex1],\n            gaussPoints[gaussPointIndex2]\n          );\n\n          // Perform isoparametric mapping\n          const mappingResult = performIsoparametricMapping2D({\n            basisFunction: basisFunctionsAndDerivatives.basisFunction,\n            basisFunctionDerivKsi: basisFunctionsAndDerivatives.basisFunctionDerivKsi,\n            basisFunctionDerivEta: basisFunctionsAndDerivatives.basisFunctionDerivEta,\n            nodesXCoordinates,\n            nodesYCoordinates,\n            localToGlobalMap,\n            nodesPerElement,\n          });\n\n          // Extract mapping results\n          const { detJacobian, basisFunctionDerivX, basisFunctionDerivY } = mappingResult;\n          const basisFunction = basisFunctionsAndDerivatives.basisFunction;\n\n          // Calculate solution derivatives\n          let solutionDerivX = 0;\n          let solutionDerivY = 0;\n          for (let localNodeIndex = 0; localNodeIndex < nodesPerElement; localNodeIndex++) {\n            solutionDerivX +=\n              solutionVector[localToGlobalMap[localNodeIndex]] * basisFunctionDerivX[localNodeIndex];\n            solutionDerivY +=\n              solutionVector[localToGlobalMap[localNodeIndex]] * basisFunctionDerivY[localNodeIndex];\n          }\n\n          // Computation of Galerkin's residuals and Jacobian matrix\n          for (let localNodeIndex1 = 0; localNodeIndex1 < nodesPerElement; localNodeIndex1++) {\n            let localToGlobalMap1 = localToGlobalMap[localNodeIndex1];\n\n            // residualVector: Viscous term contribution (to stabilize the solution)\n            residualVector[localToGlobalMap1] +=\n              eikonalViscousTerm *\n                gaussWeights[gaussPointIndex1] *\n                gaussWeights[gaussPointIndex2] *\n                detJacobian *\n                basisFunctionDerivX[localNodeIndex1] *\n                solutionDerivX +\n              eikonalViscousTerm *\n                gaussWeights[gaussPointIndex1] *\n                gaussWeights[gaussPointIndex2] *\n                detJacobian *\n                basisFunctionDerivY[localNodeIndex1] *\n                solutionDerivY;\n\n            // residualVector: Eikonal equation contribution\n            if (eikonalActivationFlag !== 0) {\n              residualVector[localToGlobalMap1] +=\n                eikonalActivationFlag *\n                (gaussWeights[gaussPointIndex1] *\n                  gaussWeights[gaussPointIndex2] *\n                  detJacobian *\n                  basisFunction[localNodeIndex1] *\n                  Math.sqrt(solutionDerivX ** 2 + solutionDerivY ** 2) -\n                  gaussWeights[gaussPointIndex1] *\n                    gaussWeights[gaussPointIndex2] *\n                    detJacobian *\n                    basisFunction[localNodeIndex1]);\n            }\n\n            for (let localNodeIndex2 = 0; localNodeIndex2 < nodesPerElement; localNodeIndex2++) {\n              let localToGlobalMap2 = localToGlobalMap[localNodeIndex2];\n\n              // jacobianMatrix: Viscous term contribution\n              jacobianMatrix[localToGlobalMap1][localToGlobalMap2] +=\n                -eikonalViscousTerm *\n                gaussWeights[gaussPointIndex1] *\n                gaussWeights[gaussPointIndex2] *\n                detJacobian *\n                (basisFunctionDerivX[localNodeIndex1] * basisFunctionDerivX[localNodeIndex2] +\n                  basisFunctionDerivY[localNodeIndex1] * basisFunctionDerivY[localNodeIndex2]);\n\n              // jacobianMatrix: Eikonal equation contribution\n              if (eikonalActivationFlag !== 0) {\n                jacobianMatrix[localToGlobalMap1][localToGlobalMap2] +=\n                  eikonalActivationFlag *\n                    (-(\n                      detJacobian *\n                      solutionDerivX *\n                      basisFunction[localNodeIndex1] *\n                      gaussWeights[gaussPointIndex1] *\n                      gaussWeights[gaussPointIndex2]\n                    ) /\n                      Math.sqrt(solutionDerivX ** 2 + solutionDerivY ** 2 + 1e-8)) *\n                    basisFunctionDerivX[localNodeIndex2] -\n                  eikonalActivationFlag *\n                    ((detJacobian *\n                      solutionDerivY *\n                      basisFunction[localNodeIndex1] *\n                      gaussWeights[gaussPointIndex1] *\n                      gaussWeights[gaussPointIndex2]) /\n                      Math.sqrt(solutionDerivX ** 2 + solutionDerivY ** 2 + 1e-8)) *\n                    basisFunctionDerivY[localNodeIndex2];\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Apply boundary conditions\n  const genericBoundaryConditions = new GenericBoundaryConditions(\n    boundaryConditions,\n    boundaryElements,\n    nop,\n    meshDimension,\n    elementOrder\n  );\n\n  // Impose Dirichlet boundary conditions\n  genericBoundaryConditions.imposeDirichletBoundaryConditions(residualVector, jacobianMatrix);\n  basicLog(\"Front propagation matrix assembly completed\");\n\n  return {\n    jacobianMatrix,\n    residualVector,\n  };\n}\n\n/**\n * Function to assemble the local Jacobian matrix and residual vector for the front propagation model when using the frontal system solver\n * @param {number} elementIndex - Index of the element being processed\n * @param {array} nop - Nodal connectivity array (element-to-node mapping)\n * @param {object} meshData - Object containing prepared mesh data\n * @param {object} basisFunctions - Object containing basis functions and their derivatives\n * @param {object} FEAData - Object containing FEA-related data\n * @param {array} solutionVector - The solution vector for non-linear equations\n * @param {number} eikonalActivationFlag - Activation parameter for the eikonal equation\n * @returns {object} An object containing:\n *  - localJacobianMatrix: Local Jacobian matrix\n *  - residualVector: Residual vector contributions\n *  - ngl: Array mapping local node indices to global node indices\n */\nexport function assembleFrontPropagationFront({\n  elementIndex,\n  nop,\n  meshData,\n  basisFunctions,\n  FEAData,\n  solutionVector,\n  eikonalActivationFlag,\n}) {\n  // Extract numerical integration parameters and mesh coordinates\n  const { gaussPoints, gaussWeights, nodesPerElement } = FEAData;\n  const { nodesXCoordinates, nodesYCoordinates, meshDimension } = meshData;\n\n  // Calculate eikonal viscous term\n  let eikonalViscousTerm = 1 - eikonalActivationFlag + baseEikonalViscousTerm; // Viscous term for the front propagation (eikonal) equation\n\n  // Initialize local Jacobian matrix and local residual vector\n  const localJacobianMatrix = Array(nodesPerElement)\n    .fill()\n    .map(() => Array(nodesPerElement).fill(0));\n  const localResidualVector = Array(nodesPerElement).fill(0);\n\n  // Build the mapping from local node indices to global node indices\n  const ngl = Array(nodesPerElement);\n  const localToGlobalMap = Array(nodesPerElement);\n  for (let localNodeIndex = 0; localNodeIndex < nodesPerElement; localNodeIndex++) {\n    ngl[localNodeIndex] = Math.abs(nop[elementIndex][localNodeIndex]);\n    localToGlobalMap[localNodeIndex] = Math.abs(nop[elementIndex][localNodeIndex]) - 1;\n  }\n\n  // Loop over Gauss points\n  for (let gaussPointIndex1 = 0; gaussPointIndex1 < gaussPoints.length; gaussPointIndex1++) {\n    // 1D front propagation (eikonal) equation\n    if (meshDimension === \"1D\") {\n      // Unsupported 1D front propagation\n      errorLog(\"1D front propagation is not yet supported\");\n\n      // Get basis functions for the current Gauss point\n      let basisFunctionsAndDerivatives = basisFunctions.getBasisFunctions(gaussPoints[gaussPointIndex1]);\n\n      // Perform isoparametric mapping\n      const mappingResult = performIsoparametricMapping1D({\n        basisFunction: basisFunctionsAndDerivatives.basisFunction,\n        basisFunctionDerivKsi: basisFunctionsAndDerivatives.basisFunctionDerivKsi,\n        nodesXCoordinates,\n        localToGlobalMap,\n        nodesPerElement,\n      });\n\n      // Extract mapping results\n      const { detJacobian, basisFunctionDerivX } = mappingResult;\n      const basisFunction = basisFunctionsAndDerivatives.basisFunction;\n\n      // Calculate solution derivative\n      let solutionDerivX = 0;\n      for (let localNodeIndex = 0; localNodeIndex < nodesPerElement; localNodeIndex++) {\n        solutionDerivX +=\n          solutionVector[localToGlobalMap[localNodeIndex]] * basisFunctionDerivX[localNodeIndex];\n      }\n\n      // Computation of Galerkin's residuals and Jacobian matrix\n      for (let localNodeIndex1 = 0; localNodeIndex1 < nodesPerElement; localNodeIndex1++) {\n        let localToGlobalMap1 = localToGlobalMap[localNodeIndex1];\n        // residualVector\n        // TODO residualVector calculation here\n\n        for (let localNodeIndex2 = 0; localNodeIndex2 < nodesPerElement; localNodeIndex2++) {\n          let localToGlobalMap2 = localToGlobalMap[localNodeIndex2];\n          // localJacobianMatrix\n          // TODO localJacobianMatrix calculation here\n        }\n      }\n      // 2D front propagation (eikonal) equation\n    } else if (meshDimension === \"2D\") {\n      for (let gaussPointIndex2 = 0; gaussPointIndex2 < gaussPoints.length; gaussPointIndex2++) {\n        // Get basis functions for the current Gauss point\n        const { basisFunction, basisFunctionDerivKsi, basisFunctionDerivEta } =\n          basisFunctions.getBasisFunctions(gaussPoints[gaussPointIndex1], gaussPoints[gaussPointIndex2]);\n\n        // Perform isoparametric mapping\n        const { detJacobian, basisFunctionDerivX, basisFunctionDerivY } = performIsoparametricMapping2D({\n          basisFunction,\n          basisFunctionDerivKsi,\n          basisFunctionDerivEta,\n          nodesXCoordinates,\n          nodesYCoordinates,\n          localToGlobalMap,\n          nodesPerElement,\n        });\n\n        // Calculate solution derivatives\n        let solutionDerivX = 0;\n        let solutionDerivY = 0;\n        for (let localNodeIndex = 0; localNodeIndex < nodesPerElement; localNodeIndex++) {\n          solutionDerivX +=\n            solutionVector[localToGlobalMap[localNodeIndex]] * basisFunctionDerivX[localNodeIndex];\n          solutionDerivY +=\n            solutionVector[localToGlobalMap[localNodeIndex]] * basisFunctionDerivY[localNodeIndex];\n        }\n\n        // Computation of Galerkin's residuals and Jacobian matrix\n        for (let localNodeIndex1 = 0; localNodeIndex1 < nodesPerElement; localNodeIndex1++) {\n          let localToGlobalMap1 = localToGlobalMap[localNodeIndex1];\n          // Viscous term contribution\n          localResidualVector[localNodeIndex1] +=\n            eikonalViscousTerm *\n              gaussWeights[gaussPointIndex1] *\n              gaussWeights[gaussPointIndex2] *\n              detJacobian *\n              basisFunctionDerivX[localNodeIndex1] *\n              solutionDerivX +\n            eikonalViscousTerm *\n              gaussWeights[gaussPointIndex1] *\n              gaussWeights[gaussPointIndex2] *\n              detJacobian *\n              basisFunctionDerivY[localNodeIndex1] *\n              solutionDerivY;\n\n          // Eikonal equation contribution\n          if (eikonalActivationFlag !== 0) {\n            localResidualVector[localNodeIndex1] +=\n              eikonalActivationFlag *\n              (gaussWeights[gaussPointIndex1] *\n                gaussWeights[gaussPointIndex2] *\n                detJacobian *\n                basisFunction[localNodeIndex1] *\n                Math.sqrt(solutionDerivX ** 2 + solutionDerivY ** 2) -\n                gaussWeights[gaussPointIndex1] *\n                  gaussWeights[gaussPointIndex2] *\n                  detJacobian *\n                  basisFunction[localNodeIndex1]);\n          }\n\n          for (let localNodeIndex2 = 0; localNodeIndex2 < nodesPerElement; localNodeIndex2++) {\n            // Viscous term contribution\n            localJacobianMatrix[localNodeIndex1][localNodeIndex2] -=\n              eikonalViscousTerm *\n              gaussWeights[gaussPointIndex1] *\n              gaussWeights[gaussPointIndex2] *\n              detJacobian *\n              (basisFunctionDerivX[localNodeIndex1] * basisFunctionDerivX[localNodeIndex2] +\n                basisFunctionDerivY[localNodeIndex1] * basisFunctionDerivY[localNodeIndex2]);\n\n            // Eikonal equation contribution\n            if (eikonalActivationFlag !== 0) {\n              localJacobianMatrix[localNodeIndex1][localNodeIndex2] +=\n                eikonalActivationFlag *\n                  (-(\n                    detJacobian *\n                    solutionDerivX *\n                    basisFunction[localNodeIndex1] *\n                    gaussWeights[gaussPointIndex1] *\n                    gaussWeights[gaussPointIndex2]\n                  ) /\n                    Math.sqrt(solutionDerivX ** 2 + solutionDerivY ** 2 + 1e-8)) *\n                  basisFunctionDerivX[localNodeIndex2] -\n                eikonalActivationFlag *\n                  ((detJacobian *\n                    solutionDerivY *\n                    basisFunction[localNodeIndex1] *\n                    gaussWeights[gaussPointIndex1] *\n                    gaussWeights[gaussPointIndex2]) /\n                    Math.sqrt(solutionDerivX ** 2 + solutionDerivY ** 2 + 1e-8)) *\n                  basisFunctionDerivY[localNodeIndex2];\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return { localJacobianMatrix, localResidualVector, ngl };\n}\n","/**\n * ════════════════════════════════════════════════════════════════\n *  FEAScript Core Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.2.0 | https://feascript.com\n *  MIT License © 2023–2026 FEAScript\n * ════════════════════════════════════════════════════════════════\n */\n\n// Internal imports\nimport { BasisFunctions } from \"../mesh/basisFunctionsScript.js\";\nimport { initializeFEA } from \"../mesh/meshUtilsScript.js\";\nimport { assembleHeatConductionFront } from \"../models/heatConductionScript.js\";\nimport { ThermalBoundaryConditions } from \"../models/thermalBoundaryConditionsScript.js\";\nimport { assembleFrontPropagationFront } from \"../models/frontPropagationScript.js\";\nimport { GenericBoundaryConditions } from \"../models/genericBoundaryConditionsScript.js\";\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n// Create object templates\nconst frontalData = {};\nconst frontalState = {};\nconst elementData = { currentElementIndex: 0 };\nconst frontStorage = {};\nlet basisFunctions;\n\n/**\n * Function to run the frontal solver and obtain results for plotting\n * @param {function} assembleFront - Matrix assembler based on the physical model\n * @param {object} meshData - Object containing mesh data\n * @param {object} boundaryConditions - Object containing boundary conditions\n * @param {object} [options] - Additional options for the solver\n * @returns {object} An object containing the solution vector and node coordinates\n */\nexport function runFrontalSolver(assembleFront, meshData, boundaryConditions, options = {}) {\n  // Initialize FEA components\n  const FEAData = initializeFEA(meshData);\n  const totalNodes = meshData.nodesXCoordinates.length;\n  const numElements = meshData.totalElements;\n  const nodesPerElement = FEAData.nodesPerElement;\n\n  // Calculate required array sizes\n  initializeFrontalArrays(nodesPerElement, numElements);\n\n  // Start timing for system solving (frontal algorithm)\n  basicLog(\"Solving system using frontal...\");\n  console.time(\"systemSolving\");\n\n  // Initialize basis functions\n  basisFunctions = new BasisFunctions({\n    meshDimension: meshData.meshDimension,\n    elementOrder: meshData.elementOrder,\n  });\n\n  // Copy node connectivity array into frontalData storage\n  for (let elementIndex = 0; elementIndex < meshData.totalElements; elementIndex++) {\n    for (let nodeIndex = 0; nodeIndex < FEAData.nodesPerElement; nodeIndex++) {\n      frontalData.nodalNumbering[elementIndex][nodeIndex] = meshData.nop[elementIndex][nodeIndex];\n    }\n  }\n\n  // Apply Dirichlet-type boundary conditions\n  // Initialize all nodes with no boundary condition\n  for (let nodeIndex = 0; nodeIndex < meshData.nodesXCoordinates.length; nodeIndex++) {\n    frontalData.nodeConstraintCode[nodeIndex] = 0;\n    frontalData.boundaryValues[nodeIndex] = 0;\n  }\n\n  // Handle Dirichlet-type boundary conditions differently based on which solver is being used\n  let dirichletBoundaryConditionsHandler;\n  // Solid heat transfer model (heatConductionScript solver)\n  if (assembleFront === assembleHeatConductionFront) {\n    dirichletBoundaryConditionsHandler = new ThermalBoundaryConditions(\n      boundaryConditions,\n      meshData.boundaryElements,\n      meshData.nop,\n      meshData.meshDimension,\n      meshData.elementOrder\n    );\n\n    dirichletBoundaryConditionsHandler.imposeConstantTempBoundaryConditionsFront(\n      frontalData.nodeConstraintCode,\n      frontalData.boundaryValues\n    );\n    // Front propagation model (frontPropagationScript solver)\n  } else if (assembleFront === assembleFrontPropagationFront) {\n    dirichletBoundaryConditionsHandler = new GenericBoundaryConditions(\n      boundaryConditions,\n      meshData.boundaryElements,\n      meshData.nop,\n      meshData.meshDimension,\n      meshData.elementOrder\n    );\n\n    dirichletBoundaryConditionsHandler.imposeConstantValueBoundaryConditionsFront(\n      frontalData.nodeConstraintCode,\n      frontalData.boundaryValues\n    );\n  }\n  // Initialize global residual vector\n  for (let nodeIndex = 0; nodeIndex < meshData.nodesXCoordinates.length; nodeIndex++) {\n    frontalData.globalResidualVector[nodeIndex] = 0;\n  }\n\n  frontalState.totalNodes = meshData.nodesXCoordinates.length;\n  frontalState.writeFlag = 0;\n  frontalState.transformationFlag = 1;\n  frontalState.determinant = 1;\n\n  for (let elementIndex = 0; elementIndex < meshData.totalElements; elementIndex++) {\n    frontalState.nodesPerElement[elementIndex] = FEAData.nodesPerElement;\n  }\n\n  // Parameters for non-linear assemblers\n  frontalState.currentSolutionVector = options.solutionVector;\n  frontalState.eikonalActivationFlag = options.eikonalActivationFlag;\n\n  // Pass assembleFront and dirichletBoundaryConditionsHandler to runFrontalAlgorithm\n  runFrontalAlgorithm(meshData, FEAData, dirichletBoundaryConditionsHandler, assembleFront);\n\n  // Copy solution\n  for (let nodeIndex = 0; nodeIndex < meshData.nodesXCoordinates.length; nodeIndex++) {\n    frontalData.solutionVector[nodeIndex] = frontalState.globalSolutionVector[nodeIndex];\n  }\n\n  // Output results to console for debugging\n  const { nodesXCoordinates, nodesYCoordinates } = meshData;\n  for (let nodeIndex = 0; nodeIndex < meshData.nodesXCoordinates.length; nodeIndex++) {\n    if (meshData.meshDimension === \"1D\") {\n      // 1D case - only output X coordinates and temperature\n      debugLog(\n        `${nodesXCoordinates[nodeIndex].toExponential(5)}  ${frontalData.solutionVector[\n          nodeIndex\n        ].toExponential(5)}`\n      );\n    } else {\n      // 2D case - output X, Y coordinates and temperature\n      debugLog(\n        `${nodesXCoordinates[nodeIndex].toExponential(5)}  ${nodesYCoordinates[nodeIndex].toExponential(\n          5\n        )}  ${frontalData.solutionVector[nodeIndex].toExponential(5)}`\n      );\n    }\n  }\n\n  console.timeEnd(\"systemSolving\");\n  basicLog(\"System solved successfully\");\n\n  const { nodesXCoordinates: finalNodesX, nodesYCoordinates: finalNodesY } = meshData;\n  return {\n    solutionVector: frontalData.solutionVector.slice(0, totalNodes),\n    nodesCoordinates: {\n      nodesXCoordinates: finalNodesX,\n      nodesYCoordinates: finalNodesY,\n    },\n  };\n}\n\n/**\n * Function to initialize arrays dynamically based on problem size\n * @param {number} nodesPerElement - Number of nodes per element\n * @param {number} numElements - Number of elements in the mesh\n */\nfunction initializeFrontalArrays(nodesPerElement, numElements) {\n  // Use the actual number of elements from the mesh\n  frontalData.nodalNumbering = Array(numElements)\n    .fill()\n    .map(() => Array(nodesPerElement).fill(0));\n  frontalData.nodeConstraintCode = Array(nodesPerElement).fill(0);\n  frontalData.boundaryValues = Array(nodesPerElement).fill(0);\n  frontalData.globalResidualVector = Array(nodesPerElement).fill(0);\n  frontalData.solutionVector = Array(nodesPerElement).fill(0);\n  frontalData.topologyData = Array(numElements).fill(0);\n  frontalData.lateralData = Array(numElements).fill(0);\n\n  // Initialize frontalState arrays\n  frontalState.writeFlag = 0;\n  frontalState.totalNodes = nodesPerElement;\n  frontalState.transformationFlag = 0;\n  frontalState.nodesPerElement = Array(numElements).fill(0);\n  frontalState.determinant = 1;\n\n  // For matrix operations, estimate required size based on problem complexity\n  const systemSize = Math.max(nodesPerElement, 2000);\n  frontalState.globalSolutionVector = Array(systemSize).fill(0);\n  frontalState.frontDataIndex = 0;\n\n  // Initialize elementData arrays\n  elementData.localJacobianMatrix = Array(nodesPerElement)\n    .fill()\n    .map(() => Array(nodesPerElement).fill(0));\n  elementData.currentElementIndex = 0;\n\n  // Initialize frontStorage arrays\n  const frontSize = estimateFrontSize(nodesPerElement, numElements);\n  frontStorage.frontValues = Array(frontSize).fill(0);\n  frontStorage.columnHeaders = Array(systemSize).fill(0);\n  frontStorage.pivotRow = Array(systemSize).fill(0);\n  frontStorage.pivotData = Array(frontSize).fill(0);\n}\n\n/**\n * Function to estimate the required front size\n * @param {number} nodesPerElement - Number of of nodes per element\n * @param {number} numElements - Number of elements in the mesh\n * @returns {number} Estimated front size\n */\nfunction estimateFrontSize(nodesPerElement, numElements) {\n  const frontWidthEstimate = Math.max(Math.ceil(Math.sqrt(numElements)) * nodesPerElement, nodesPerElement * 2);\n  return frontWidthEstimate * numElements;\n}\n// Old function to estimate the required front size\n// function estimateFrontSize(nodesPerElement, numElements, nodesPerElement) {\n//   const frontWidthEstimate = Math.ceil(Math.sqrt(numElements) * nodesPerElement * 2);\n//   const frontSize = frontWidthEstimate * nodesPerElement * 4;\n//   return Math.max(frontSize, 10000);\n// }\n\n/**\n * Function to compute local Jacobian matrix and local residual vector\n * @param {object} meshData - Object containing mesh data\n * @param {object} FEAData - Object containing FEA-related data\n * @param {object} thermalBoundaryConditions - Object containing thermal boundary conditions\n * @param {function} assembleFront - Matrix assembler based on the physical model\n */\nfunction assembleElementContribution(meshData, FEAData, thermalBoundaryConditions, assembleFront) {\n  const elementIndex = elementData.currentElementIndex - 1;\n\n  // Guard against out-of-range indices\n  if (elementIndex < 0 || elementIndex >= meshData.totalElements) {\n    errorLog(`Skipping out-of-range elementIndex=${elementIndex} (totalElements=${meshData.totalElements})`);\n    return false;\n  }\n\n  // Domain terms\n  const { localJacobianMatrix, localResidualVector, ngl } = assembleFront({\n    elementIndex,\n    nop: frontalData.nodalNumbering,\n    meshData,\n    basisFunctions: basisFunctions,\n    FEAData,\n    // These are ignored by linear assemblers\n    solutionVector: frontalState.currentSolutionVector,\n    eikonalActivationFlag: frontalState.eikonalActivationFlag,\n  });\n\n  // Handle Robin-type boundary conditions differently based on which solver is being used\n  let boundaryLocalJacobianMatrix = Array(FEAData.nodesPerElement)\n    .fill()\n    .map(() => Array(FEAData.nodesPerElement).fill(0));\n  let boundaryResidualVector = Array(FEAData.nodesPerElement).fill(0);\n\n  // heatConductionScript solver\n  if (assembleFront === assembleHeatConductionFront) {\n    // Check if this element is on a Robin-type boundary\n    let isOnRobinTypeBoundary = false;\n    for (const boundaryKey in meshData.boundaryElements) {\n      if (\n        thermalBoundaryConditions.boundaryConditions[boundaryKey]?.[0] === \"convection\" &&\n        meshData.boundaryElements[boundaryKey].some(([boundaryElementIndex, _]) => boundaryElementIndex === elementIndex)\n      ) {\n        isOnRobinTypeBoundary = true;\n        break;\n      }\n    }\n\n    // Only calculate Robin-type for elements when required\n    if (isOnRobinTypeBoundary) {\n      const { gaussPoints, gaussWeights } = FEAData;\n      const result = thermalBoundaryConditions.imposeConvectionBoundaryConditionsFront(\n        elementIndex,\n        meshData.nodesXCoordinates,\n        meshData.nodesYCoordinates,\n        gaussPoints,\n        gaussWeights,\n        basisFunctions\n      );\n      boundaryLocalJacobianMatrix = result.localJacobianMatrix;\n      boundaryResidualVector = result.localResidualVector;\n    }\n  } else if (assembleFront === assembleFrontPropagationFront) {\n    // For now, no Robin-type boundary conditions exist for any other solver\n  }\n\n  // Combine domain and boundary contributions\n  for (let localNodeI = 0; localNodeI < FEAData.nodesPerElement; localNodeI++) {\n    for (let localNodeJ = 0; localNodeJ < FEAData.nodesPerElement; localNodeJ++) {\n      elementData.localJacobianMatrix[localNodeI][localNodeJ] =\n        localJacobianMatrix[localNodeI][localNodeJ] + boundaryLocalJacobianMatrix[localNodeI][localNodeJ];\n    }\n  }\n\n  // Assemble local element residual\n  for (let localNodeIndex = 0; localNodeIndex < FEAData.nodesPerElement; localNodeIndex++) {\n    const globalNodeIndex = ngl[localNodeIndex] - 1;\n    frontalData.globalResidualVector[globalNodeIndex] +=\n      localResidualVector[localNodeIndex] + boundaryResidualVector[localNodeIndex];\n  }\n\n  return true;\n}\n\n/**\n * Function to implement the frontal solver algorithm\n * @param {object} meshData - Object containing mesh data\n * @param {object} FEAData - Object containing FEA-related data\n * @param {object} thermalBoundaryConditions - Object containing thermal boundary conditions\n * @param {function} assembleFront - Matrix assembler based on the physical model\n */\nfunction runFrontalAlgorithm(meshData, FEAData, thermalBoundaryConditions, assembleFront) {\n  // Allocate local arrays dynamically\n  const totalElements = meshData.totalElements;\n  const nodesPerElement = meshData.nodesXCoordinates.length;\n  const systemSize = Math.max(nodesPerElement, frontalState.globalSolutionVector.length);\n  let localDestination = Array(FEAData.nodesPerElement).fill(0);\n  let rowDestination = Array(FEAData.nodesPerElement).fill(0);\n  let rowHeaders = Array(systemSize).fill(0);\n  let pivotRowIndices = Array(systemSize).fill(0);\n  let pivotColumnIndices = Array(systemSize).fill(0);\n  let modifiedRows = Array(systemSize).fill(0);\n  let pivotColumn = Array(systemSize).fill(0);\n  let frontMatrix = Array(systemSize)\n    .fill()\n    .map(() => Array(systemSize).fill(0));\n  let rowSwapCount = Array(nodesPerElement).fill(0);\n  let columnSwapCount = Array(nodesPerElement).fill(0);\n  let lastAppearanceCheck = Array(nodesPerElement).fill(0);\n  let pivotColumnGlobalIndex; // Pivot column global index\n\n  let frontDataCounter = 1;\n  frontalState.writeFlag++;\n  let pivotDataIndex = 1;\n  let summedRows = 1;\n  elementData.currentElementIndex = 0;\n\n  for (let nodeIndex = 0; nodeIndex < frontalState.totalNodes; nodeIndex++) {\n    rowSwapCount[nodeIndex] = 0;\n    columnSwapCount[nodeIndex] = 0;\n  }\n\n  if (frontalState.transformationFlag !== 0) {\n    // Prefront: find last appearance of each node\n    for (let nodeIndex = 0; nodeIndex < frontalState.totalNodes; nodeIndex++) {\n      lastAppearanceCheck[nodeIndex] = 0;\n    }\n\n    for (let elementIndex = 0; elementIndex < totalElements; elementIndex++) {\n      let reverseElementIndex = totalElements - elementIndex - 1;\n      for (\n        let localNodeIndex = 0;\n        localNodeIndex < frontalState.nodesPerElement[reverseElementIndex];\n        localNodeIndex++\n      ) {\n        let globalNodeIndex = frontalData.nodalNumbering[reverseElementIndex][localNodeIndex];\n        if (lastAppearanceCheck[globalNodeIndex - 1] === 0) {\n          lastAppearanceCheck[globalNodeIndex - 1] = 1;\n          frontalData.nodalNumbering[reverseElementIndex][localNodeIndex] =\n            -frontalData.nodalNumbering[reverseElementIndex][localNodeIndex];\n        }\n      }\n    }\n  }\n\n  frontalState.transformationFlag = 0;\n  let columnCount = 0;\n  let rowCount = 0;\n\n  for (let i = 0; i < systemSize; i++) {\n    for (let j = 0; j < systemSize; j++) {\n      frontMatrix[j][i] = 0;\n    }\n  }\n\n  while (true) {\n    // Assemble a new element only while we still have elements\n    let assembled = false;\n    let numElementNodes = 0;\n    let numElementColumns = 0;\n\n    if (elementData.currentElementIndex < totalElements) {\n      elementData.currentElementIndex++;\n      assembled = assembleElementContribution(meshData, FEAData, thermalBoundaryConditions, assembleFront);\n    }\n\n    if (assembled) {\n      const currentElement = elementData.currentElementIndex;\n      numElementNodes = frontalState.nodesPerElement[currentElement - 1];\n      numElementColumns = frontalState.nodesPerElement[currentElement - 1];\n\n      for (let localNodeIndex = 0; localNodeIndex < numElementColumns; localNodeIndex++) {\n        let globalNodeIndex = frontalData.nodalNumbering[currentElement - 1][localNodeIndex];\n        let columnIndex;\n\n        if (columnCount === 0) {\n          columnCount++;\n          localDestination[localNodeIndex] = columnCount;\n          frontStorage.columnHeaders[columnCount - 1] = globalNodeIndex;\n        } else {\n          for (columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n            if (Math.abs(globalNodeIndex) === Math.abs(frontStorage.columnHeaders[columnIndex])) break;\n          }\n\n          if (columnIndex === columnCount) {\n            columnCount++;\n            localDestination[localNodeIndex] = columnCount;\n            frontStorage.columnHeaders[columnCount - 1] = globalNodeIndex;\n          } else {\n            localDestination[localNodeIndex] = columnIndex + 1;\n            frontStorage.columnHeaders[columnIndex] = globalNodeIndex;\n          }\n        }\n\n        let rowIndex;\n        if (rowCount === 0) {\n          rowCount++;\n          rowDestination[localNodeIndex] = rowCount;\n          rowHeaders[rowCount - 1] = globalNodeIndex;\n        } else {\n          for (rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n            if (Math.abs(globalNodeIndex) === Math.abs(rowHeaders[rowIndex])) break;\n          }\n\n          if (rowIndex === rowCount) {\n            rowCount++;\n            rowDestination[localNodeIndex] = rowCount;\n            rowHeaders[rowCount - 1] = globalNodeIndex;\n          } else {\n            rowDestination[localNodeIndex] = rowIndex + 1;\n            rowHeaders[rowIndex] = globalNodeIndex;\n          }\n        }\n      }\n\n      if (rowCount > systemSize || columnCount > systemSize) {\n        errorLog(\"Error: systemSize not large enough\");\n        return;\n      }\n\n      for (let localColumnIndex = 0; localColumnIndex < numElementColumns; localColumnIndex++) {\n        let frontColumnIndex = localDestination[localColumnIndex];\n        for (let localRowIndex = 0; localRowIndex < numElementNodes; localRowIndex++) {\n          let frontRowIndex = rowDestination[localRowIndex];\n          frontMatrix[frontRowIndex - 1][frontColumnIndex - 1] +=\n            elementData.localJacobianMatrix[localRowIndex][localColumnIndex];\n        }\n      }\n    }\n\n    // Pivoting/elimination continues whether or not a new element was assembled\n    let availableColumnCount = 0;\n    for (let columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n      if (frontStorage.columnHeaders[columnIndex] < 0) {\n        pivotColumnIndices[availableColumnCount] = columnIndex + 1;\n        availableColumnCount++;\n      }\n    }\n\n    let constrainedRowCount = 0;\n    let availableRowCount = 0;\n    for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n      let globalNodeIndex = rowHeaders[rowIndex];\n      if (globalNodeIndex < 0) {\n        pivotRowIndices[availableRowCount] = rowIndex + 1;\n        availableRowCount++;\n        let absoluteNodeIndex = Math.abs(globalNodeIndex);\n        if (frontalData.nodeConstraintCode[absoluteNodeIndex - 1] === 1) {\n          modifiedRows[constrainedRowCount] = rowIndex + 1;\n          constrainedRowCount++;\n          frontalData.nodeConstraintCode[absoluteNodeIndex - 1] = 2;\n          frontalData.globalResidualVector[absoluteNodeIndex - 1] =\n            frontalData.boundaryValues[absoluteNodeIndex - 1];\n        }\n      }\n    }\n\n    if (constrainedRowCount > 0) {\n      for (let constrainedIndex = 0; constrainedIndex < constrainedRowCount; constrainedIndex++) {\n        let rowIndex = modifiedRows[constrainedIndex] - 1;\n        let globalNodeIndex = Math.abs(rowHeaders[rowIndex]);\n        for (let columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n          frontMatrix[rowIndex][columnIndex] = 0;\n          let columnGlobalIndex = Math.abs(frontStorage.columnHeaders[columnIndex]);\n          if (columnGlobalIndex === globalNodeIndex) frontMatrix[rowIndex][columnIndex] = 1;\n        }\n      }\n    }\n\n    if (availableColumnCount > summedRows || elementData.currentElementIndex < totalElements) {\n      if (availableColumnCount === 0) {\n        errorLog(\"Error: no more rows fully summed\");\n        return;\n      }\n\n      let pivotRowIndex = pivotRowIndices[0];\n      let pivotColumnIndex = pivotColumnIndices[0];\n      let pivotValue = frontMatrix[pivotRowIndex - 1][pivotColumnIndex - 1];\n\n      if (Math.abs(pivotValue) < 1e-4) {\n        pivotValue = 0;\n        for (let columnIndex = 0; columnIndex < availableColumnCount; columnIndex++) {\n          let testColumnIndex = pivotColumnIndices[columnIndex];\n          for (let rowIndex = 0; rowIndex < availableRowCount; rowIndex++) {\n            let testRowIndex = pivotRowIndices[rowIndex];\n            let testValue = frontMatrix[testRowIndex - 1][testColumnIndex - 1];\n            if (Math.abs(testValue) > Math.abs(pivotValue)) {\n              pivotValue = testValue;\n              pivotColumnIndex = testColumnIndex;\n              pivotRowIndex = testRowIndex;\n            }\n          }\n        }\n      }\n\n      let pivotGlobalRowIndex = Math.abs(rowHeaders[pivotRowIndex - 1]);\n      pivotColumnGlobalIndex = Math.abs(frontStorage.columnHeaders[pivotColumnIndex - 1]); // Assign, don't declare\n      let permutationHelper =\n        pivotGlobalRowIndex +\n        pivotColumnGlobalIndex +\n        rowSwapCount[pivotGlobalRowIndex - 1] +\n        columnSwapCount[pivotColumnGlobalIndex - 1];\n      frontalState.determinant =\n        (frontalState.determinant * pivotValue * (-1) ** permutationHelper) / Math.abs(pivotValue);\n\n      for (let nodeIndex = 0; nodeIndex < frontalState.totalNodes; nodeIndex++) {\n        if (nodeIndex >= pivotGlobalRowIndex) rowSwapCount[nodeIndex]--;\n        if (nodeIndex >= pivotColumnGlobalIndex) columnSwapCount[nodeIndex]--;\n      }\n\n      if (Math.abs(pivotValue) < 1e-10) {\n        errorLog(\n          `Matrix singular or ill-conditioned, currentElementIndex=${elementData.currentElementIndex}, pivotGlobalRowIndex=${pivotGlobalRowIndex}, pivotColumnGlobalIndex=${pivotColumnGlobalIndex}, pivotValue=${pivotValue}`\n        );\n      }\n\n      if (pivotValue === 0) return;\n\n      for (let columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n        frontStorage.pivotRow[columnIndex] = frontMatrix[pivotRowIndex - 1][columnIndex] / pivotValue;\n      }\n\n      let rightHandSide = frontalData.globalResidualVector[pivotGlobalRowIndex - 1] / pivotValue;\n      frontalData.globalResidualVector[pivotGlobalRowIndex - 1] = rightHandSide;\n      pivotColumn[pivotRowIndex - 1] = pivotValue;\n\n      if (pivotRowIndex > 1) {\n        for (let rowIndex = 0; rowIndex < pivotRowIndex - 1; rowIndex++) {\n          let globalRowIndex = Math.abs(rowHeaders[rowIndex]);\n          let eliminationFactor = frontMatrix[rowIndex][pivotColumnIndex - 1];\n          pivotColumn[rowIndex] = eliminationFactor;\n          if (pivotColumnIndex > 1 && eliminationFactor !== 0) {\n            for (let columnIndex = 0; columnIndex < pivotColumnIndex - 1; columnIndex++) {\n              frontMatrix[rowIndex][columnIndex] -= eliminationFactor * frontStorage.pivotRow[columnIndex];\n            }\n          }\n          if (pivotColumnIndex < columnCount) {\n            for (let columnIndex = pivotColumnIndex; columnIndex < columnCount; columnIndex++) {\n              frontMatrix[rowIndex][columnIndex - 1] =\n                frontMatrix[rowIndex][columnIndex] - eliminationFactor * frontStorage.pivotRow[columnIndex];\n            }\n          }\n          frontalData.globalResidualVector[globalRowIndex - 1] -= eliminationFactor * rightHandSide;\n        }\n      }\n\n      if (pivotRowIndex < rowCount) {\n        for (let rowIndex = pivotRowIndex; rowIndex < rowCount; rowIndex++) {\n          let globalRowIndex = Math.abs(rowHeaders[rowIndex]);\n          let eliminationFactor = frontMatrix[rowIndex][pivotColumnIndex - 1];\n          pivotColumn[rowIndex] = eliminationFactor;\n          if (pivotColumnIndex > 1) {\n            for (let columnIndex = 0; columnIndex < pivotColumnIndex - 1; columnIndex++) {\n              frontMatrix[rowIndex - 1][columnIndex] =\n                frontMatrix[rowIndex][columnIndex] - eliminationFactor * frontStorage.pivotRow[columnIndex];\n            }\n          }\n          if (pivotColumnIndex < columnCount) {\n            for (let columnIndex = pivotColumnIndex; columnIndex < columnCount; columnIndex++) {\n              frontMatrix[rowIndex - 1][columnIndex - 1] =\n                frontMatrix[rowIndex][columnIndex] - eliminationFactor * frontStorage.pivotRow[columnIndex];\n            }\n          }\n          frontalData.globalResidualVector[globalRowIndex - 1] -= eliminationFactor * rightHandSide;\n        }\n      }\n\n      for (let i = 0; i < rowCount; i++) {\n        frontStorage.pivotData[pivotDataIndex + i - 1] = pivotColumn[i];\n      }\n      pivotDataIndex += rowCount;\n\n      for (let i = 0; i < rowCount; i++) {\n        frontStorage.pivotData[pivotDataIndex + i - 1] = rowHeaders[i];\n      }\n      pivotDataIndex += rowCount;\n\n      frontStorage.pivotData[pivotDataIndex - 1] = pivotRowIndex;\n      pivotDataIndex++;\n\n      for (let i = 0; i < columnCount; i++) {\n        frontStorage.frontValues[frontDataCounter - 1 + i] = frontStorage.pivotRow[i];\n      }\n      frontDataCounter += columnCount;\n\n      for (let i = 0; i < columnCount; i++) {\n        frontStorage.frontValues[frontDataCounter - 1 + i] = frontStorage.columnHeaders[i];\n      }\n      frontDataCounter += columnCount;\n\n      frontStorage.frontValues[frontDataCounter - 1] = pivotGlobalRowIndex;\n      frontStorage.frontValues[frontDataCounter] = columnCount;\n      frontStorage.frontValues[frontDataCounter + 1] = pivotColumnIndex;\n      frontStorage.frontValues[frontDataCounter + 2] = pivotValue;\n      frontDataCounter += 4;\n\n      for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n        frontMatrix[rowIndex][columnCount - 1] = 0;\n      }\n\n      for (let columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n        frontMatrix[rowCount - 1][columnIndex] = 0;\n      }\n\n      columnCount--;\n      if (pivotColumnIndex < columnCount + 1) {\n        for (let columnIndex = pivotColumnIndex - 1; columnIndex < columnCount; columnIndex++) {\n          frontStorage.columnHeaders[columnIndex] = frontStorage.columnHeaders[columnIndex + 1];\n        }\n      }\n\n      rowCount--;\n      if (pivotRowIndex < rowCount + 1) {\n        for (let rowIndex = pivotRowIndex - 1; rowIndex < rowCount; rowIndex++) {\n          rowHeaders[rowIndex] = rowHeaders[rowIndex + 1];\n        }\n      }\n\n      if (rowCount > 1 || elementData.currentElementIndex < totalElements) continue;\n\n      pivotColumnGlobalIndex = Math.abs(frontStorage.columnHeaders[0]); // Assign, don't declare\n      pivotRowIndex = 1;\n      pivotValue = frontMatrix[0][0];\n      pivotGlobalRowIndex = Math.abs(rowHeaders[0]);\n      pivotColumnIndex = 1;\n      permutationHelper =\n        pivotGlobalRowIndex +\n        pivotColumnGlobalIndex +\n        rowSwapCount[pivotGlobalRowIndex - 1] +\n        columnSwapCount[pivotColumnGlobalIndex - 1];\n      frontalState.determinant =\n        (frontalState.determinant * pivotValue * (-1) ** permutationHelper) / Math.abs(pivotValue);\n\n      frontStorage.pivotRow[0] = 1;\n      if (Math.abs(pivotValue) < 1e-10) {\n        errorLog(\n          `Matrix singular or ill-conditioned, currentElementIndex=${elementData.currentElementIndex}, pivotGlobalRowIndex=${pivotGlobalRowIndex}, pivotColumnGlobalIndex=${pivotColumnGlobalIndex}, pivotValue=${pivotValue}`\n        );\n      }\n\n      if (pivotValue === 0) return;\n\n      frontalData.globalResidualVector[pivotGlobalRowIndex - 1] =\n        frontalData.globalResidualVector[pivotGlobalRowIndex - 1] / pivotValue;\n      frontStorage.frontValues[frontDataCounter - 1] = frontStorage.pivotRow[0];\n      frontDataCounter++;\n      frontStorage.frontValues[frontDataCounter - 1] = frontStorage.columnHeaders[0];\n      frontDataCounter++;\n      frontStorage.frontValues[frontDataCounter - 1] = pivotGlobalRowIndex;\n      frontStorage.frontValues[frontDataCounter] = columnCount;\n      frontStorage.frontValues[frontDataCounter + 1] = pivotColumnIndex;\n      frontStorage.frontValues[frontDataCounter + 2] = pivotValue;\n      frontDataCounter += 4;\n\n      frontStorage.pivotData[pivotDataIndex - 1] = pivotColumn[0];\n      pivotDataIndex++;\n      frontStorage.pivotData[pivotDataIndex - 1] = rowHeaders[0];\n      pivotDataIndex++;\n      frontStorage.pivotData[pivotDataIndex - 1] = pivotRowIndex;\n      pivotDataIndex++;\n\n      frontalState.frontDataIndex = frontDataCounter;\n      if (frontalState.writeFlag === 1)\n        debugLog(`total ecs transfer in matrix reduction=${frontDataCounter}`);\n\n      // Back substitution\n      performBackSubstitution(frontDataCounter);\n      break;\n    }\n  }\n}\n\n/**\n * Function to perform back substitution for the frontal solver\n * @param {number} frontDataCounter - Index counter for the element contributions\n */\nfunction performBackSubstitution(frontDataCounter) {\n  for (let nodeIndex = 0; nodeIndex < frontalState.totalNodes; nodeIndex++) {\n    frontalState.globalSolutionVector[nodeIndex] = frontalData.boundaryValues[nodeIndex];\n  }\n\n  for (let iterationIndex = 1; iterationIndex <= frontalState.totalNodes; iterationIndex++) {\n    frontDataCounter -= 4;\n    let pivotGlobalRowIndex = frontStorage.frontValues[frontDataCounter - 1];\n    let columnCount = frontStorage.frontValues[frontDataCounter];\n    let pivotColumnIndex = frontStorage.frontValues[frontDataCounter + 1];\n    let pivotValue = frontStorage.frontValues[frontDataCounter + 2];\n\n    if (iterationIndex === 1) {\n      frontDataCounter--;\n      frontStorage.columnHeaders[0] = frontStorage.frontValues[frontDataCounter - 1];\n      frontDataCounter--;\n      frontStorage.pivotRow[0] = frontStorage.frontValues[frontDataCounter - 1];\n    } else {\n      frontDataCounter -= columnCount;\n      for (let columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n        frontStorage.columnHeaders[columnIndex] =\n          frontStorage.frontValues[frontDataCounter - 1 + columnIndex];\n      }\n      frontDataCounter -= columnCount;\n      for (let columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n        frontStorage.pivotRow[columnIndex] = frontStorage.frontValues[frontDataCounter - 1 + columnIndex];\n      }\n    }\n\n    let pivotColumnGlobalIndex = Math.abs(frontStorage.columnHeaders[pivotColumnIndex - 1]);\n    if (frontalData.nodeConstraintCode[pivotColumnGlobalIndex - 1] > 0) continue;\n\n    let accumulatedValue = 0;\n    frontStorage.pivotRow[pivotColumnIndex - 1] = 0;\n    for (let columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n      accumulatedValue -=\n        frontStorage.pivotRow[columnIndex] *\n        frontalState.globalSolutionVector[Math.abs(frontStorage.columnHeaders[columnIndex]) - 1];\n    }\n\n    frontalState.globalSolutionVector[pivotColumnGlobalIndex - 1] =\n      accumulatedValue + frontalData.globalResidualVector[pivotGlobalRowIndex - 1];\n\n    frontalData.nodeConstraintCode[pivotColumnGlobalIndex - 1] = 1;\n  }\n\n  if (frontalState.writeFlag === 1)\n    debugLog(`value of frontDataCounter after backsubstitution=${frontDataCounter}`);\n}\n","/**\n * ════════════════════════════════════════════════════════════════\n *  FEAScript Core Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.2.0 | https://feascript.com\n *  MIT License © 2023–2026 FEAScript\n * ════════════════════════════════════════════════════════════════\n */\n\n// Internal imports\nimport { euclideanNorm } from \"../methods/euclideanNormScript.js\";\nimport { solveLinearSystem } from \"./linearSystemSolverScript.js\";\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\nimport { runFrontalSolver } from \"./frontalSolverScript.js\";\nimport { assembleFrontPropagationFront } from \"../models/frontPropagationScript.js\";\n\n/**\n * Function to solve a system of non-linear equations using the Newton-Raphson method\n * @param {function} assembleMat - Matrix assembler based on the physical model\n * @param {object} context - Context object containing simulation data and options\n * @returns {object} An object containing:\n *  - solutionVector: The solution vector\n *  - iterations: The number of iterations performed\n *  - converged: Boolean indicating whether the method converged\n */\n\nexport function newtonRaphson(assembleMat, context = {}) {\n  let errorNorm = 0;\n  let converged = false;\n  let iterations = 0;\n  let deltaX = [];\n  let solutionVector = [];\n  let jacobianMatrix = [];\n  let residualVector = [];\n\n  // Extract context\n  const { maxIterations = 100, tolerance = 1e-4 } = context;\n\n  // Calculate system size\n  let totalNodes = context.meshData.nodesXCoordinates.length;\n\n  // Initialize arrays with proper size\n  for (let i = 0; i < totalNodes; i++) {\n    deltaX[i] = 0;\n    solutionVector[i] = 0;\n  }\n\n  // Initialize solution from context if available\n  if (context.initialSolution && context.initialSolution.length === totalNodes) {\n    solutionVector = [...context.initialSolution];\n  }\n\n  while (iterations < maxIterations && !converged) {\n    // Update solution\n    for (let i = 0; i < solutionVector.length; i++) {\n      solutionVector[i] = Number(solutionVector[i]) + Number(deltaX[i]);\n    }\n\n    // Check if using frontal solver\n    if (context.solverMethod === \"frontal\") {\n      const frontalResult = runFrontalSolver(\n        assembleFrontPropagationFront,\n        context.meshData,\n        context.boundaryConditions,\n        { solutionVector, eikonalActivationFlag: context.eikonalActivationFlag }\n      );\n      deltaX = frontalResult.solutionVector;\n    } else {\n      // Compute Jacobian and residual matrices\n      ({ jacobianMatrix, residualVector } = assembleMat(\n        context.meshData,\n        context.boundaryConditions,\n        solutionVector, // The solution vector is required in the case of a non-linear equation\n        context.eikonalActivationFlag // Currently used only in the front propagation solver (TODO refactor in case of a solver not needing it)\n      ));\n\n      // Solve the linear system based on the specified solver method\n      const linearSystemResult = solveLinearSystem(context.solverMethod, jacobianMatrix, residualVector);\n      deltaX = linearSystemResult.solutionVector;\n    }\n\n    // Check convergence\n    errorNorm = euclideanNorm(deltaX);\n\n    // Norm for each iteration\n    basicLog(`Newton-Raphson iteration ${iterations + 1}: Error norm = ${errorNorm.toExponential(4)}`);\n\n    if (errorNorm <= tolerance) {\n      converged = true;\n    } else if (errorNorm > 1e2) {\n      errorLog(`Solution not converged. Error norm: ${errorNorm}`);\n      break;\n    }\n\n    iterations++;\n  }\n\n  return {\n    solutionVector,\n    converged,\n    iterations,\n    jacobianMatrix,\n    residualVector,\n  };\n}\n","/**\n * ════════════════════════════════════════════════════════════════\n *  FEAScript Core Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.2.0 | https://feascript.com\n *  MIT License © 2023–2026 FEAScript\n * ════════════════════════════════════════════════════════════════\n */\n\n// Internal imports\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Class to handle flow boundary conditions application for Stokes and Navier-Stokes models\n */\nexport class FlowBoundaryConditions {\n  /**\n   * Constructor to initialize the FlowBoundaryConditions class\n   * @param {object} boundaryConditions - Object containing boundary conditions for the finite element analysis\n   * @param {array} boundaryElements - Array containing elements that belong to each boundary\n   * @param {array} nop - Nodal numbering (NOP) array representing the connectivity between elements and nodes\n   * @param {string} meshDimension - The dimension of the mesh (e.g., \"2D\")\n   * @param {string} elementOrder - The order of elements (e.g., \"linear\", \"quadratic\")\n   * @param {number} totalNodesVelocity - Total number of velocity nodes (Q2)\n   * @param {number} totalNodesPressure - Total number of pressure nodes (Q1)\n   * @param {Map} q2ToPressureMap - Map from global Q2 node index to pressure DOF index\n   */\n  constructor(\n    boundaryConditions,\n    boundaryElements,\n    nop,\n    meshDimension,\n    elementOrder,\n    totalNodesVelocity,\n    totalNodesPressure,\n    q2ToPressureMap,\n  ) {\n    this.boundaryConditions = boundaryConditions;\n    this.boundaryElements = boundaryElements;\n    this.nop = nop;\n    this.meshDimension = meshDimension;\n    this.elementOrder = elementOrder;\n    this.totalNodesVelocity = totalNodesVelocity;\n    this.totalNodesPressure = totalNodesPressure;\n    this.q2ToPressureMap = q2ToPressureMap;\n  }\n\n  /**\n   * Function to impose velocity Dirichlet boundary conditions\n   * @param {array} residualVector - The residual vector to be modified\n   * @param {array} jacobianMatrix - The Jacobian matrix to be modified\n   *\n   * For consistency across both linear and nonlinear formulations,\n   * this project always refers to the assembled right-hand side vector\n   * as `residualVector` and the assembled system matrix as `jacobianMatrix`.\n   *\n   * In linear problems `jacobianMatrix` is equivalent to the\n   * classic stiffness/conductivity matrix and `residualVector`\n   * corresponds to the traditional load (RHS) vector.\n   *\n   * Supported boundary condition types:\n   *  - \"constantVelocity\": Set velocity components at boundary nodes\n   *    Format: [\"constantVelocity\", uValue, vValue]\n   *  - \"stressFree\": Natural boundary condition (zero traction), no assembly needed\n   *    Format: [\"stressFree\"]\n   */\n  imposeDirichletBoundaryConditions(residualVector, jacobianMatrix) {\n    const totalDOFs = residualVector.length;\n    let hasStressFree = false;\n\n    if (this.meshDimension === \"2D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        const bcType = this.boundaryConditions[boundaryKey][0];\n\n        if (bcType === \"stressFree\") {\n          hasStressFree = true;\n          // Natural boundary condition - no explicit assembly needed\n          debugLog(`Boundary ${boundaryKey}: Applying stress-free condition (natural BC)`);\n        } else if (bcType === \"constantVelocity\") {\n          const uValue = this.boundaryConditions[boundaryKey][1];\n          const vValue = this.boundaryConditions[boundaryKey][2];\n          debugLog(\n            `Boundary ${boundaryKey}: Applying constant velocity condition (u=${uValue}, v=${vValue})`,\n          );\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            if (this.elementOrder === \"quadratic\") {\n              const boundarySides = {\n                0: [0, 3, 6], // Nodes at the bottom side of the reference element\n                1: [0, 1, 2], // Nodes at the left side of the reference element\n                2: [2, 5, 8], // Nodes at the top side of the reference element\n                3: [6, 7, 8], // Nodes at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                const uDOF = globalNodeIndex;\n                const vDOF = this.totalNodesVelocity + globalNodeIndex;\n                debugLog(\n                  `  - Applied velocity Dirichlet to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`,\n                );\n                // Apply u-velocity Dirichlet boundary condition\n                residualVector[uDOF] = uValue;\n                for (let colIndex = 0; colIndex < totalDOFs; colIndex++) {\n                  jacobianMatrix[uDOF][colIndex] = 0;\n                }\n                jacobianMatrix[uDOF][uDOF] = 1;\n\n                // Apply v-velocity Dirichlet boundary condition\n                residualVector[vDOF] = vValue;\n                for (let colIndex = 0; colIndex < totalDOFs; colIndex++) {\n                  jacobianMatrix[vDOF][colIndex] = 0;\n                }\n                jacobianMatrix[vDOF][vDOF] = 1;\n              });\n            } else if (this.elementOrder === \"linear\") {\n              const boundarySides = {\n                0: [0, 2], // Nodes at the bottom side of the reference element\n                1: [0, 1], // Nodes at the left side of the reference element\n                2: [1, 3], // Nodes at the top side of the reference element\n                3: [2, 3], // Nodes at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                const uDOF = globalNodeIndex;\n                const vDOF = this.totalNodesVelocity + globalNodeIndex;\n                debugLog(\n                  `  - Applied velocity Dirichlet to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`,\n                );\n                // Apply u-velocity Dirichlet boundary condition\n                residualVector[uDOF] = uValue;\n                for (let colIndex = 0; colIndex < totalDOFs; colIndex++) {\n                  jacobianMatrix[uDOF][colIndex] = 0;\n                }\n                jacobianMatrix[uDOF][uDOF] = 1;\n\n                // Apply v-velocity Dirichlet boundary condition\n                residualVector[vDOF] = vValue;\n                for (let colIndex = 0; colIndex < totalDOFs; colIndex++) {\n                  jacobianMatrix[vDOF][colIndex] = 0;\n                }\n                jacobianMatrix[vDOF][vDOF] = 1;\n              });\n            }\n          });\n        }\n      });\n\n      // If no stress-free boundary exists, pin pressure at one node to remove null space\n      // (pressure is determined only up to a constant for all-Dirichlet velocity problems)\n      if (!hasStressFree) {\n        const pDOF = 2 * this.totalNodesVelocity; // First pressure DOF\n        for (let colIndex = 0; colIndex < totalDOFs; colIndex++) {\n          jacobianMatrix[pDOF][colIndex] = 0;\n        }\n        jacobianMatrix[pDOF][pDOF] = 1;\n        residualVector[pDOF] = 0;\n        debugLog(\"Pinned pressure at first pressure node (p = 0) to remove null space\");\n      }\n    }\n  }\n}\n","/**\n * ════════════════════════════════════════════════════════════════\n *  FEAScript Core Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.2.0 | https://feascript.com\n *  MIT License © 2023–2026 FEAScript\n * ════════════════════════════════════════════════════════════════\n */\n\n// Internal imports\nimport {\n  prepareMesh,\n  pointInsideTriangle,\n  pointInsideQuadrilateral,\n  computeNodeNeighbors,\n  getBoundarySegments,\n} from \"../mesh/meshUtilsScript.js\";\nimport { BasisFunctions } from \"../mesh/basisFunctionsScript.js\";\nimport { initializeFEA } from \"../mesh/meshUtilsScript.js\";\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Function to create plots of the solution vector\n * @param {object} result - Object containing solution vector and mesh information\n * @param {object} model - Object containing model properties\n * @param {string} plotType - The type of plot\n * @param {string} plotDivId - The id of the div where the plot will be rendered\n */\nexport function plotSolution(model, result, plotType, plotDivId) {\n  console.time(\"plottingTime\");\n  const { nodesXCoordinates, nodesYCoordinates } = result.nodesCoordinates;\n  const solutionVector = result.solutionVector;\n  const solverConfig = model.solverConfig;\n  const meshDimension = model.meshConfig.meshDimension;\n  const meshData = prepareMesh(model.meshConfig); // Retrieve mesh connectivity details (used in splitQuadrilateral)\n\n  if (meshDimension === \"1D\" && plotType === \"line\") {\n    // Check if solutionVector is a nested array\n    let yData;\n    if (solutionVector.length > 0 && Array.isArray(solutionVector[0])) {\n      yData = solutionVector.map((arr) => arr[0]);\n    } else {\n      yData = solutionVector;\n    }\n    let xData = Array.from(nodesXCoordinates);\n\n    let lineData = {\n      x: nodesXCoordinates,\n      y: yData,\n      mode: \"lines\",\n      type: \"scatter\",\n      line: { color: \"rgb(219, 64, 82)\", width: 2 },\n      name: \"Solution\",\n    };\n\n    let maxWindowWidth = Math.min(window.innerWidth, 700);\n    let plotWidth = Math.min(maxWindowWidth, 600);\n    let plotHeight = 300;\n\n    let layout = {\n      title: `line plot - ${solverConfig}`,\n      width: plotWidth,\n      height: plotHeight,\n      xaxis: { title: \"x\" },\n      yaxis: { title: \"Solution\" },\n      margin: { l: 50, r: 50, t: 50, b: 50 },\n    };\n\n    Plotly.newPlot(plotDivId, [lineData], layout, { responsive: true });\n    console.timeEnd(\"plottingTime\");\n  } else if (meshDimension === \"2D\" && plotType === \"contour\") {\n    // Check if solutionVector is a nested array\n    let zData;\n    if (Array.isArray(solutionVector[0])) {\n      zData = solutionVector.map((val) => val[0]);\n    } else {\n      zData = solutionVector;\n    }\n\n    // Plot sizing parameters\n    let maxWindowWidth = Math.min(window.innerWidth, 700);\n    let minX = Math.min(...nodesXCoordinates);\n    let maxX = Math.max(...nodesXCoordinates);\n    let minY = Math.min(...nodesYCoordinates);\n    let maxY = Math.max(...nodesYCoordinates);\n    let lengthX = maxX - minX;\n    let lengthY = maxY - minY;\n    let aspectRatio = lengthY / lengthX;\n    let plotWidth = Math.min(maxWindowWidth, 600);\n    let plotHeight = plotWidth * aspectRatio;\n\n    // Layout properties\n    let layout = {\n      title: `${plotType} plot - ${solverConfig}`,\n      width: plotWidth,\n      height: plotHeight,\n      xaxis: { title: \"x\" },\n      yaxis: {\n        title: \"y\",\n        scaleanchor: \"x\",\n        scaleratio: 1,\n      },\n      margin: { l: 50, r: 50, t: 50, b: 50 },\n      hovermode: \"closest\",\n    };\n\n    // Create the plot\n    let contourData = {\n      x: nodesXCoordinates,\n      y: nodesYCoordinates,\n      z: zData,\n      type: \"contour\",\n      line: {\n        smoothing: 0.85,\n      },\n      contours: {\n        coloring: \"heatmap\",\n        showlabels: false,\n      },\n      //colorscale: 'Viridis',\n      colorbar: {\n        title: \"Solution\",\n      },\n      name: \"Solution Field\",\n    };\n\n    Plotly.newPlot(plotDivId, [contourData], layout, { responsive: true });\n    console.timeEnd(\"plottingTime\");\n  }\n}\n\n/**\n * Function to generate a dense visualization grid and interpolate the FEM solution on it\n * @param {object} result - Object containing solution vector and mesh information\n * @param {object} model - Object containing model properties\n * @param {string} plotType - The type of plot\n * @param {string} plotDivId - The id of the div where the plot will be rendered\n */\nexport function plotInterpolatedSolution(model, result, plotType, plotDivId) {\n  console.time(\"plottingTime\");\n  const { nodesXCoordinates, nodesYCoordinates } = result.nodesCoordinates; // TODO: Check if we should place it inside the 2D block\n  const meshDimension = model.meshConfig.meshDimension;\n  const meshData = prepareMesh(model.meshConfig); // Retrieve mesh connectivity details\n\n  // Initialize BasisFunctions once here to avoid creating it inside the loop\n  const basisFunctions = new BasisFunctions({\n    meshDimension: model.meshConfig.meshDimension,\n    elementOrder: model.meshConfig.elementOrder,\n  });\n\n  if (meshDimension === \"1D\" && plotType === \"line\") {\n    // 1D plot region\n  } else if (meshDimension === \"2D\" && plotType === \"contour\") {\n    const visNodeXCoordinates = [];\n    const visNodeYCoordinates = [];\n    const lengthX = Math.max(...nodesXCoordinates) - Math.min(...nodesXCoordinates);\n    const lengthY = Math.max(...nodesYCoordinates) - Math.min(...nodesYCoordinates);\n    const visPoinsPerUnit = 50; // Number of nodes per one length unit of the visualization grid\n    const visNodesX = Math.round(lengthX * visPoinsPerUnit); // Number of nodes along the x-axis of the visualization grid\n    const visNodesY = Math.round(lengthY * visPoinsPerUnit); // Number of nodes along the y-axis of the visualization grid\n    const deltavisX = lengthX / (visNodesX - 1);\n    const deltavisY = lengthY / (visNodesY - 1);\n    let visSolution = [];\n\n    visNodeXCoordinates[0] = Math.min(...nodesXCoordinates);\n    visNodeYCoordinates[0] = Math.min(...nodesYCoordinates);\n\n    for (let visNodeIndexY = 1; visNodeIndexY < visNodesY; visNodeIndexY++) {\n      visNodeXCoordinates[visNodeIndexY] = visNodeXCoordinates[0];\n      visNodeYCoordinates[visNodeIndexY] = visNodeYCoordinates[0] + visNodeIndexY * deltavisY;\n    }\n\n    for (let visNodeIndexX = 1; visNodeIndexX < visNodesX; visNodeIndexX++) {\n      const nnode = visNodeIndexX * visNodesY;\n      visNodeXCoordinates[nnode] = visNodeXCoordinates[0] + visNodeIndexX * deltavisX;\n      visNodeYCoordinates[nnode] = visNodeYCoordinates[0];\n\n      for (let visNodeIndexY = 1; visNodeIndexY < visNodesY; visNodeIndexY++) {\n        visNodeXCoordinates[nnode + visNodeIndexY] = visNodeXCoordinates[nnode];\n        visNodeYCoordinates[nnode + visNodeIndexY] = visNodeYCoordinates[nnode] + visNodeIndexY * deltavisY;\n      }\n    }\n\n    const visNodeCoordinates = { visNodeXCoordinates, visNodeYCoordinates };\n\n    // Initialize visSolution with null for all visualization nodes\n    visSolution = new Array(visNodesX * visNodesY).fill(null);\n\n    // Get boundary segments for ray casting\n    const boundarySegments = getBoundarySegments(meshData);\n\n    // Perform adjacency-based search to find which element contains a given point (quick search)\n    const { nodeNeighbors, neighborCount } = computeNodeNeighbors(meshData);\n    let lastParentElement = 0;\n    for (let visNodeIndex = 0; visNodeIndex < visNodesX * visNodesY; visNodeIndex++) {\n      // Ray casting check\n      if (\n        !pointInsidePolygon(\n          visNodeXCoordinates[visNodeIndex],\n          visNodeYCoordinates[visNodeIndex],\n          boundarySegments\n        )\n      ) {\n        continue;\n      }\n      let found = false;\n      for (\n        let localNodeIndex = 0;\n        localNodeIndex < meshData.nop[lastParentElement].length;\n        localNodeIndex++\n      ) {\n        let globalNodeIndex = meshData.nop[lastParentElement][localNodeIndex] - 1;\n        for (\n          let neighborElementsIndex = 0;\n          neighborElementsIndex < neighborCount[globalNodeIndex];\n          neighborElementsIndex++\n        ) {\n          let currentElement = nodeNeighbors[globalNodeIndex][neighborElementsIndex];\n          const searchResult = pointSearch(\n            model,\n            meshData,\n            result,\n            currentElement,\n            visNodeXCoordinates[visNodeIndex],\n            visNodeYCoordinates[visNodeIndex],\n            basisFunctions\n          );\n\n          if (searchResult.inside) {\n            lastParentElement = currentElement;\n            visSolution[visNodeIndex] = searchResult.value;\n            found = true;\n            break;\n          }\n        }\n        if (found) break;\n      }\n\n      // Scan all elements to find which element contains a given point (slow search)\n      if (!found) {\n        for (let currentElement = 0; currentElement < meshData.nop.length; currentElement++) {\n          const searchResult = pointSearch(\n            model,\n            meshData,\n            result,\n            currentElement,\n            visNodeXCoordinates[visNodeIndex],\n            visNodeYCoordinates[visNodeIndex],\n            basisFunctions\n          );\n\n          if (searchResult.inside) {\n            lastParentElement = currentElement;\n            visSolution[visNodeIndex] = searchResult.value;\n            found = true;\n            break;\n          }\n        }\n      }\n    }\n\n    // Plot sizing parameters\n    let maxWindowWidth = Math.min(window.innerWidth, 700);\n    let aspectRatio = lengthY / lengthX;\n    let plotWidth = Math.min(maxWindowWidth, 600);\n    let plotHeight = plotWidth * aspectRatio;\n\n    // Layout properties\n    let layout = {\n      title: `${plotType} plot (interpolated) - ${model.solverConfig}`,\n      width: plotWidth,\n      height: plotHeight,\n      xaxis: { title: \"x\" },\n      yaxis: {\n        title: \"y\",\n        scaleanchor: \"x\",\n        scaleratio: 1,\n      },\n      margin: { l: 50, r: 50, t: 50, b: 50 },\n      hovermode: \"closest\",\n    };\n\n    // Create the plot\n    let contourData = {\n      x: visNodeXCoordinates,\n      y: visNodeYCoordinates,\n      z: visSolution,\n      type: \"contour\",\n      connectgaps: false,\n      hoverongaps: false,\n      line: {\n        smoothing: 0.85,\n      },\n      contours: {\n        coloring: \"heatmap\",\n        showlabels: false,\n      },\n      //colorscale: 'Viridis',\n      colorbar: {\n        title: \"Solution\",\n      },\n      name: \"Interpolated Solution Field\",\n    };\n\n    Plotly.newPlot(plotDivId, [contourData], layout, { responsive: true });\n    console.timeEnd(\"plottingTime\");\n  }\n}\n\n/**\n * Function to search if a point is inside an element and interpolate the solution\n * @param {object} model - Object containing model properties\n * @param {object} meshData - Object containing mesh data\n * @param {object} result - Object containing solution vector and mesh information\n * @param {number} currentElement - Index of the element to check\n * @param {number} visNodeXCoordinate - X-coordinate of the point\n * @param {number} visNodeYCoordinate - Y-coordinate of the point\n * @param {object} basisFunctions - Instance of BasisFunctions class\n * @returns {object} Object containing inside boolean and interpolated value\n */\nfunction pointSearch(\n  model,\n  meshData,\n  result,\n  currentElement,\n  visNodeXCoordinate,\n  visNodeYCoordinate,\n  basisFunctions\n) {\n  const { nodesXCoordinates, nodesYCoordinates } = result.nodesCoordinates;\n  const nodesPerElement = meshData.nop[currentElement].length;\n\n  if (nodesPerElement === 4) {\n    // Linear quadrilateral element\n    let vertices = [\n      [\n        nodesXCoordinates[meshData.nop[currentElement][0] - 1],\n        nodesYCoordinates[meshData.nop[currentElement][0] - 1],\n      ],\n      [\n        nodesXCoordinates[meshData.nop[currentElement][1] - 1],\n        nodesYCoordinates[meshData.nop[currentElement][1] - 1],\n      ],\n      [\n        nodesXCoordinates[meshData.nop[currentElement][2] - 1],\n        nodesYCoordinates[meshData.nop[currentElement][2] - 1],\n      ],\n      [\n        nodesXCoordinates[meshData.nop[currentElement][3] - 1],\n        nodesYCoordinates[meshData.nop[currentElement][3] - 1],\n      ],\n    ];\n    const pointCheck = pointInsideQuadrilateral(visNodeXCoordinate, visNodeYCoordinate, vertices);\n    if (pointCheck.inside) {\n      return {\n        inside: true,\n        value: solutionInterpolation(\n          model,\n          meshData,\n          result,\n          currentElement,\n          pointCheck.ksi,\n          pointCheck.eta,\n          basisFunctions\n        ),\n      };\n    }\n  } else if (nodesPerElement === 9) {\n    // Quadratic quadrilateral element\n    let vertices = [\n      [\n        nodesXCoordinates[meshData.nop[currentElement][0] - 1],\n        nodesYCoordinates[meshData.nop[currentElement][0] - 1],\n      ],\n      [\n        nodesXCoordinates[meshData.nop[currentElement][2] - 1],\n        nodesYCoordinates[meshData.nop[currentElement][2] - 1],\n      ],\n      [\n        nodesXCoordinates[meshData.nop[currentElement][6] - 1],\n        nodesYCoordinates[meshData.nop[currentElement][6] - 1],\n      ],\n      [\n        nodesXCoordinates[meshData.nop[currentElement][8] - 1],\n        nodesYCoordinates[meshData.nop[currentElement][8] - 1],\n      ],\n    ];\n    const pointCheck = pointInsideQuadrilateral(visNodeXCoordinate, visNodeYCoordinate, vertices);\n    if (pointCheck.inside) {\n      return {\n        inside: true,\n        value: solutionInterpolation(\n          model,\n          meshData,\n          result,\n          currentElement,\n          pointCheck.ksi,\n          pointCheck.eta,\n          basisFunctions\n        ),\n      };\n    }\n  } // TODO: Add also triangular element cases\n  return { inside: false, value: null };\n}\n\n/**\n * Function to interpolate the solution at a specific point (ksi, eta) within an element\n * @param {object} model - Object containing model properties\n * @param {object} meshData - Object containing mesh data\n * @param {object} result - Object containing solution vector and mesh information\n * @param {number} elementIndex - Index of the element containing the point\n * @param {number} ksi - First natural coordinate (ksi)\n * @param {number} eta - Second natural coordinate (eta)\n * @param {object} basisFunctions - Instance of BasisFunctions class\n * @returns {number} Interpolated solution value\n */\nfunction solutionInterpolation(model, meshData, result, elementIndex, ksi, eta, basisFunctions) {\n  // Initialize FEA components\n  const solutionVector = result.solutionVector;\n  const nodesPerElement = meshData.nop[elementIndex].length;\n\n  // Get basis functions for the current point\n  const basisFunctionsAndDerivatives = basisFunctions.getBasisFunctions(ksi, eta);\n  let basisFunction = basisFunctionsAndDerivatives.basisFunction;\n\n  // Check if solutionVector is a nested array\n  let zData;\n  if (Array.isArray(solutionVector[0])) {\n    zData = solutionVector.map((val) => val[0]);\n  } else {\n    zData = solutionVector;\n  }\n\n  // Interpolate solution\n  let solutionInterpolationValue = 0;\n  for (let localNodeIndex = 0; localNodeIndex < nodesPerElement; localNodeIndex++) {\n    solutionInterpolationValue +=\n      zData[meshData.nop[elementIndex][localNodeIndex] - 1] * basisFunction[localNodeIndex];\n  }\n\n  return solutionInterpolationValue;\n}\n\n/**\n * Function to check if a point is inside a polygon using ray casting algorithm\n * @param {number} x - X-coordinate of the point\n * @param {number} y - Y-coordinate of the point\n * @param {array} segments - Array of boundary segments\n * @returns {boolean} True if the point is inside the polygon\n */\nfunction pointInsidePolygon(x, y, segments) {\n  let inside = false;\n  for (let i = 0; i < segments.length; i++) {\n    const [[x1, y1], [x2, y2]] = segments[i];\n    const intersect = y1 > y !== y2 > y && x < ((x2 - x1) * (y - y1)) / (y2 - y1) + x1;\n    if (intersect) inside = !inside;\n  }\n  return inside;\n}\n","/**\n * ════════════════════════════════════════════════════════════════\n *  FEAScript Core Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.2.0 | https://feascript.com\n *  MIT License © 2023–2026 FEAScript\n * ════════════════════════════════════════════════════════════════\n */\n\n// Internal imports\nimport { newtonRaphson } from \"./methods/newtonRaphsonScript.js\";\nimport { solveLinearSystem } from \"./methods/linearSystemSolverScript.js\";\nimport { solveLinearSystemAsync } from \"./methods/linearSystemSolverScript.js\";\nimport { prepareMesh } from \"./mesh/meshUtilsScript.js\";\nimport { assembleFrontPropagationMat } from \"./models/frontPropagationScript.js\";\nimport { assembleGeneralFormPDEMat, assembleGeneralFormPDEFront } from \"./models/generalFormPDEScript.js\";\nimport { assembleHeatConductionMat, assembleHeatConductionFront } from \"./models/heatConductionScript.js\";\nimport { assembleStokesMatrix } from \"./models/stokesScript.js\";\nimport { runFrontalSolver } from \"./methods/frontalSolverScript.js\";\nimport { basicLog, debugLog, warnLog, errorLog } from \"./utilities/loggingScript.js\";\n\n/**\n * Class to implement finite element analysis in JavaScript\n * @param {string} solverConfig - Parameter specifying the type of solver\n * @param {object} meshConfig - Object containing computational mesh details\n * @param {object} boundaryConditions - Object containing boundary conditions for the finite element analysis\n * @returns {object} An object containifng the solution vector and mesh information\n */\nexport class FEAScriptModel {\n  constructor() {\n    this.solverConfig = null;\n    this.meshConfig = {};\n    this.boundaryConditions = {};\n    this.solverMethod = \"lusolve\"; // Default solver method\n    this.coefficientFunctions = null; // Add storage for coefficient functions\n    warnLog(\n      \"FEAScript is provided “as is” without any warranty. The authors are not responsible for any damages or losses that may result from using the software. See the license for more details: https://github.com/FEAScript/FEAScript-core/blob/main/LICENSE\"\n    );\n    basicLog(\"FEAScriptModel instance created\");\n  }\n\n  /**\n   * Method to set the solver configuration\n   * @param {string} solverConfig - Parameter specifying the type of solver\n   * @param {object} [options] - Optional additional configuration\n   */\n  setSolverConfig(solverConfig, options = {}) {\n    this.solverConfig = solverConfig;\n    warnLog(\"setSolverConfig() is deprecated. Use setModelConfig() instead\");\n\n    // Store coefficient functions if provided\n    if (options?.coefficientFunctions !== undefined) {\n      this.coefficientFunctions = options.coefficientFunctions;\n      debugLog(\"coefficientFunctions set\");\n    }\n    // Only update if a value is provided\n    if (options?.maxIterations !== undefined) {\n      this.maxIterations = options.maxIterations;\n      debugLog(`maxIterations set to ${this.maxIterations}`);\n    }\n    if (options?.tolerance !== undefined) {\n      this.tolerance = options.tolerance;\n      debugLog(`tolerance set to ${this.tolerance}`);\n    }\n\n    debugLog(`solverConfig set to ${solverConfig}`);\n  }\n\n  // Alias modelConfig to solverConfig (solverConfig is deprecated, use setModelConfig instead)\n  setModelConfig(modelConfig, options = {}) {\n    this.setSolverConfig(modelConfig, options);\n  }\n\n  setMeshConfig(meshConfig) {\n    this.meshConfig = meshConfig;\n    debugLog(`meshConfig set with dimensions: ${meshConfig.meshDimension}`);\n  }\n\n  addBoundaryCondition(boundaryKey, condition) {\n    this.boundaryConditions[boundaryKey] = condition;\n    debugLog(`boundaryConditions added for boundary: ${boundaryKey}, type: ${condition[0]}`);\n  }\n\n  setSolverMethod(solverMethod) {\n    this.solverMethod = solverMethod;\n    debugLog(`solverMethod set to: ${solverMethod}`);\n  }\n\n  /**\n   * Method to solve the finite element problem synchronously\n   * @param {object} [options] - Additional parameters for the solver, such as `maxIterations` and `tolerance`\n   * @returns {object} An object containing the solution vector and mesh information\n   */\n  solve(options = {}) {\n    if (!this.solverConfig || !this.meshConfig || !this.boundaryConditions) {\n      errorLog(\"solverConfig, meshConfig and boundaryConditions must be set before solving\");\n    }\n    /**\n     * For consistency across both linear and nonlinear formulations,\n     * we always refer to the assembled right-hand side vector as \n     * `residualVector` and the assembled system matrix as `jacobianMatrix`.\n     *\n     * In linear problems `jacobianMatrix` is equivalent to the\n     * classic stiffness/conductivity matrix and `residualVector`\n     * corresponds to the traditional load (RHS) vector.\n     */\n\n    let jacobianMatrix = [];\n    let residualVector = [];\n    let solutionVector = [];\n    let initialSolution = [];\n\n    // Prepare the mesh\n    basicLog(\"Preparing mesh...\");\n    const meshData = prepareMesh(this.meshConfig);\n    basicLog(\"Mesh preparation completed\");\n\n    // Extract node coordinates and nodal numbering from meshData\n    const nodesCoordinates = {\n      nodesXCoordinates: meshData.nodesXCoordinates,\n      nodesYCoordinates: meshData.nodesYCoordinates,\n    };\n\n    // Select and execute the appropriate solver based on solverConfig\n    basicLog(\"Beginning solving process...\");\n    console.time(\"totalSolvingTime\");\n    basicLog(`Using solver ${this.solverConfig}`);\n    if (this.solverConfig === \"heatConductionScript\") {\n      // Check if using frontal solver\n      if (this.solverMethod === \"frontal\") {\n        const frontalResult = runFrontalSolver(\n          assembleHeatConductionFront,\n          meshData,\n          this.boundaryConditions\n        );\n        solutionVector = frontalResult.solutionVector;\n      } else {\n        // Use regular linear solver methods\n        ({ jacobianMatrix, residualVector } = assembleHeatConductionMat(meshData, this.boundaryConditions));\n        const linearSystemResult = solveLinearSystem(this.solverMethod, jacobianMatrix, residualVector, {\n          maxIterations: options.maxIterations ?? this.maxIterations,\n          tolerance: options.tolerance ?? this.tolerance,\n        });\n        solutionVector = linearSystemResult.solutionVector;\n      }\n    } else if (this.solverConfig === \"frontPropagationScript\") {\n      // Initialize eikonalActivationFlag\n      let eikonalActivationFlag = 0; // TODO: make activationFlag a generic variable (not only for eikonal)\n      const eikonalExteralIterations = 5; // Number of incremental steps for the eikonal equation\n\n      // Create context object with all necessary properties\n      const context = {\n        meshData: meshData,\n        boundaryConditions: this.boundaryConditions,\n        eikonalActivationFlag: eikonalActivationFlag,\n        solverMethod: this.solverMethod,\n        initialSolution,\n        // TODO: Consider using different maxIterations/tolerance for Newton-Raphson and linear solver\n        maxIterations: options.maxIterations ?? this.maxIterations,\n        tolerance: options.tolerance ?? this.tolerance,\n      };\n\n      while (eikonalActivationFlag <= 1) {\n        // Update the context object with current eikonalActivationFlag\n        context.eikonalActivationFlag = eikonalActivationFlag;\n\n        // Pass the previous solution as initial guess\n        if (solutionVector.length > 0) {\n          context.initialSolution = [...solutionVector];\n        }\n\n        // Solve the assembled non-linear system\n        const newtonRaphsonResult = newtonRaphson(assembleFrontPropagationMat, context);\n\n        // Extract results\n        jacobianMatrix = newtonRaphsonResult.jacobianMatrix;\n        residualVector = newtonRaphsonResult.residualVector;\n        solutionVector = newtonRaphsonResult.solutionVector;\n\n        // Increment eikonalActivationFlag for next iteration\n        eikonalActivationFlag += 1 / eikonalExteralIterations;\n      }\n    } else if (this.solverConfig === \"generalFormPDEScript\") {\n      // Check if using frontal solver\n      if (this.solverMethod === \"frontal\") {\n        errorLog(\n          \"Frontal solver is not yet supported for generalFormPDEScript. Please use 'lusolve' or 'jacobi'.\"\n        );\n      } else {\n        // Use regular linear solver methods\n        ({ jacobianMatrix, residualVector } = assembleGeneralFormPDEMat(\n          meshData,\n          this.boundaryConditions,\n          this.coefficientFunctions\n        ));\n\n        const linearSystemResult = solveLinearSystem(this.solverMethod, jacobianMatrix, residualVector, {\n          maxIterations: options.maxIterations ?? this.maxIterations,\n          tolerance: options.tolerance ?? this.tolerance,\n        });\n        solutionVector = linearSystemResult.solutionVector;\n      }\n    } else if (this.solverConfig === \"stokesScript\") {\n      // Use regular linear solver methods for steady Stokes flow\n      const stokesResult = assembleStokesMatrix(meshData, this.boundaryConditions);\n      jacobianMatrix = stokesResult.jacobianMatrix;\n      residualVector = stokesResult.residualVector;\n\n      const linearSystemResult = solveLinearSystem(this.solverMethod, jacobianMatrix, residualVector, {\n        maxIterations: options.maxIterations ?? this.maxIterations,\n        tolerance: options.tolerance ?? this.tolerance,\n      });\n      solutionVector = linearSystemResult.solutionVector;\n\n      // Store Stokes-specific metadata for solution extraction\n      this._stokesMetadata = {\n        totalNodesVelocity: stokesResult.totalNodesVelocity,\n        totalNodesPressure: stokesResult.totalNodesPressure,\n        pressureNodeIndices: stokesResult.pressureNodeIndices,\n      };\n    }\n    console.timeEnd(\"totalSolvingTime\");\n    basicLog(\"Solving process completed\");\n\n    return { solutionVector, nodesCoordinates };\n  }\n\n  /**\n   * Method to solve the finite element problem asynchronously\n   * @param {object} computeEngine - The compute engine to use for the asynchronous solver (e.g., a worker or a WebGPU context)\n   * @param {object} [options] - Additional parameters for the solver, such as `maxIterations` and `tolerance`\n   * @returns {Promise<object>} A promise that resolves to an object containing the solution vector and the coordinates of the mesh nodes\n   */\n  async solveAsync(computeEngine, options = {}) {\n    if (!this.solverConfig || !this.meshConfig || !this.boundaryConditions) {\n      errorLog(\"Solver config, mesh config, and boundary conditions must be set before solving.\");\n    }\n\n    let jacobianMatrix = [];\n    let residualVector = [];\n    let solutionVector = [];\n\n    basicLog(\"Preparing mesh...\");\n    const meshData = prepareMesh(this.meshConfig);\n    basicLog(\"Mesh preparation completed\");\n    const nodesCoordinates = {\n      nodesXCoordinates: meshData.nodesXCoordinates,\n      nodesYCoordinates: meshData.nodesYCoordinates,\n    };\n\n    basicLog(\"Beginning solving process...\");\n    console.time(\"totalSolvingTime\");\n\n    basicLog(`Using solver: ${this.solverConfig}`);\n    if (this.solverConfig === \"heatConductionScript\") {\n      ({ jacobianMatrix, residualVector } = assembleHeatConductionMat(meshData, this.boundaryConditions));\n\n      if (this.solverMethod === \"jacobi-gpu\") {\n        const { solutionVector: x } = await solveLinearSystemAsync(\n          \"jacobi-gpu\",\n          jacobianMatrix,\n          residualVector,\n          {\n            computeEngine,\n            maxIterations: options.maxIterations ?? this.maxIterations,\n            tolerance: options.tolerance ?? this.tolerance,\n          }\n        );\n        solutionVector = x;\n      } else {\n        // Any other async solver\n      }\n    }\n    console.timeEnd(\"totalSolvingTime\");\n    basicLog(\"Solving process completed\");\n\n    return { solutionVector, nodesCoordinates };\n  }\n}\n","/**\n * ════════════════════════════════════════════════════════════════\n *  FEAScript Core Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.2.0 | https://feascript.com\n *  MIT License © 2023–2026 FEAScript\n * ════════════════════════════════════════════════════════════════\n */\n\n// Internal imports\nimport { initializeFEA, performIsoparametricMapping1D } from \"../mesh/meshUtilsScript.js\";\nimport { GenericBoundaryConditions } from \"./genericBoundaryConditionsScript.js\";\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Function to assemble the Jacobian matrix and residuals vector for the general form PDE model\n * @param {object} meshData - Object containing prepared mesh data\n * @param {object} boundaryConditions - Object containing boundary conditions\n * @param {object} coefficientFunctions - Functions A(x), B(x), C(x), D(x) for the PDE\n * @returns {object} An object containing:\n *  - jacobianMatrix: The assembled Jacobian matrix\n *  - residualVector: The assembled residual vector\n */\nexport function assembleGeneralFormPDEMat(meshData, boundaryConditions, coefficientFunctions) {\n  basicLog(\"Starting general form PDE matrix assembly...\");\n\n  // Extract mesh data\n  const {\n    nodesXCoordinates,\n    nodesYCoordinates,\n    nop,\n    boundaryElements,\n    totalElements,\n    meshDimension,\n    elementOrder,\n  } = meshData;\n\n  // Extract coefficient functions\n  const { A, B, C, D } = coefficientFunctions;\n\n  // Initialize FEA components\n  const FEAData = initializeFEA(meshData);\n  const {\n    residualVector,\n    jacobianMatrix,\n    localToGlobalMap,\n    basisFunctions,\n    gaussPoints,\n    gaussWeights,\n    nodesPerElement,\n  } = FEAData;\n\n  if (meshDimension === \"1D\") {\n    // 1D general form PDE\n\n    // Matrix assembly\n    for (let elementIndex = 0; elementIndex < totalElements; elementIndex++) {\n      // Map local element nodes to global mesh nodes\n      for (let localNodeIndex = 0; localNodeIndex < nodesPerElement; localNodeIndex++) {\n        // Convert to 0-based indexing\n        localToGlobalMap[localNodeIndex] = Math.abs(nop[elementIndex][localNodeIndex]) - 1;\n      }\n\n      // Loop over Gauss points\n      for (let gaussPointIndex = 0; gaussPointIndex < gaussPoints.length; gaussPointIndex++) {\n        // Get basis functions for the current Gauss point\n        const { basisFunction, basisFunctionDerivKsi } = basisFunctions.getBasisFunctions(\n          gaussPoints[gaussPointIndex]\n        );\n\n        // Perform isoparametric mapping\n        const { detJacobian, basisFunctionDerivX } = performIsoparametricMapping1D({\n          basisFunction,\n          basisFunctionDerivKsi,\n          nodesXCoordinates,\n          localToGlobalMap,\n          nodesPerElement,\n        });\n\n        // Calculate the physical coordinate for this Gauss point\n        let xCoord = 0;\n        for (let i = 0; i < nodesPerElement; i++) {\n          xCoord += nodesXCoordinates[localToGlobalMap[i]] * basisFunction[i];\n        }\n\n        // Evaluate coefficient functions at this physical coordinate\n        const a = A(xCoord);\n        const b = B(xCoord);\n        const c = C(xCoord);\n        const d = D(xCoord);\n\n        // Computation of Galerkin's residuals and local Jacobian matrix\n        for (let localNodeIndex1 = 0; localNodeIndex1 < nodesPerElement; localNodeIndex1++) {\n          const globalNodeIndex1 = localToGlobalMap[localNodeIndex1];\n\n          // Source term contribution to residual vector\n          residualVector[globalNodeIndex1] -=\n            gaussWeights[gaussPointIndex] * detJacobian * d * basisFunction[localNodeIndex1];\n\n          for (let localNodeIndex2 = 0; localNodeIndex2 < nodesPerElement; localNodeIndex2++) {\n            const globalNodeIndex2 = localToGlobalMap[localNodeIndex2];\n\n            // Diffusion term\n            jacobianMatrix[globalNodeIndex1][globalNodeIndex2] +=\n              gaussWeights[gaussPointIndex] *\n              detJacobian *\n              a *\n              basisFunctionDerivX[localNodeIndex1] *\n              basisFunctionDerivX[localNodeIndex2];\n\n            // Advection term\n            jacobianMatrix[globalNodeIndex1][globalNodeIndex2] -=\n              gaussWeights[gaussPointIndex] *\n              detJacobian *\n              b *\n              basisFunctionDerivX[localNodeIndex2] *\n              basisFunction[localNodeIndex1];\n\n            // Reaction term\n            jacobianMatrix[globalNodeIndex1][globalNodeIndex2] -=\n              gaussWeights[gaussPointIndex] *\n              detJacobian *\n              c *\n              basisFunction[localNodeIndex1] *\n              basisFunction[localNodeIndex2];\n          }\n        }\n      }\n    }\n  } else if (meshDimension === \"2D\") {\n    errorLog(\"2D general form PDE is not yet supported in assembleGeneralFormPDEMat.\");\n    // 2D general form PDE - empty for now\n  }\n\n  // Apply boundary conditions\n  const genericBoundaryConditions = new GenericBoundaryConditions(\n    boundaryConditions,\n    boundaryElements,\n    nop,\n    meshDimension,\n    elementOrder\n  );\n\n  // Apply Dirichlet boundary conditions only\n  genericBoundaryConditions.imposeDirichletBoundaryConditions(residualVector, jacobianMatrix);\n\n  basicLog(\"General form PDE matrix assembly completed\");\n\n  return {\n    jacobianMatrix,\n    residualVector,\n  };\n}\n\n/**\n * Function to assemble the frontal solver matrix for the general form PDE model\n * @param {object} data - Object containing element data for the frontal solver\n * @returns {object} An object containing local Jacobian matrix and residual vector\n */\nexport function assembleGeneralFormPDEFront({\n  elementIndex,\n  nop,\n  meshData,\n  basisFunctions,\n  FEAData,\n  coefficientFunctions,\n}) {\n  // Extract numerical integration parameters and mesh coordinates\n  const { gaussPoints, gaussWeights, nodesPerElement } = FEAData;\n  const { nodesXCoordinates, nodesYCoordinates, meshDimension } = meshData;\n  const { A, B, C, D } = coefficientFunctions;\n\n  // Initialize local Jacobian matrix and local residual vector\n  const localJacobianMatrix = Array(nodesPerElement)\n    .fill()\n    .map(() => Array(nodesPerElement).fill(0));\n  const localResidualVector = Array(nodesPerElement).fill(0);\n\n  // Build the mapping from local node indices to global node indices\n  const ngl = Array(nodesPerElement);\n  const localToGlobalMap = Array(nodesPerElement);\n  for (let localNodeIndex = 0; localNodeIndex < nodesPerElement; localNodeIndex++) {\n    ngl[localNodeIndex] = Math.abs(nop[elementIndex][localNodeIndex]);\n    localToGlobalMap[localNodeIndex] = Math.abs(nop[elementIndex][localNodeIndex]) - 1;\n  }\n\n  if (meshDimension === \"1D\") {\n    // 1D general form PDE\n\n    // Loop over Gauss points\n    for (let gaussPointIndex = 0; gaussPointIndex < gaussPoints.length; gaussPointIndex++) {\n      // Get basis functions for the current Gauss point\n      const { basisFunction, basisFunctionDerivKsi } = basisFunctions.getBasisFunctions(\n        gaussPoints[gaussPointIndex]\n      );\n\n      // Perform isoparametric mapping\n      const { detJacobian, basisFunctionDerivX } = performIsoparametricMapping1D({\n        basisFunction,\n        basisFunctionDerivKsi,\n        nodesXCoordinates,\n        localToGlobalMap,\n        nodesPerElement,\n      });\n\n      // Calculate the physical coordinate for this Gauss point\n      let xCoord = 0;\n      for (let i = 0; i < nodesPerElement; i++) {\n        xCoord += nodesXCoordinates[localToGlobalMap[i]] * basisFunction[i];\n      }\n\n      // Evaluate coefficient functions at this physical coordinate\n      const a = A(xCoord);\n      const b = B(xCoord);\n      const c = C(xCoord);\n      const d = D(xCoord);\n\n      // Computation of local Jacobian matrix and residual vector\n      for (let localNodeIndex1 = 0; localNodeIndex1 < nodesPerElement; localNodeIndex1++) {\n        // Source term contribution to local residual vector\n        localResidualVector[localNodeIndex1] -=\n          gaussWeights[gaussPointIndex] * detJacobian * d * basisFunction[localNodeIndex1];\n\n        for (let localNodeIndex2 = 0; localNodeIndex2 < nodesPerElement; localNodeIndex2++) {\n          // Diffusion term\n          localJacobianMatrix[localNodeIndex1][localNodeIndex2] +=\n            gaussWeights[gaussPointIndex] *\n            detJacobian *\n            a *\n            basisFunctionDerivX[localNodeIndex1] *\n            basisFunctionDerivX[localNodeIndex2];\n\n          // Advection term\n          localJacobianMatrix[localNodeIndex1][localNodeIndex2] -=\n            gaussWeights[gaussPointIndex] *\n            detJacobian *\n            b *\n            basisFunctionDerivX[localNodeIndex2] *\n            basisFunction[localNodeIndex1];\n\n          // Reaction term\n          localJacobianMatrix[localNodeIndex1][localNodeIndex2] -=\n            gaussWeights[gaussPointIndex] *\n            detJacobian *\n            c *\n            basisFunction[localNodeIndex1] *\n            basisFunction[localNodeIndex2];\n        }\n      }\n    }\n  } else if (meshDimension === \"2D\") {\n    errorLog(\"2D general form PDE is not yet supported in assembleGeneralFormPDEFront.\");\n    // 2D general form PDE - empty for now\n  }\n\n  return {\n    localJacobianMatrix,\n    localResidualVector,\n    ngl,\n  };\n}\n","/**\n * ════════════════════════════════════════════════════════════════\n *  FEAScript Core Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.2.0 | https://feascript.com\n *  MIT License © 2023–2026 FEAScript\n * ════════════════════════════════════════════════════════════════\n */\n\n// Internal imports\nimport { performIsoparametricMapping2D } from \"../mesh/meshUtilsScript.js\";\nimport { BasisFunctions } from \"../mesh/basisFunctionsScript.js\";\nimport { NumericalIntegration } from \"../methods/numericalIntegrationScript.js\";\nimport { FlowBoundaryConditions } from \"./flowBoundaryConditions.js\";\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Function to assemble the Jacobian matrix and residual vector for the steady Stokes flow model\n * using Taylor-Hood (Q2-Q1) mixed finite elements\n *\n * DOF ordering in the assembled system:\n *   [u_0 … u_{N_2−1}, v_0 … v_{N_2−1}, p_0 … p_{N_1−1}]\n * where N_2 = total velocity nodes (Q2) and N_1 = total pressure nodes (Q1)\n *\n * @param {object} meshData - Object containing prepared mesh data (must use quadratic elements)\n * @param {object} boundaryConditions - Object containing boundary conditions for the finite element analysis\n * @returns {object} An object containing:\n *  - jacobianMatrix: The assembled Jacobian matrix\n *  - residualVector: The assembled residual vector\n *  - totalNodesVelocity: Number of velocity nodes (Q2)\n *  - totalNodesPressure: Number of pressure nodes (Q1)\n *  - pressureNodeIndices: Array mapping pressure DOF index to global Q2 node index\n *\n * For consistency across both linear and nonlinear formulations,\n * this project always refers to the assembled right-hand side vector\n * as `residualVector` and the assembled system matrix as `jacobianMatrix`.\n *\n * In linear problems `jacobianMatrix` is equivalent to the\n * classic stiffness/conductivity matrix and `residualVector`\n * corresponds to the traditional load (RHS) vector.\n */\nexport function assembleStokesMatrix(meshData, boundaryConditions) {\n  basicLog(\"Starting Stokes flow matrix assembly...\");\n\n  // Extract mesh data\n  const {\n    nodesXCoordinates,\n    nodesYCoordinates,\n    nop,\n    boundaryElements,\n    totalElements,\n    totalNodes,\n    meshDimension,\n    elementOrder,\n  } = meshData;\n\n  // Validate mesh configuration\n  if (meshDimension !== \"2D\") {\n    errorLog(\"Stokes solver requires a 2D mesh\");\n  }\n  if (elementOrder !== \"quadratic\") {\n    errorLog(\"Stokes solver requires quadratic elements for Taylor-Hood (Q2-Q1) formulation\");\n  }\n\n  // Number of velocity nodes (Q2) is the total number of nodes in the quadratic mesh\n  const totalNodesVelocity = totalNodes;\n  const nodesPerVelocityElement = 9; // Q2 element has 9 nodes\n  const nodesPerPressureElement = 4; // Q1 element has 4 nodes\n\n  // Local Q2 indices that correspond to Q1 corner nodes\n  // Q2 local numbering:\n  //   2 - 5 - 8\n  //   |       |\n  //   1   4   7\n  //   |       |\n  //   0 - 3 - 6\n  // Corner nodes (Q1): 0, 2, 6, 8\n  const cornerLocalIndices = [0, 2, 6, 8];\n\n  // Build pressure node mapping from Q2 corner nodes\n  const q2ToPressureMap = new Map();\n  const pressureNodeIndices = []; // Maps pressure DOF index to global Q2 node index\n  let pressureNodeCount = 0;\n\n  for (let elementIndex = 0; elementIndex < totalElements; elementIndex++) {\n    for (let cornerIndex = 0; cornerIndex < cornerLocalIndices.length; cornerIndex++) {\n      const globalQ2Node = nop[elementIndex][cornerLocalIndices[cornerIndex]] - 1; // Convert to 0-based\n      if (!q2ToPressureMap.has(globalQ2Node)) {\n        q2ToPressureMap.set(globalQ2Node, pressureNodeCount);\n        pressureNodeIndices.push(globalQ2Node);\n        pressureNodeCount++;\n      }\n    }\n  }\n  const totalNodesPressure = pressureNodeCount;\n  const totalDOFs = 2 * totalNodesVelocity + totalNodesPressure;\n\n  debugLog(\n    `Stokes DOFs: ${totalNodesVelocity} velocity nodes (Q2), ${totalNodesPressure} pressure nodes (Q1), ${totalDOFs} total DOFs`,\n  );\n\n  // Initialize Jacobian matrix and residual vector\n  let residualVector = [];\n  let jacobianMatrix = [];\n  for (let nodeIndex = 0; nodeIndex < totalDOFs; nodeIndex++) {\n    residualVector[nodeIndex] = 0;\n    jacobianMatrix.push([]);\n    for (let colIndex = 0; colIndex < totalDOFs; colIndex++) {\n      jacobianMatrix[nodeIndex][colIndex] = 0;\n    }\n  }\n\n  // Initialize basis functions for velocity (Q2) and pressure (Q1)\n  const velocityBasisFunctions = new BasisFunctions({\n    meshDimension: \"2D\",\n    elementOrder: \"quadratic\",\n  });\n  const pressureBasisFunctions = new BasisFunctions({\n    meshDimension: \"2D\",\n    elementOrder: \"linear\",\n  });\n\n  // Initialize numerical integration (use quadratic-order Gauss rule)\n  const numericalIntegration = new NumericalIntegration({\n    meshDimension: \"2D\",\n    elementOrder: \"quadratic\",\n  });\n  let gaussPointsAndWeights = numericalIntegration.getGaussPointsAndWeights();\n  let gaussPoints = gaussPointsAndWeights.gaussPoints;\n  let gaussWeights = gaussPointsAndWeights.gaussWeights;\n\n  // Viscosity coefficient\n  const mu = 1.0;\n\n  // Matrix assembly\n  for (let elementIndex = 0; elementIndex < totalElements; elementIndex++) {\n    // Build local-to-global mapping for velocity nodes (Q2)\n    let velLocalToGlobalMap = [];\n    for (let localNodeIndex = 0; localNodeIndex < nodesPerVelocityElement; localNodeIndex++) {\n      // Subtract 1 from nop in order to start numbering from 0\n      velLocalToGlobalMap[localNodeIndex] = nop[elementIndex][localNodeIndex] - 1;\n    }\n\n    // Build local-to-global mapping for pressure nodes (Q1)\n    let presLocalToGlobalMap = [];\n    for (let localNodeIndex = 0; localNodeIndex < nodesPerPressureElement; localNodeIndex++) {\n      const globalQ2Node = nop[elementIndex][cornerLocalIndices[localNodeIndex]] - 1;\n      presLocalToGlobalMap[localNodeIndex] = q2ToPressureMap.get(globalQ2Node);\n    }\n\n    // Loop over Gauss points\n    for (let gaussPointIndex1 = 0; gaussPointIndex1 < gaussPoints.length; gaussPointIndex1++) {\n      for (let gaussPointIndex2 = 0; gaussPointIndex2 < gaussPoints.length; gaussPointIndex2++) {\n        // Get velocity (Q2) basis functions for the current Gauss point\n        const velocityBasisFunctionsAndDerivatives = velocityBasisFunctions.getBasisFunctions(\n          gaussPoints[gaussPointIndex1],\n          gaussPoints[gaussPointIndex2],\n        );\n\n        // Get pressure (Q1) basis functions for the current Gauss point\n        const pressureBasisFunctionsAndDerivatives = pressureBasisFunctions.getBasisFunctions(\n          gaussPoints[gaussPointIndex1],\n          gaussPoints[gaussPointIndex2],\n        );\n\n        // Perform isoparametric mapping using Q2 velocity basis functions\n        const mappingResult = performIsoparametricMapping2D({\n          basisFunction: velocityBasisFunctionsAndDerivatives.basisFunction,\n          basisFunctionDerivKsi: velocityBasisFunctionsAndDerivatives.basisFunctionDerivKsi,\n          basisFunctionDerivEta: velocityBasisFunctionsAndDerivatives.basisFunctionDerivEta,\n          nodesXCoordinates,\n          nodesYCoordinates,\n          localToGlobalMap: velLocalToGlobalMap,\n          nodesPerElement: nodesPerVelocityElement,\n        });\n\n        // Extract mapping results\n        const { detJacobian, basisFunctionDerivX, basisFunctionDerivY } = mappingResult;\n\n        // Gauss integration weight factor\n        const weightFactor = gaussWeights[gaussPointIndex1] * gaussWeights[gaussPointIndex2] * detJacobian;\n\n        // Assemble viscous stiffness terms (K block)\n        for (let localNodeIndex1 = 0; localNodeIndex1 < nodesPerVelocityElement; localNodeIndex1++) {\n          let globalNode1 = velLocalToGlobalMap[localNodeIndex1];\n          let uDOF1 = globalNode1; // u-velocity DOF\n          let vDOF1 = totalNodesVelocity + globalNode1; // v-velocity DOF\n\n          for (let localNodeIndex2 = 0; localNodeIndex2 < nodesPerVelocityElement; localNodeIndex2++) {\n            let globalNode2 = velLocalToGlobalMap[localNodeIndex2];\n            let uDOF2 = globalNode2; // u-velocity DOF\n            let vDOF2 = totalNodesVelocity + globalNode2; // v-velocity DOF\n\n            // Viscous stiffness\n            let viscousContribution =\n              -weightFactor *\n              mu *\n              (basisFunctionDerivX[localNodeIndex1] * basisFunctionDerivX[localNodeIndex2] +\n                basisFunctionDerivY[localNodeIndex1] * basisFunctionDerivY[localNodeIndex2]);\n\n            // K appears in both u-u and v-v blocks\n            jacobianMatrix[uDOF1][uDOF2] += viscousContribution;\n            jacobianMatrix[vDOF1][vDOF2] += viscousContribution;\n          }\n\n          // Assemble pressure-velocity coupling terms\n          for (let localPresIndex = 0; localPresIndex < nodesPerPressureElement; localPresIndex++) {\n            let pDOF = 2 * totalNodesVelocity + presLocalToGlobalMap[localPresIndex];\n\n            let bxContribution =\n              weightFactor *\n              pressureBasisFunctionsAndDerivatives.basisFunction[localPresIndex] *\n              basisFunctionDerivX[localNodeIndex1];\n\n            let byContribution =\n              weightFactor *\n              pressureBasisFunctionsAndDerivatives.basisFunction[localPresIndex] *\n              basisFunctionDerivY[localNodeIndex1];\n\n            // Pressure gradient in x-momentum\n            jacobianMatrix[uDOF1][pDOF] += bxContribution;\n\n            // Pressure gradient in y-momentum\n            jacobianMatrix[vDOF1][pDOF] += byContribution;\n\n            // Continuity equation\n            jacobianMatrix[pDOF][uDOF1] += -bxContribution;\n            jacobianMatrix[pDOF][vDOF1] += -byContribution;\n          }\n        }\n      }\n    }\n  }\n\n  // Apply boundary conditions\n  const flowBoundaryConditions = new FlowBoundaryConditions(\n    boundaryConditions,\n    boundaryElements,\n    nop,\n    meshDimension,\n    elementOrder,\n    totalNodesVelocity,\n    totalNodesPressure,\n    q2ToPressureMap,\n  );\n\n  flowBoundaryConditions.imposeDirichletBoundaryConditions(residualVector, jacobianMatrix);\n  basicLog(\"Stokes flow matrix assembly completed\");\n\n  return {\n    jacobianMatrix,\n    residualVector,\n    totalNodesVelocity,\n    totalNodesPressure,\n    pressureNodeIndices,\n  };\n}\n","/**\n * ════════════════════════════════════════════════════════════════\n *  FEAScript Core Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.2.0 | https://feascript.com\n *  MIT License © 2023–2026 FEAScript\n * ════════════════════════════════════════════════════════════════\n */\n\n// External imports\nimport * as Comlink from \"../vendor/comlink.mjs\";\n\n/**\n * Class to facilitate communication with web workers for FEAScript operations\n */\nexport class FEAScriptWorker {\n  /**\n   * Constructor to initialize the FEAScriptWorker class\n   * Sets up the worker and initializes the workerWrapper.\n   */\n  constructor() {\n    this.worker = null;\n    this.feaWorker = null;\n    this.isReady = false;\n\n    this._initWorker();\n  }\n\n  /**\n   * Function to initialize the web worker and wrap it using Comlink\n   * @private\n   * @throws Will throw an error if the worker fails to initialize\n   */\n  async _initWorker() {\n    try {\n      this.worker = new Worker(new URL(\"./wrapperScript.js\", import.meta.url), {\n        type: \"module\",\n      });\n\n      this.worker.onerror = (event) => {\n        console.error(\"FEAScriptWorker: Worker error:\", event);\n      };\n      const workerWrapper = Comlink.wrap(this.worker);\n\n      this.feaWorker = await new workerWrapper();\n\n      this.isReady = true;\n    } catch (error) {\n      console.error(\"Failed to initialize worker\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Function to ensure that the worker is ready before performing any operations\n   * @private\n   * @returns {Promise<void>} Resolves when the worker is ready\n   * @throws Will throw an error if the worker is not ready within the timeout period\n   */\n  async _ensureReady() {\n    if (this.isReady) return Promise.resolve();\n\n    return new Promise((resolve, reject) => {\n      let attempts = 0;\n      const maxAttempts = 50; // 5 seconds max\n\n      const checkReady = () => {\n        attempts++;\n        if (this.isReady) {\n          resolve();\n        } else if (attempts >= maxAttempts) {\n          reject(new Error(\"Timeout waiting for worker to be ready\"));\n        } else {\n          setTimeout(checkReady, 1000);\n        }\n      };\n      checkReady();\n    });\n  }\n\n  /**\n   * Function to set the model configuration in the worker\n   * @param {string} modelConfig - The model configuration to set\n   * @returns {Promise<boolean>} Resolves when the configuration is set\n   */\n  async setModelConfig(modelConfig) {\n    await this._ensureReady();\n    return this.feaWorker.setModelConfig(modelConfig);\n  }\n\n  /**\n   * Function to set the mesh configuration in the worker\n   * @param {object} meshConfig - The mesh configuration to set\n   * @returns {Promise<boolean>} Resolves when the configuration is set\n   */\n  async setMeshConfig(meshConfig) {\n    await this._ensureReady();\n    return this.feaWorker.setMeshConfig(meshConfig);\n  }\n\n  /**\n   * Function to add a boundary condition to the worker\n   * @param {string} boundaryKey - The key identifying the boundary\n   * @param {array} condition - The boundary condition to add\n   * @returns {Promise<boolean>} Resolves when the boundary condition is added\n   */\n  async addBoundaryCondition(boundaryKey, condition) {\n    await this._ensureReady();\n    return this.feaWorker.addBoundaryCondition(boundaryKey, condition);\n  }\n\n  /**\n   * Function to set the solver method in the worker\n   * @param {string} solverMethod - The solver method to set\n   * @returns {Promise<boolean>} Resolves when the solver method is set\n   */\n  async setSolverMethod(solverMethod) {\n    await this._ensureReady();\n    return this.feaWorker.setSolverMethod(solverMethod);\n  }\n\n  /**\n   * Function to request the worker to solve the problem\n   * @returns {Promise<object>} Resolves with the solution result\n   */\n  async solve() {\n    await this._ensureReady();\n    const startTime = performance.now();\n    const result = await this.feaWorker.solve();\n    const endTime = performance.now();\n    return result;\n  }\n\n  /**\n   * Function to retrieve model information from the worker\n   * @returns {Promise<object>} Resolves with the model information\n   */\n  async getModelInfo() {\n    await this._ensureReady();\n    return this.feaWorker.getModelInfo();\n  }\n\n  /**\n   * Function to send a ping request to the worker to check its availability\n   * @returns {Promise<boolean>} Resolves if the worker responds\n   */\n  async ping() {\n    await this._ensureReady();\n    return this.feaWorker.ping();\n  }\n\n  /**\n   * Function to terminate the worker and clean up resources\n   */\n  terminate() {\n    if (this.worker) {\n      this.worker.terminate();\n      this.worker = null;\n      this.feaWorker = null;\n      this.isReady = false;\n    }\n  }\n}\n","/**\n * ════════════════════════════════════════════════════════════════\n *  FEAScript Core Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.2.0 | https://feascript.com\n *  MIT License © 2023–2026 FEAScript\n * ════════════════════════════════════════════════════════════════\n */\n\n// Internal imports\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Function to import mesh data from Gmsh (.msh v4.1) containing quadrilateral and triangular elements\n * @param {File} file\n * @returns {object}\n */\nconst importGmshQuadTri = async (file) => {\n  let result = {\n    nodesXCoordinates: [],\n    nodesYCoordinates: [],\n    nodalNumbering: {\n      quadElements: [],\n      triangleElements: [],\n    },\n    boundaryElements: [],\n    boundaryConditions: [],\n    boundaryNodePairs: {},\n    gmshV: 0,\n    ascii: false,\n    fltBytes: \"8\",\n    totalNodesX: 0,\n    totalNodesY: 0,\n    physicalPropMap: [],\n    elementTypes: {},\n  };\n\n  // Entities to physical tags map\n  const entityPhysicalMap = { curves: {} };\n\n  let content = await file.text();\n  let lines = content\n    .split(\"\\n\")\n    .map((l) => l.trim())\n    .filter((l) => l !== \"\");\n\n  let section = \"\";\n  let lineIndex = 0;\n\n  // Nodes\n  let nodeEntityBlocks = 0;\n  let totalNodes = 0;\n  let nodeBlocksProcessed = 0;\n  let currentNodeBlock = { numNodes: 0 };\n  let nodeTags = [];\n  let nodeTagsCollected = 0;\n  let nodeCoordinatesCollected = 0;\n\n  // Elements\n  let elementEntityBlocks = 0;\n  let totalElements = 0;\n  let elementBlocksProcessed = 0;\n  let currentElementBlock = { numElements: 0 };\n  let elementsProcessedInBlock = 0;\n\n  let boundaryElementsByTag = {};\n\n  // Entities helpers\n  let entityCounts = null;\n  let entitiesPhase = null;\n  let processedPoints = 0;\n  let processedCurves = 0;\n  let processedSurfaces = 0;\n  let processedVolumes = 0;\n\n  while (lineIndex < lines.length) {\n    const line = lines[lineIndex];\n\n    // Section switches\n    if (line === \"$MeshFormat\") {\n      section = \"meshFormat\";\n      lineIndex++;\n      continue;\n    }\n    if (line === \"$EndMeshFormat\") {\n      section = \"\";\n      lineIndex++;\n      continue;\n    }\n    if (line === \"$PhysicalNames\") {\n      section = \"physicalNames\";\n      lineIndex++;\n      continue;\n    }\n    if (line === \"$EndPhysicalNames\") {\n      section = \"\";\n      lineIndex++;\n      continue;\n    }\n    if (line === \"$Entities\") {\n      section = \"entities\";\n      entitiesPhase = \"counts\";\n      lineIndex++;\n      continue;\n    }\n    if (line === \"$EndEntities\") {\n      section = \"\";\n      entityCounts = null;\n      entitiesPhase = null;\n      lineIndex++;\n      continue;\n    }\n    if (line === \"$Nodes\") {\n      section = \"nodes\";\n      lineIndex++;\n      continue;\n    }\n    if (line === \"$EndNodes\") {\n      section = \"\";\n      lineIndex++;\n      continue;\n    }\n    if (line === \"$Elements\") {\n      section = \"elements\";\n      lineIndex++;\n      continue;\n    }\n    if (line === \"$EndElements\") {\n      section = \"\";\n      lineIndex++;\n      continue;\n    }\n\n    const parts = line.split(/\\s+/);\n\n    // Mesh format\n    if (section === \"meshFormat\") {\n      result.gmshV = parseFloat(parts[0]);\n      result.ascii = parts[1] === \"0\";\n      result.fltBytes = parts[2];\n    }\n\n    // Physical names\n    else if (section === \"physicalNames\") {\n      const dimension = parseInt(parts[0], 10);\n      const tag = parseInt(parts[1], 10);\n      let name = parts.slice(2).join(\" \").replace(/^\"|\"$/g, \"\");\n\n      result.physicalPropMap.push({ tag, dimension, name });\n    }\n\n    // Entities\n    else if (section === \"entities\") {\n      if (entitiesPhase === \"counts\") {\n        entityCounts = {\n          points: parseInt(parts[0], 10),\n          curves: parseInt(parts[1], 10),\n          surfaces: parseInt(parts[2], 10),\n          volumes: parseInt(parts[3], 10),\n        };\n        entitiesPhase = \"points\";\n      } else if (entitiesPhase === \"points\") {\n        processedPoints++;\n        if (processedPoints === entityCounts.points) entitiesPhase = \"curves\";\n      } else if (entitiesPhase === \"curves\") {\n        const tag = parseInt(parts[0], 10);\n        const numPhysical = parseInt(parts[7], 10);\n        const physTags = parts.slice(8, 8 + numPhysical).map((p) => parseInt(p, 10));\n        entityPhysicalMap.curves[tag] = physTags;\n        processedCurves++;\n        if (processedCurves === entityCounts.curves) entitiesPhase = \"surfaces\";\n      } else if (entitiesPhase === \"surfaces\") {\n        processedSurfaces++;\n        if (processedSurfaces === entityCounts.surfaces) entitiesPhase = \"volumes\";\n      } else if (entitiesPhase === \"volumes\") {\n        processedVolumes++;\n      }\n    }\n\n    // Nodes\n    else if (section === \"nodes\") {\n      if (nodeEntityBlocks === 0) {\n        nodeEntityBlocks = parseInt(parts[0], 10);\n        totalNodes = parseInt(parts[1], 10);\n        result.nodesXCoordinates = new Array(totalNodes).fill(0);\n        result.nodesYCoordinates = new Array(totalNodes).fill(0);\n      } else if (nodeBlocksProcessed < nodeEntityBlocks && currentNodeBlock.numNodes === 0) {\n        currentNodeBlock = {\n          dim: parseInt(parts[0], 10),\n          tag: parseInt(parts[1], 10),\n          parametric: parseInt(parts[2], 10),\n          numNodes: parseInt(parts[3], 10),\n        };\n        nodeTags = [];\n        nodeTagsCollected = 0;\n        nodeCoordinatesCollected = 0;\n      } else if (nodeTagsCollected < currentNodeBlock.numNodes) {\n        for (let p of parts) {\n          nodeTags.push(parseInt(p, 10));\n          nodeTagsCollected++;\n          if (nodeTagsCollected === currentNodeBlock.numNodes) break;\n        }\n      } else if (nodeCoordinatesCollected < currentNodeBlock.numNodes) {\n        const nodeTag = nodeTags[nodeCoordinatesCollected] - 1;\n        result.nodesXCoordinates[nodeTag] = parseFloat(parts[0]);\n        result.nodesYCoordinates[nodeTag] = parseFloat(parts[1]);\n        result.totalNodesX++;\n        result.totalNodesY++;\n        nodeCoordinatesCollected++;\n        if (nodeCoordinatesCollected === currentNodeBlock.numNodes) {\n          nodeBlocksProcessed++;\n          currentNodeBlock = { numNodes: 0 };\n        }\n      }\n    }\n\n    // Elements\n    else if (section === \"elements\") {\n      if (elementEntityBlocks === 0) {\n        elementEntityBlocks = parseInt(parts[0], 10);\n        totalElements = parseInt(parts[1], 10);\n      } else if (elementBlocksProcessed < elementEntityBlocks && currentElementBlock.numElements === 0) {\n        currentElementBlock = {\n          dim: parseInt(parts[0], 10),\n          tag: parseInt(parts[1], 10), // entity tag\n          elementType: parseInt(parts[2], 10),\n          numElements: parseInt(parts[3], 10),\n        };\n\n        result.elementTypes[currentElementBlock.elementType] =\n          (result.elementTypes[currentElementBlock.elementType] || 0) + currentElementBlock.numElements;\n\n        elementsProcessedInBlock = 0;\n      } else if (elementsProcessedInBlock < currentElementBlock.numElements) {\n        const nodeIndices = parts.slice(1).map((n) => parseInt(n, 10));\n\n        // Resolve physical tag via entity → physical map\n        let physicalTag = currentElementBlock.tag;\n        if (currentElementBlock.dim === 1) {\n          const mapped = entityPhysicalMap.curves[currentElementBlock.tag];\n          if (mapped && mapped.length > 0) physicalTag = mapped[0];\n        }\n\n        if (currentElementBlock.elementType === 1 || currentElementBlock.elementType === 8) {\n          if (!boundaryElementsByTag[physicalTag]) boundaryElementsByTag[physicalTag] = [];\n          boundaryElementsByTag[physicalTag].push(nodeIndices);\n\n          if (!result.boundaryNodePairs[physicalTag]) result.boundaryNodePairs[physicalTag] = [];\n          result.boundaryNodePairs[physicalTag].push(nodeIndices);\n        } else if (currentElementBlock.elementType === 2) {\n          result.nodalNumbering.triangleElements.push(nodeIndices);\n        } else if (currentElementBlock.elementType === 3 || currentElementBlock.elementType === 10) {\n          result.nodalNumbering.quadElements.push(nodeIndices);\n        }\n\n        elementsProcessedInBlock++;\n        if (elementsProcessedInBlock === currentElementBlock.numElements) {\n          elementBlocksProcessed++;\n          currentElementBlock = { numElements: 0 };\n        }\n      }\n    }\n\n    lineIndex++;\n  }\n\n  // Boundary conditions\n  result.physicalPropMap.forEach((prop) => {\n    if (prop.dimension === 1) {\n      const nodes = boundaryElementsByTag[prop.tag] || [];\n      if (nodes.length > 0) {\n        result.boundaryConditions.push({\n          name: prop.name,\n          tag: prop.tag,\n          nodes,\n        });\n      }\n    }\n  });\n\n  debugLog(`Parsed boundary node pairs by physical tag: ${JSON.stringify(result.boundaryNodePairs)}`);\n\n  return result;\n};\n\nexport { importGmshQuadTri };\n","/**\n * ════════════════════════════════════════════════════════════════\n *  FEAScript Core Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.2.0 | https://feascript.com\n *  MIT License © 2023–2026 FEAScript\n * ════════════════════════════════════════════════════════════════\n */\n\nexport { FEAScriptModel } from \"./FEAScript.js\";\nexport { importGmshQuadTri } from \"./readers/gmshReaderScript.js\"; //TODO rename importGmshQuadTri to importGmsh\nexport { logSystem } from \"./utilities/loggingScript.js\";\nexport { plotSolution, plotInterpolatedSolution } from \"./visualization/plotSolutionScript.js\";\nexport { FEAScriptWorker } from \"./workers/workerScript.js\";\nexport const printVersion = \"0.2.0\";"],"names":["euclideanNorm","vector","norm","i","length","Math","sqrt","currentLogLevel","debugLog","message","console","log","basicLog","errorLog","warnLog","proxyMarker","Symbol","createEndpoint","releaseProxy","finalizer","throwMarker","isObject","val","transferHandlers","Map","canHandle","serialize","obj","port1","port2","MessageChannel","expose","deserialize","port","start","wrap","value","serialized","Error","isError","name","stack","Object","assign","ep","globalThis","allowedOrigins","addEventListener","callback","ev","data","origin","allowedOrigin","RegExp","test","isAllowedOrigin","warn","id","type","path","argumentList","map","fromWireValue","returnValue","parent","slice","reduce","prop","rawValue","apply","proxy","transfers","transferCache","set","transfer","undefined","Promise","resolve","catch","then","wireValue","transferables","toWireValue","postMessage","removeEventListener","closeEndPoint","error","TypeError","endpoint","constructor","isMessagePort","close","target","pendingListeners","resolver","get","delete","createProxy","throwIfProxyReleased","isReleased","releaseEndpoint","requestResponseMessage","proxyCounter","WeakMap","proxyFinalizers","FinalizationRegistry","newCount","isProxyReleased","Proxy","_target","unregister","unregisterProxy","clear","r","p","toString","bind","_thisArg","rawArgumentList","last","processArguments","construct","register","registerProxy","processed","v","arr","Array","prototype","concat","handler","serializedValue","msg","fill","floor","random","Number","MAX_SAFE_INTEGER","join","solveLinearSystem","solverMethod","jacobianMatrix","residualVector","options","maxIterations","tolerance","solutionVector","converged","iterations","time","jacobianMatrixSparse","math","sparse","luFactorization","slu","solutionMatrix","lusolve","squeeze","valueOf","jacobiSolverResult","A","b","x0","n","x","xNew","iter","sum","j","maxDiff","max","abs","jacobiSolver","timeEnd","async","solveLinearSystemAsync","isArray","toArray","created","computeEngine","worker","Worker","URL","document","require","__filename","href","currentScript","tagName","toUpperCase","src","baseURI","Comlink.wrap","initialize","createDefaultComputeEngine","result","webgpuJacobiSolver","destroy","terminate","BasisFunctions","meshDimension","elementOrder","this","getBasisFunctions","ksi","eta","basisFunction","basisFunctionDerivKsi","basisFunctionDerivEta","l1","c","l2","l3","dl1","dl2","dl3","Mesh","numElementsX","maxX","numElementsY","maxY","parsedMesh","boundaryElementsProcessed","parseMeshFromGmsh","nodalNumbering","quadElements","triangleElements","JSON","stringify","elementTypes","mappedNodalNumbering","elementIndex","gmshNodes","FEAScriptNodes","push","physicalPropMap","boundaryElements","fixedBoundaryElements","boundaryNodePairs","forEach","dimension","tag","nodesPair","node1","node2","foundElement","elementConnectivity","includes","side","node1Index","indexOf","node2Index","Mesh1D","super","generateMesh","nodesXCoordinates","totalNodesX","deltaX","nodeIndex","generateNodalNumbering1D","findBoundaryElements","nop","columnCounter","sideIndex","Mesh2D","angleLeft","angleRight","nodesYCoordinates","totalNodesY","deltaY","nodeIndexY","nodeIndexX","nnode","degToRad","PI","tanLeft","tan","tanRight","epsilon","y","xLeft","xRight","t","generateNodalNumbering2D","rowCounter","elementIndexX","elementIndexY","nodeIndex1","nodeIndex2","NumericalIntegration","getGaussPointsAndWeights","gaussPoints","gaussWeights","prepareMesh","meshConfig","mesh","nodesCoordinatesAndNumbering","totalElements","totalNodes","initializeFEA","meshData","colIndex","basisFunctions","gaussPointsAndWeights","localToGlobalMap","nodesPerElement","performIsoparametricMapping1D","params","xCoordinates","ksiDerivX","localNodeIndex","detJacobian","basisFunctionDerivX","performIsoparametricMapping2D","yCoordinates","etaDerivX","ksiDerivY","etaDerivY","basisFunctionDerivY","pointInsideTriangle","vertices","v0","v1","v2","denom","inside","pointInsideQuadrilateral","firstTriangleVertices","secondTriangleVertices","v3","splitQuadrilateral","pointInsideFirstTriangle","pointInsideSecondTriangle","getDistanceFromLine","p1","p2","distLeft","distRight","distBottom","ThermalBoundaryConditions","boundaryConditions","imposeConstantTempBoundaryConditions","keys","boundaryKey","tempValue","globalNodeIndex","imposeConstantTempBoundaryConditionsFront","nodeConstraintCode","boundaryValues","imposeConvectionBoundaryConditions","convectionHeatTranfCoeff","convectionExtTemp","key","boundaryCondition","convectionCoeff","extTemp","gaussPoint1","gaussPoint2","firstNodeIndex","lastNodeIndex","nodeIncrement","basisFunctionsAndDerivatives","tangentVectorLength","localNodeIndex2","globalNodeIndex2","gaussPointIndex","imposeConvectionBoundaryConditionsFront","localJacobianMatrix","localResidualVector","boundaryElement","find","boundaryElementIndex","_","assembleHeatConductionMat","FEAData","gaussPointIndex1","mappingResult","localNodeIndex1","localToGlobalMap1","localToGlobalMap2","gaussPointIndex2","thermalBoundaryConditions","assembleHeatConductionFront","ngl","globalIndex","GenericBoundaryConditions","imposeDirichletBoundaryConditions","imposeConstantValueBoundaryConditionsFront","assembleFrontPropagationMat","eikonalActivationFlag","eikonalViscousTerm","solutionDerivX","solutionDerivY","assembleFrontPropagationFront","frontalData","frontalState","elementData","currentElementIndex","frontStorage","runFrontalSolver","assembleFront","numElements","globalResidualVector","topologyData","lateralData","writeFlag","transformationFlag","determinant","systemSize","globalSolutionVector","frontDataIndex","frontSize","frontWidthEstimate","ceil","estimateFrontSize","frontValues","columnHeaders","pivotRow","pivotData","initializeFrontalArrays","dirichletBoundaryConditionsHandler","currentSolutionVector","pivotColumnGlobalIndex","localDestination","rowDestination","rowHeaders","pivotRowIndices","pivotColumnIndices","modifiedRows","pivotColumn","frontMatrix","rowSwapCount","columnSwapCount","lastAppearanceCheck","frontDataCounter","pivotDataIndex","summedRows","reverseElementIndex","columnCount","rowCount","assembled","numElementNodes","numElementColumns","assembleElementContribution","currentElement","columnIndex","rowIndex","localColumnIndex","frontColumnIndex","localRowIndex","availableColumnCount","constrainedRowCount","availableRowCount","absoluteNodeIndex","constrainedIndex","pivotRowIndex","pivotColumnIndex","pivotValue","testColumnIndex","testRowIndex","testValue","pivotGlobalRowIndex","permutationHelper","rightHandSide","globalRowIndex","eliminationFactor","performBackSubstitution","runFrontalAlgorithm","toExponential","finalNodesX","finalNodesY","nodesCoordinates","boundaryLocalJacobianMatrix","boundaryResidualVector","isOnRobinTypeBoundary","some","localNodeI","localNodeJ","iterationIndex","accumulatedValue","newtonRaphson","assembleMat","context","errorNorm","initialSolution","FlowBoundaryConditions","totalNodesVelocity","totalNodesPressure","q2ToPressureMap","totalDOFs","hasStressFree","bcType","uValue","vValue","uDOF","vDOF","pDOF","pointSearch","model","visNodeXCoordinate","visNodeYCoordinate","pointCheck","solutionInterpolation","zData","solutionInterpolationValue","pointInsidePolygon","segments","x1","y1","x2","y2","solverConfig","coefficientFunctions","setSolverConfig","setModelConfig","modelConfig","setMeshConfig","addBoundaryCondition","condition","setSolverMethod","solve","eikonalExteralIterations","newtonRaphsonResult","B","C","D","xCoord","a","d","globalNodeIndex1","assembleGeneralFormPDEMat","stokesResult","cornerLocalIndices","pressureNodeIndices","pressureNodeCount","cornerIndex","globalQ2Node","has","velocityBasisFunctions","pressureBasisFunctions","velLocalToGlobalMap","presLocalToGlobalMap","velocityBasisFunctionsAndDerivatives","pressureBasisFunctionsAndDerivatives","weightFactor","globalNode1","uDOF1","vDOF1","globalNode2","uDOF2","vDOF2","viscousContribution","localPresIndex","bxContribution","byContribution","assembleStokesMatrix","_stokesMetadata","solveAsync","feaWorker","isReady","_initWorker","onerror","event","workerWrapper","_ensureReady","reject","attempts","checkReady","setTimeout","performance","now","getModelInfo","ping","file","gmshV","ascii","fltBytes","entityPhysicalMap","curves","lines","text","split","l","trim","filter","section","lineIndex","nodeEntityBlocks","nodeBlocksProcessed","currentNodeBlock","numNodes","nodeTags","nodeTagsCollected","nodeCoordinatesCollected","elementEntityBlocks","elementBlocksProcessed","currentElementBlock","elementsProcessedInBlock","boundaryElementsByTag","entityCounts","entitiesPhase","processedPoints","processedCurves","processedSurfaces","line","parts","parseFloat","parseInt","replace","points","surfaces","volumes","numPhysical","physTags","dim","parametric","nodeTag","elementType","nodeIndices","physicalTag","mapped","nodes","level","plotType","plotDivId","visNodeXCoordinates","visNodeYCoordinates","lengthX","min","lengthY","visPoinsPerUnit","visNodesX","round","visNodesY","deltavisX","deltavisY","visSolution","visNodeIndexY","visNodeIndexX","boundarySegments","boundarySides","boundaryLineElements","boundaryNodesSegments","boundaryGlobalElementIndex","boundaryIndex","boundaryLocalElementIndex","boundaryLocalNodeIndices","currentElementNodesX","currentElementNodesY","boundaryLocalNodeIndex","k","getBoundarySegments","nodeNeighbors","neighborCount","from","elemIndex","computeNodeNeighbors","lastParentElement","visNodeIndex","found","neighborElementsIndex","searchResult","maxWindowWidth","window","innerWidth","aspectRatio","plotWidth","plotHeight","layout","title","width","height","xaxis","yaxis","scaleanchor","scaleratio","margin","hovermode","contourData","z","connectgaps","hoverongaps","smoothing","contours","coloring","showlabels","colorbar","Plotly","newPlot","responsive","yData","lineData","mode","color","minX","minY"],"mappings":"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"}