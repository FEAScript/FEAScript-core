{"version":3,"file":"feascript.cjs.js","sources":["../src/vendor/comlink.mjs","../src/methods/numericalIntegrationScript.js","../src/utilities/loggingScript.js","../src/mesh/basisFunctionsScript.js","../src/mesh/meshGenerationScript.js","../src/solvers/thermalBoundaryConditionsScript.js","../src/FEAScript.js","../src/solvers/solidHeatTransferScript.js","../src/methods/jacobiMethodScript.js","../src/workers/workerScript.js","../src/readers/gmshReaderScript.js","../src/visualization/plotSolutionScript.js"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    [\"proxy\", proxyTransferHandler],\n    [\"throw\", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case \"GET\" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction wrap(ep, target) {\n    const pendingListeners = new Map();\n    ep.addEventListener(\"message\", function handleMessage(ev) {\n        const { data } = ev;\n        if (!data || !data.id) {\n            return;\n        }\n        const resolver = pendingListeners.get(data.id);\n        if (!resolver) {\n            return;\n        }\n        try {\n            resolver(data);\n        }\n        finally {\n            pendingListeners.delete(data.id);\n        }\n    });\n    return createProxy(ep, pendingListeners, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, new Map(), {\n        type: \"RELEASE\" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, pendingListeners, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    pendingListeners.clear();\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, pendingListeners, {\n                    type: \"GET\" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, pendingListeners, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"SET\" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, pendingListeners, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didn’t happen.\n            if (last === \"bind\") {\n                return createProxy(ep, pendingListeners, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"APPLY\" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case \"HANDLER\" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, pendingListeners, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        pendingListeners.set(id, resolve);\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join(\"-\");\n}\n\nexport { createEndpoint, expose, finalizer, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n/**\n * Class to handle numerical integration using Gauss quadrature\n */\nexport class numericalIntegration {\n  /**\n   * Constructor to initialize the numericalIntegration class\n   * @param {string} meshDimension - The dimension of the mesh\n   * @param {string} elementOrder - The order of elements\n   */\n  constructor({ meshDimension, elementOrder }) {\n    this.meshDimension = meshDimension;\n    this.elementOrder = elementOrder;\n  }\n\n  /**\n   * Function to return Gauss points and weights based on element configuration\n   * @returns {object} An object containing:\n   *  - gaussPoints: Array of Gauss points\n   *  - gaussWeights: Array of Gauss weights\n   */\n  getGaussPointsAndWeights() {\n    let gaussPoints = []; // Gauss points\n    let gaussWeights = []; // Gauss weights\n\n    if (this.elementOrder === \"linear\") {\n      // For linear elements, use 1-point Gauss quadrature\n      gaussPoints[0] = 0.5;\n      gaussWeights[0] = 1;\n    } else if (this.elementOrder === \"quadratic\") {\n      // For quadratic elements, use 3-point Gauss quadrature\n      gaussPoints[0] = (1 - Math.sqrt(3 / 5)) / 2;\n      gaussPoints[1] = 0.5;\n      gaussPoints[2] = (1 + Math.sqrt(3 / 5)) / 2;\n      gaussWeights[0] = 5 / 18;\n      gaussWeights[1] = 8 / 18;\n      gaussWeights[2] = 5 / 18;\n    }\n\n    return { gaussPoints, gaussWeights };\n  }\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n// Global logging level\nlet currentLogLevel = \"basic\";\n\n/**\n * Function to set the logging system level\n * @param {string} level - Logging level (basic, debug)\n */\nexport function logSystem(level) {\n  if (level !== \"basic\" && level !== \"debug\") {\n    console.log(\n      \"%c[WARN] Invalid log level: \" + level + \". Using basic instead.\",\n      \"color: #FFC107; font-weight: bold;\"\n    ); // Yellow for warnings\n    currentLogLevel = \"basic\";\n  } else {\n    currentLogLevel = level;\n    basicLog(`Log level set to: ${level}`);\n  }\n}\n\n/**\n * Function to log debug messages - only logs if level is 'debug'\n * @param {string} message - Message to log\n */\nexport function debugLog(message) {\n  if (currentLogLevel === \"debug\") {\n    console.log(\"%c[DEBUG] \" + message, \"color: #2196F3; font-weight: bold;\"); // Blue color for debug\n  }\n}\n\n/**\n * Function to log basic information - always logs\n * @param {string} message - Message to log\n */\nexport function basicLog(message) {\n  console.log(\"%c[INFO] \" + message, \"color: #4CAF50; font-weight: bold;\"); // Green color for basic info\n}\n\n/**\n * Function to log error messages\n * @param {string} message - Message to log\n */\nexport function errorLog(message) {\n  console.log(\"%c[ERROR] \" + message, \"color: #F44336; font-weight: bold;\"); // Red color for errors\n}\n\n/**\n * Function to handle version information and fetch the latest update date and release from GitHub\n */\nexport async function printVersion() {\n  basicLog(\"Fetching latest FEAScript version information...\");\n  try {\n    const commitResponse = await fetch(\"https://api.github.com/repos/FEAScript/FEAScript/commits/main\");\n    const commitData = await commitResponse.json();\n    const latestCommitDate = new Date(commitData.commit.committer.date).toLocaleString();\n    basicLog(`Latest FEAScript update: ${latestCommitDate}`);\n    return latestCommitDate;\n  } catch (error) {\n    errorLog(\"Failed to fetch version information: \" + error);\n    return \"Version information unavailable\";\n  }\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n// Internal imports\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Class to handle basis functions and their derivatives based on element configuration\n */\nexport class basisFunctions {\n  /**\n   * Constructor to initialize the basisFunctions class\n   * @param {string} meshDimension - The dimension of the mesh\n   * @param {string} elementOrder - The order of elements\n   */\n  constructor({ meshDimension, elementOrder }) {\n    this.meshDimension = meshDimension;\n    this.elementOrder = elementOrder;\n  }\n\n  /**\n   * Function to calculate basis functions and their derivatives based on the dimension and order\n   * @param {number} ksi - Natural coordinate (for both 1D and 2D)\n   * @param {number} [eta] - Second natural coordinate (only for 2D elements)\n   * @returns {object} An object containing:\n   *  - basisFunction: Array of evaluated basis functions\n   *  - basisFunctionDerivKsi: Array of derivatives of basis functions with respect to ksi\n   *  - basisFunctionDerivEta: Array of derivatives of basis functions with respect to eta (only for 2D elements)\n   */\n  getBasisFunctions(ksi, eta = null) {\n    let basisFunction = [];\n    let basisFunctionDerivKsi = [];\n    let basisFunctionDerivEta = [];\n\n    if (this.meshDimension === \"1D\") {\n      if (this.elementOrder === \"linear\") {\n        // Linear basis functions for 1D elements\n        basisFunction[0] = 1 - ksi;\n        basisFunction[1] = ksi;\n\n        // Derivatives of basis functions with respect to ksi\n        basisFunctionDerivKsi[0] = -1;\n        basisFunctionDerivKsi[1] = 1;\n      } else if (this.elementOrder === \"quadratic\") {\n        // Quadratic basis functions for 1D elements\n        basisFunction[0] = 1 - 3 * ksi + 2 * ksi ** 2;\n        basisFunction[1] = 4 * ksi - 4 * ksi ** 2;\n        basisFunction[2] = -ksi + 2 * ksi ** 2;\n\n        // Derivatives of basis functions with respect to ksi\n        basisFunctionDerivKsi[0] = -3 + 4 * ksi;\n        basisFunctionDerivKsi[1] = 4 - 8 * ksi;\n        basisFunctionDerivKsi[2] = -1 + 4 * ksi;\n      }\n    } else if (this.meshDimension === \"2D\") {\n      if (eta === null) {\n        errorLog(\"Eta coordinate is required for 2D elements\");\n        return;\n      }\n\n      if (this.elementOrder === \"linear\") {\n        // Linear basis functions for 2D elements\n        function l1(c) {\n          return 1 - c;\n        }\n        function l2(c) {\n          return c;\n        }\n        function dl1() {\n          return -1;\n        }\n        function dl2() {\n          return 1;\n        }\n\n        // Evaluate basis functions at (ksi, eta)\n        basisFunction[0] = l1(ksi) * l1(eta);\n        basisFunction[1] = l1(ksi) * l2(eta);\n        basisFunction[2] = l2(ksi) * l1(eta);\n        basisFunction[3] = l2(ksi) * l2(eta);\n\n        // Derivatives with respect to ksi\n        basisFunctionDerivKsi[0] = dl1() * l1(eta);\n        basisFunctionDerivKsi[1] = dl1() * l2(eta);\n        basisFunctionDerivKsi[2] = dl2() * l1(eta);\n        basisFunctionDerivKsi[3] = dl2() * l2(eta);\n\n        // Derivatives with respect to eta\n        basisFunctionDerivEta[0] = l1(ksi) * dl1();\n        basisFunctionDerivEta[1] = l1(ksi) * dl2();\n        basisFunctionDerivEta[2] = l2(ksi) * dl1();\n        basisFunctionDerivEta[3] = l2(ksi) * dl2();\n      } else if (this.elementOrder === \"quadratic\") {\n        // Quadratic basis functions for 2D elements\n        function l1(c) {\n          return 2 * c ** 2 - 3 * c + 1;\n        }\n        function l2(c) {\n          return -4 * c ** 2 + 4 * c;\n        }\n        function l3(c) {\n          return 2 * c ** 2 - c;\n        }\n        function dl1(c) {\n          return 4 * c - 3;\n        }\n        function dl2(c) {\n          return -8 * c + 4;\n        }\n        function dl3(c) {\n          return 4 * c - 1;\n        }\n\n        // Evaluate basis functions at (ksi, eta)\n        basisFunction[0] = l1(ksi) * l1(eta);\n        basisFunction[1] = l1(ksi) * l2(eta);\n        basisFunction[2] = l1(ksi) * l3(eta);\n        basisFunction[3] = l2(ksi) * l1(eta);\n        basisFunction[4] = l2(ksi) * l2(eta);\n        basisFunction[5] = l2(ksi) * l3(eta);\n        basisFunction[6] = l3(ksi) * l1(eta);\n        basisFunction[7] = l3(ksi) * l2(eta);\n        basisFunction[8] = l3(ksi) * l3(eta);\n\n        // Derivatives with respect to ksi\n        basisFunctionDerivKsi[0] = dl1(ksi) * l1(eta);\n        basisFunctionDerivKsi[1] = dl1(ksi) * l2(eta);\n        basisFunctionDerivKsi[2] = dl1(ksi) * l3(eta);\n        basisFunctionDerivKsi[3] = dl2(ksi) * l1(eta);\n        basisFunctionDerivKsi[4] = dl2(ksi) * l2(eta);\n        basisFunctionDerivKsi[5] = dl2(ksi) * l3(eta);\n        basisFunctionDerivKsi[6] = dl3(ksi) * l1(eta);\n        basisFunctionDerivKsi[7] = dl3(ksi) * l2(eta);\n        basisFunctionDerivKsi[8] = dl3(ksi) * l3(eta);\n\n        // Derivatives with respect to eta\n        basisFunctionDerivEta[0] = l1(ksi) * dl1(eta);\n        basisFunctionDerivEta[1] = l1(ksi) * dl2(eta);\n        basisFunctionDerivEta[2] = l1(ksi) * dl3(eta);\n        basisFunctionDerivEta[3] = l2(ksi) * dl1(eta);\n        basisFunctionDerivEta[4] = l2(ksi) * dl2(eta);\n        basisFunctionDerivEta[5] = l2(ksi) * dl3(eta);\n        basisFunctionDerivEta[6] = l3(ksi) * dl1(eta);\n        basisFunctionDerivEta[7] = l3(ksi) * dl2(eta);\n        basisFunctionDerivEta[8] = l3(ksi) * dl3(eta);\n      }\n    }\n\n    return { basisFunction, basisFunctionDerivKsi, basisFunctionDerivEta };\n  }\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n// Internal imports\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Class to handle the generation of structured finite element meshes\n */\nexport class meshGeneration {\n  /**\n   * Constructor to initialize the meshGeneration class\n   * @param {object} config - Configuration object for the mesh\n   * @param {number} [config.numElementsX] - Number of elements along the x-axis (required for geometry-based mesh)\n   * @param {number} [config.maxX] - Maximum x-coordinate of the mesh (required for geometry-based mesh)\n   * @param {number} [config.numElementsY=1] - Number of elements along the y-axis (for 1D meshes)\n   * @param {number} [config.maxY=0] - Maximum y-coordinate of the mesh (for 1D meshes)\n   * @param {string} [config.meshDimension='2D'] - The dimension of the mesh, either 1D or 2D\n   * @param {string} [config.elementOrder='linear'] - The order of elements, either 'linear' or 'quadratic'\n   * @param {object} [config.parsedMesh=null] - Optional pre-parsed mesh data\n   */\n  constructor({\n    numElementsX = null,\n    maxX = null,\n    numElementsY = null,\n    maxY = null,\n    meshDimension = null,\n    elementOrder = \"linear\",\n    parsedMesh = null,\n  }) {\n    this.numElementsX = numElementsX;\n    this.numElementsY = numElementsY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n    this.meshDimension = meshDimension;\n    this.elementOrder = elementOrder;\n    this.parsedMesh = parsedMesh;\n  }\n\n  /**\n   * Function to generate the mesh based on the dimension or use a pre-parsed mesh\n   * @returns {object} The generated mesh containing node coordinates and total nodes\n   */\n  generateMesh() {\n    // If pre-parsed mesh data is provided, use it directly\n    if (this.parsedMesh) {\n      // Process the nodalNumbering from gmshReader format to the format expected by the solver\n      if (this.parsedMesh.nodalNumbering) {\n        if (\n          typeof this.parsedMesh.nodalNumbering === \"object\" &&\n          !Array.isArray(this.parsedMesh.nodalNumbering)\n        ) {\n          // Store the nodal numbering structure before converting\n          const quadElements = this.parsedMesh.nodalNumbering.quadElements || [];\n          const triangleElements = this.parsedMesh.nodalNumbering.triangleElements || [];\n\n          debugLog(\n            \"Initial parsed mesh nodal numbering from GMSH format: \" +\n              JSON.stringify(this.parsedMesh.nodalNumbering)\n          );\n\n          // Check if it has quadElements or triangleElements structure from gmshReader\n          if (this.parsedMesh.elementTypes[3] || this.parsedMesh.elementTypes[10]) {\n            // Map nodal numbering from GMSH format to FEAScript format for quad elements\n            const mappedNodalNumbering = [];\n\n            for (let elemIdx = 0; elemIdx < quadElements.length; elemIdx++) {\n              const gmshNodes = quadElements[elemIdx];\n              const feaScriptNodes = new Array(gmshNodes.length);\n\n              // Check for element type based on number of nodes\n              if (gmshNodes.length === 4) {\n                // Simple mapping for linear quad elements (4 nodes)\n                // GMSH:         FEAScript:\n                // 3 --- 2       1 --- 3\n                // |     |  -->  |     |\n                // 0 --- 1       0 --- 2\n\n                feaScriptNodes[0] = gmshNodes[0]; // 0 -> 0\n                feaScriptNodes[1] = gmshNodes[3]; // 3 -> 1\n                feaScriptNodes[2] = gmshNodes[1]; // 1 -> 2\n                feaScriptNodes[3] = gmshNodes[2]; // 2 -> 3\n              } else if (gmshNodes.length === 9) {\n                // Mapping for quadratic quad elements (9 nodes)\n                // GMSH:         FEAScript:\n                // 3--6--2       2--5--8\n                // |     |       |     |\n                // 7  8  5  -->  1  4  7\n                // |     |       |     |\n                // 0--4--1       0--3--6\n\n                feaScriptNodes[0] = gmshNodes[0]; // 0 -> 0\n                feaScriptNodes[1] = gmshNodes[7]; // 7 -> 1\n                feaScriptNodes[2] = gmshNodes[3]; // 3 -> 2\n                feaScriptNodes[3] = gmshNodes[4]; // 4 -> 3\n                feaScriptNodes[4] = gmshNodes[8]; // 8 -> 4\n                feaScriptNodes[5] = gmshNodes[6]; // 6 -> 5\n                feaScriptNodes[6] = gmshNodes[1]; // 1 -> 6\n                feaScriptNodes[7] = gmshNodes[5]; // 5 -> 7\n                feaScriptNodes[8] = gmshNodes[2]; // 2 -> 8\n              }\n\n              mappedNodalNumbering.push(feaScriptNodes);\n            }\n\n            this.parsedMesh.nodalNumbering = mappedNodalNumbering;\n          } else if (this.parsedMesh.elementTypes[2]) {\n          }\n\n          debugLog(\n            \"Nodal numbering after mapping from GMSH to FEAScript format: \" +\n              JSON.stringify(this.parsedMesh.nodalNumbering)\n          );\n\n          // Process boundary elements if they exist and if physical property mapping exists\n          if (this.parsedMesh.physicalPropMap && this.parsedMesh.boundaryElements) {\n            // Check if boundary elements need to be processed\n            if (\n              Array.isArray(this.parsedMesh.boundaryElements) &&\n              this.parsedMesh.boundaryElements.length > 0 &&\n              this.parsedMesh.boundaryElements[0] === undefined\n            ) {\n              // Create a new array without the empty first element\n              const fixedBoundaryElements = [];\n              for (let i = 1; i < this.parsedMesh.boundaryElements.length; i++) {\n                if (this.parsedMesh.boundaryElements[i]) {\n                  fixedBoundaryElements.push(this.parsedMesh.boundaryElements[i]);\n                }\n              }\n              this.parsedMesh.boundaryElements = fixedBoundaryElements;\n            }\n\n            // If boundary node pairs exist but boundary elements haven't been processed\n            if (this.parsedMesh.boundaryNodePairs && !this.parsedMesh.boundaryElementsProcessed) {\n              // Reset boundary elements array\n              this.parsedMesh.boundaryElements = [];\n\n              // Process each physical property from the Gmsh file\n              this.parsedMesh.physicalPropMap.forEach((prop) => {\n                // Only process 1D physical entities (boundary lines)\n                if (prop.dimension === 1) {\n                  // Get all node pairs for this boundary\n                  const boundaryNodePairs = this.parsedMesh.boundaryNodePairs[prop.tag] || [];\n\n                  if (boundaryNodePairs.length > 0) {\n                    // Initialize array for this boundary tag\n                    if (!this.parsedMesh.boundaryElements[prop.tag]) {\n                      this.parsedMesh.boundaryElements[prop.tag] = [];\n                    }\n\n                    // For each boundary line segment (defined by a pair of nodes)\n                    boundaryNodePairs.forEach((nodesPair) => {\n                      const node1 = nodesPair[0]; // First node in the pair\n                      const node2 = nodesPair[1]; // Second node in the pair\n\n                      debugLog(\n                        `Processing boundary node pair: [${node1}, ${node2}] for boundary ${prop.tag} (${\n                          prop.name || \"unnamed\"\n                        })`\n                      );\n\n                      // Search through all elements to find which one contains both nodes\n                      let foundElement = false;\n\n                      // Loop through all elements in the mesh\n                      for (let elemIdx = 0; elemIdx < this.parsedMesh.nodalNumbering.length; elemIdx++) {\n                        const elemNodes = this.parsedMesh.nodalNumbering[elemIdx];\n\n                        // For linear quadrilateral linear elements (4 nodes)\n                        if (elemNodes.length === 4) {\n                          // Check if both boundary nodes are in this element\n                          if (elemNodes.includes(node1) && elemNodes.includes(node2)) {\n                            // Find which side of the element these nodes form\n                            let side;\n\n                            const node1Index = elemNodes.indexOf(node1);\n                            const node2Index = elemNodes.indexOf(node2);\n\n                            debugLog(\n                              `  Found element ${elemIdx} containing boundary nodes. Element nodes: [${elemNodes.join(\n                                \", \"\n                              )}]`\n                            );\n                            debugLog(\n                              `  Node ${node1} is at index ${node1Index}, Node ${node2} is at index ${node2Index} in the element`\n                            );\n\n                            // Based on FEAScript linear quadrilateral numbering:\n                            // 1 --- 3\n                            // |     |\n                            // 0 --- 2\n\n                            if (\n                              (node1Index === 0 && node2Index === 2) ||\n                              (node1Index === 2 && node2Index === 0)\n                            ) {\n                              side = 0; // Bottom side\n                              debugLog(`  These nodes form the BOTTOM side (${side}) of element ${elemIdx}`);\n                            } else if (\n                              (node1Index === 0 && node2Index === 1) ||\n                              (node1Index === 1 && node2Index === 0)\n                            ) {\n                              side = 1; // Left side\n                              debugLog(`  These nodes form the LEFT side (${side}) of element ${elemIdx}`);\n                            } else if (\n                              (node1Index === 1 && node2Index === 3) ||\n                              (node1Index === 3 && node2Index === 1)\n                            ) {\n                              side = 2; // Top side\n                              debugLog(`  These nodes form the TOP side (${side}) of element ${elemIdx}`);\n                            } else if (\n                              (node1Index === 2 && node2Index === 3) ||\n                              (node1Index === 3 && node2Index === 2)\n                            ) {\n                              side = 3; // Right side\n                              debugLog(`  These nodes form the RIGHT side (${side}) of element ${elemIdx}`);\n                            }\n\n                            // Add the element and side to the boundary elements array\n                            this.parsedMesh.boundaryElements[prop.tag].push([elemIdx, side]);\n                            debugLog(\n                              `  Added element-side pair [${elemIdx}, ${side}] to boundary tag ${prop.tag}`\n                            );\n                            foundElement = true;\n                            break;\n                          }\n                        } else if (elemNodes.length === 9) {\n                          // For quadratic quadrilateral elements (9 nodes)\n                          // Check if both boundary nodes are in this element\n                          if (elemNodes.includes(node1) && elemNodes.includes(node2)) {\n                            // Find which side of the element these nodes form\n                            let side;\n\n                            const node1Index = elemNodes.indexOf(node1);\n                            const node2Index = elemNodes.indexOf(node2);\n\n                            debugLog(\n                              `  Found element ${elemIdx} containing boundary nodes. Element nodes: [${elemNodes.join(\n                                \", \"\n                              )}]`\n                            );\n                            debugLog(\n                              `  Node ${node1} is at index ${node1Index}, Node ${node2} is at index ${node2Index} in the element`\n                            );\n\n                            // Based on FEAScript quadratic quadrilateral numbering:\n                            // 2--5--8\n                            // |     |\n                            // 1  4  7\n                            // |     |\n                            // 0--3--6\n\n                            if (\n                              (node1Index === 0 && node2Index === 6) ||\n                              (node1Index === 6 && node2Index === 0) ||\n                              (node1Index === 0 && node2Index === 3) ||\n                              (node1Index === 3 && node2Index === 0) ||\n                              (node1Index === 3 && node2Index === 6) ||\n                              (node1Index === 6 && node2Index === 3)\n                            ) {\n                              side = 0; // Bottom side (nodes 0, 3, 6)\n                              debugLog(`  These nodes form the BOTTOM side (${side}) of element ${elemIdx}`);\n                            } else if (\n                              (node1Index === 0 && node2Index === 2) ||\n                              (node1Index === 2 && node2Index === 0) ||\n                              (node1Index === 0 && node2Index === 1) ||\n                              (node1Index === 1 && node2Index === 0) ||\n                              (node1Index === 1 && node2Index === 2) ||\n                              (node1Index === 2 && node2Index === 1)\n                            ) {\n                              side = 1; // Left side (nodes 0, 1, 2)\n                              debugLog(`  These nodes form the LEFT side (${side}) of element ${elemIdx}`);\n                            } else if (\n                              (node1Index === 2 && node2Index === 8) ||\n                              (node1Index === 8 && node2Index === 2) ||\n                              (node1Index === 2 && node2Index === 5) ||\n                              (node1Index === 5 && node2Index === 2) ||\n                              (node1Index === 5 && node2Index === 8) ||\n                              (node1Index === 8 && node2Index === 5)\n                            ) {\n                              side = 2; // Top side (nodes 2, 5, 8)\n                              debugLog(`  These nodes form the TOP side (${side}) of element ${elemIdx}`);\n                            } else if (\n                              (node1Index === 6 && node2Index === 8) ||\n                              (node1Index === 8 && node2Index === 6) ||\n                              (node1Index === 6 && node2Index === 7) ||\n                              (node1Index === 7 && node2Index === 6) ||\n                              (node1Index === 7 && node2Index === 8) ||\n                              (node1Index === 8 && node2Index === 7)\n                            ) {\n                              side = 3; // Right side (nodes 6, 7, 8)\n                              debugLog(`  These nodes form the RIGHT side (${side}) of element ${elemIdx}`);\n                            }\n\n                            // Add the element and side to the boundary elements array\n                            this.parsedMesh.boundaryElements[prop.tag].push([elemIdx, side]);\n                            debugLog(\n                              `  Added element-side pair [${elemIdx}, ${side}] to boundary tag ${prop.tag}`\n                            );\n                            foundElement = true;\n                            break;\n                          }\n                        }\n                      }\n\n                      if (!foundElement) {\n                        errorLog(\n                          `Could not find element containing boundary nodes ${node1} and ${node2}. Boundary may be incomplete.`\n                        );\n                      }\n                    });\n                  }\n                }\n              });\n\n              // Mark as processed\n              this.parsedMesh.boundaryElementsProcessed = true;\n\n              // Fix boundary elements array - remove undefined entries\n              if (\n                this.parsedMesh.boundaryElements.length > 0 &&\n                this.parsedMesh.boundaryElements[0] === undefined\n              ) {\n                const fixedBoundaryElements = [];\n                for (let i = 1; i < this.parsedMesh.boundaryElements.length; i++) {\n                  if (this.parsedMesh.boundaryElements[i]) {\n                    fixedBoundaryElements.push(this.parsedMesh.boundaryElements[i]);\n                  }\n                }\n                this.parsedMesh.boundaryElements = fixedBoundaryElements;\n              }\n            }\n          }\n        }\n      }\n\n      debugLog(\"Processed boundary elements by tag: \" + JSON.stringify(this.parsedMesh.boundaryElements));\n\n      return this.parsedMesh;\n    } else {\n      // Validate required geometry parameters based on mesh dimension\n      if (this.meshDimension === \"1D\") {\n        if (this.numElementsX === null || this.maxX === null) {\n          errorLog(\"numElementsX and maxX are required parameters when generating a 1D mesh from geometry\");\n        }\n      } else if (this.meshDimension === \"2D\") {\n        if (\n          this.numElementsX === null ||\n          this.maxX === null ||\n          this.numElementsY === null ||\n          this.maxY === null\n        ) {\n          errorLog(\n            \"numElementsX, maxX, numElementsY, and maxY are required parameters when generating a 2D mesh from geometry\"\n          );\n        }\n      }\n\n      // Generate mesh based on dimension\n      return this.generateMeshFromGeometry();\n    }\n  }\n\n  /**\n   * Function to generate a structured mesh based on the geometry configuration\n   * @returns {object} An object containing the coordinates of nodes,\n   * total number of nodes, nodal numbering (NOP) array, and boundary elements\n   */\n  generateMeshFromGeometry() {\n    let nodesXCoordinates = [];\n    let nodesYCoordinates = [];\n    const xStart = 0;\n    const yStart = 0;\n    let totalNodesX, totalNodesY, deltaX, deltaY;\n\n    if (this.meshDimension === \"1D\") {\n      if (this.elementOrder === \"linear\") {\n        totalNodesX = this.numElementsX + 1;\n        deltaX = (this.maxX - xStart) / this.numElementsX;\n\n        nodesXCoordinates[0] = xStart;\n        for (let nodeIndex = 1; nodeIndex < totalNodesX; nodeIndex++) {\n          nodesXCoordinates[nodeIndex] = nodesXCoordinates[nodeIndex - 1] + deltaX;\n        }\n      } else if (this.elementOrder === \"quadratic\") {\n        totalNodesX = 2 * this.numElementsX + 1;\n        deltaX = (this.maxX - xStart) / this.numElementsX;\n\n        nodesXCoordinates[0] = xStart;\n        for (let nodeIndex = 1; nodeIndex < totalNodesX; nodeIndex++) {\n          nodesXCoordinates[nodeIndex] = nodesXCoordinates[nodeIndex - 1] + deltaX / 2;\n        }\n      }\n      // Generate nodal numbering (NOP) array\n      const nodalNumbering = this.generateNodalNumbering(\n        this.numElementsX,\n        null, // numElementsY (not used in 1D)\n        totalNodesX,\n        null, // totalNodesY (not used in 1D)\n        this.elementOrder\n      );\n      // Find boundary elements\n      const boundaryElements = this.findBoundaryElements();\n\n      debugLog(\"Generated node X coordinates: \" + JSON.stringify(nodesXCoordinates));\n\n      // Return x coordinates of nodes, total nodes, NOP array, and boundary elements\n      return {\n        nodesXCoordinates,\n        totalNodesX,\n        nodalNumbering,\n        boundaryElements,\n      };\n    } else if (this.meshDimension === \"2D\") {\n      if (this.elementOrder === \"linear\") {\n        totalNodesX = this.numElementsX + 1;\n        totalNodesY = this.numElementsY + 1;\n        deltaX = (this.maxX - xStart) / this.numElementsX;\n        deltaY = (this.maxY - yStart) / this.numElementsY;\n\n        nodesXCoordinates[0] = xStart;\n        nodesYCoordinates[0] = yStart;\n        for (let nodeIndexY = 1; nodeIndexY < totalNodesY; nodeIndexY++) {\n          nodesXCoordinates[nodeIndexY] = nodesXCoordinates[0];\n          nodesYCoordinates[nodeIndexY] = nodesYCoordinates[0] + nodeIndexY * deltaY;\n        }\n        for (let nodeIndexX = 1; nodeIndexX < totalNodesX; nodeIndexX++) {\n          const nnode = nodeIndexX * totalNodesY;\n          nodesXCoordinates[nnode] = nodesXCoordinates[0] + nodeIndexX * deltaX;\n          nodesYCoordinates[nnode] = nodesYCoordinates[0];\n          for (let nodeIndexY = 1; nodeIndexY < totalNodesY; nodeIndexY++) {\n            nodesXCoordinates[nnode + nodeIndexY] = nodesXCoordinates[nnode];\n            nodesYCoordinates[nnode + nodeIndexY] = nodesYCoordinates[nnode] + nodeIndexY * deltaY;\n          }\n        }\n      } else if (this.elementOrder === \"quadratic\") {\n        totalNodesX = 2 * this.numElementsX + 1;\n        totalNodesY = 2 * this.numElementsY + 1;\n        deltaX = (this.maxX - xStart) / this.numElementsX;\n        deltaY = (this.maxY - yStart) / this.numElementsY;\n\n        nodesXCoordinates[0] = xStart;\n        nodesYCoordinates[0] = yStart;\n        for (let nodeIndexY = 1; nodeIndexY < totalNodesY; nodeIndexY++) {\n          nodesXCoordinates[nodeIndexY] = nodesXCoordinates[0];\n          nodesYCoordinates[nodeIndexY] = nodesYCoordinates[0] + (nodeIndexY * deltaY) / 2;\n        }\n        for (let nodeIndexX = 1; nodeIndexX < totalNodesX; nodeIndexX++) {\n          const nnode = nodeIndexX * totalNodesY;\n          nodesXCoordinates[nnode] = nodesXCoordinates[0] + (nodeIndexX * deltaX) / 2;\n          nodesYCoordinates[nnode] = nodesYCoordinates[0];\n          for (let nodeIndexY = 1; nodeIndexY < totalNodesY; nodeIndexY++) {\n            nodesXCoordinates[nnode + nodeIndexY] = nodesXCoordinates[nnode];\n            nodesYCoordinates[nnode + nodeIndexY] = nodesYCoordinates[nnode] + (nodeIndexY * deltaY) / 2;\n          }\n        }\n      }\n      // Generate nodal numbering (NOP) array\n      const nodalNumbering = this.generateNodalNumbering(\n        this.numElementsX,\n        this.numElementsY,\n        totalNodesX,\n        totalNodesY,\n        this.elementOrder\n      );\n      // Find boundary elements\n      const boundaryElements = this.findBoundaryElements();\n\n      debugLog(\"Generated node X coordinates: \" + JSON.stringify(nodesXCoordinates));\n      debugLog(\"Generated node Y coordinates: \" + JSON.stringify(nodesYCoordinates));\n\n      // Return x and y coordinates of nodes, total nodes, NOP array, and boundary elements\n      return {\n        nodesXCoordinates,\n        nodesYCoordinates,\n        totalNodesX,\n        totalNodesY,\n        nodalNumbering,\n        boundaryElements,\n      };\n    }\n  }\n\n  /**\n   * Function to find the elements that belong to each boundary of a domain\n   * @returns {array} An array containing arrays of elements and their adjacent boundary side for each boundary\n   * Each element in the array is of the form [elementIndex, side], where 'side' indicates which side\n   * of the reference element is in contact with the physical boundary:\n   *\n   * For 1D domains (line segments):\n   * 0 - Left node of reference element (maps to physical left endpoint)\n   * 1 - Right node of reference element (maps to physical right endpoint)\n   *\n   * For 2D domains (rectangular):\n   * 0 - Bottom side of reference element (maps to physical bottom boundary)\n   * 1 - Left side of reference element (maps to physical left boundary)\n   * 2 - Top side of reference element (maps to physical top boundary)\n   * 3 - Right side of reference element (maps to physical right boundary)\n   */\n  findBoundaryElements() {\n    const boundaryElements = [];\n    const maxSides = this.meshDimension === \"1D\" ? 2 : 4; // Number of element sides based on mesh dimension\n    for (let sideIndex = 0; sideIndex < maxSides; sideIndex++) {\n      boundaryElements.push([]);\n    }\n\n    if (this.meshDimension === \"1D\") {\n      // Left boundary (element 0, side 0)\n      boundaryElements[0].push([0, 0]);\n\n      // Right boundary (last element, side 1)\n      boundaryElements[1].push([this.numElementsX - 1, 1]);\n    } else if (this.meshDimension === \"2D\") {\n      for (let elementIndexX = 0; elementIndexX < this.numElementsX; elementIndexX++) {\n        for (let elementIndexY = 0; elementIndexY < this.numElementsY; elementIndexY++) {\n          const elementIndex = elementIndexX * this.numElementsY + elementIndexY;\n\n          // Bottom boundary\n          if (elementIndexY === 0) {\n            boundaryElements[0].push([elementIndex, 0]);\n          }\n\n          // Left boundary\n          if (elementIndexX === 0) {\n            boundaryElements[1].push([elementIndex, 1]);\n          }\n\n          // Top boundary\n          if (elementIndexY === this.numElementsY - 1) {\n            boundaryElements[2].push([elementIndex, 2]);\n          }\n\n          // Right boundary\n          if (elementIndexX === this.numElementsX - 1) {\n            boundaryElements[3].push([elementIndex, 3]);\n          }\n        }\n      }\n    }\n\n    debugLog(\"Identified boundary elements by side: \" + JSON.stringify(boundaryElements));\n    return boundaryElements;\n  }\n\n  /**\n   * Function to generate the nodal numbering (NOP) array for a structured mesh\n   * This array represents the connectivity between elements and their corresponding nodes\n   * @param {number} numElementsX - Number of elements along the x-axis\n   * @param {number} [numElementsY] - Number of elements along the y-axis (optional for 1D)\n   * @param {number} totalNodesX - Total number of nodes along the x-axis\n   * @param {number} [totalNodesY] - Total number of nodes along the y-axis (optional for 1D)\n   * @param {string} elementOrder - The order of elements, either 'linear' or 'quadratic'\n   * @returns {array} NOP - A two-dimensional array which represents the element-to-node connectivity for the entire mesh\n   */\n  generateNodalNumbering(numElementsX, numElementsY, totalNodesX, totalNodesY, elementOrder) {\n    let elementIndex = 0;\n    let nop = [];\n\n    if (this.meshDimension === \"1D\") {\n      if (elementOrder === \"linear\") {\n        /**\n         * Linear 1D elements with the following nodes representation:\n         *\n         *   1 --- 2\n         *\n         */\n        for (let elementIndex = 0; elementIndex < numElementsX; elementIndex++) {\n          nop[elementIndex] = [];\n          for (let nodeIndex = 1; nodeIndex <= 2; nodeIndex++) {\n            nop[elementIndex][nodeIndex - 1] = elementIndex + nodeIndex;\n          }\n        }\n      } else if (elementOrder === \"quadratic\") {\n        /**\n         * Quadratic 1D elements with the following nodes representation:\n         *\n         *   1--2--3\n         *\n         */\n        let columnCounter = 0;\n        for (let elementIndex = 0; elementIndex < numElementsX; elementIndex++) {\n          nop[elementIndex] = [];\n          for (let nodeIndex = 1; nodeIndex <= 3; nodeIndex++) {\n            nop[elementIndex][nodeIndex - 1] = elementIndex + nodeIndex + columnCounter;\n          }\n          columnCounter += 1;\n        }\n      }\n    } else if (this.meshDimension === \"2D\") {\n      if (elementOrder === \"linear\") {\n        /**\n         * Linear rectangular elements with the following nodes representation:\n         *\n         *   1 --- 3\n         *   |     |\n         *   0 --- 2\n         *\n         */\n        let rowCounter = 0;\n        let columnCounter = 2;\n        for (let elementIndex = 0; elementIndex < numElementsX * numElementsY; elementIndex++) {\n          rowCounter += 1;\n          nop[elementIndex] = [];\n          nop[elementIndex][0] = elementIndex + columnCounter - 1;\n          nop[elementIndex][1] = elementIndex + columnCounter;\n          nop[elementIndex][2] = elementIndex + columnCounter + numElementsY;\n          nop[elementIndex][3] = elementIndex + columnCounter + numElementsY + 1;\n          if (rowCounter === numElementsY) {\n            columnCounter += 1;\n            rowCounter = 0;\n          }\n        }\n      } else if (elementOrder === \"quadratic\") {\n        /**\n         * Quadratic rectangular elements with the following nodes representation:\n         *\n         *   2--5--8\n         *   |     |\n         *   1  4  7\n         *   |     |\n         *   0--3--6\n         *\n         */\n        for (let elementIndexX = 1; elementIndexX <= numElementsX; elementIndexX++) {\n          for (let elementIndexY = 1; elementIndexY <= numElementsY; elementIndexY++) {\n            nop[elementIndex] = [];\n            for (let nodeIndex1 = 1; nodeIndex1 <= 3; nodeIndex1++) {\n              let nodeIndex2 = 3 * nodeIndex1 - 2;\n              nop[elementIndex][nodeIndex2 - 1] =\n                totalNodesY * (2 * elementIndexX + nodeIndex1 - 3) + 2 * elementIndexY - 1;\n              nop[elementIndex][nodeIndex2] = nop[elementIndex][nodeIndex2 - 1] + 1;\n              nop[elementIndex][nodeIndex2 + 1] = nop[elementIndex][nodeIndex2 - 1] + 2;\n            }\n            elementIndex = elementIndex + 1;\n          }\n        }\n      }\n    }\n\n    return nop;\n  }\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n// Internal imports\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Class to handle thermal boundary conditions application\n */\nexport class ThermalBoundaryConditions {\n  /**\n   * Constructor to initialize the ThermalBoundaryConditions class\n   * @param {object} boundaryConditions - Object containing boundary conditions for the finite element analysis\n   * @param {array} boundaryElements - Array containing elements that belong to each boundary\n   * @param {array} nop - Nodal numbering (NOP) array representing the connectivity between elements and nodes\n   * @param {string} meshDimension - The dimension of the mesh (e.g., \"2D\")\n   * @param {string} elementOrder - The order of elements (e.g., \"linear\", \"quadratic\")\n   */\n  constructor(boundaryConditions, boundaryElements, nop, meshDimension, elementOrder) {\n    this.boundaryConditions = boundaryConditions;\n    this.boundaryElements = boundaryElements;\n    this.nop = nop;\n    this.meshDimension = meshDimension;\n    this.elementOrder = elementOrder;\n  }\n\n  /**\n   * Function to impose constant temperature boundary conditions (Dirichlet type)\n   * @param {array} residualVector - The residual vector to be modified\n   * @param {array} jacobianMatrix - The Jacobian matrix to be modified\n   */\n  imposeConstantTempBoundaryConditions(residualVector, jacobianMatrix) {\n    basicLog(\"Applying constant temperature boundary conditions (Dirichlet type)\");\n    if (this.meshDimension === \"1D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        if (this.boundaryConditions[boundaryKey][0] === \"constantTemp\") {\n          const tempValue = this.boundaryConditions[boundaryKey][1];\n          debugLog(\n            `Boundary ${boundaryKey}: Applying constant temperature of ${tempValue} K (Dirichlet condition)`\n          );\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            if (this.elementOrder === \"linear\") {\n              const boundarySides = {\n                0: [0], // Node at the left side of the reference element\n                1: [1], // Node at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied fixed temperature to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                // Set the residual vector to the ConstantTemp value\n                residualVector[globalNodeIndex] = tempValue;\n                // Set the Jacobian matrix row to zero\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\n                }\n                // Set the diagonal entry of the Jacobian matrix to one\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\n              });\n            } else if (this.elementOrder === \"quadratic\") {\n              const boundarySides = {\n                0: [0], // Node at the left side of the reference element\n                2: [2], // Node at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied fixed temperature to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                // Set the residual vector to the ConstantTemp value\n                residualVector[globalNodeIndex] = tempValue;\n                // Set the Jacobian matrix row to zero\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\n                }\n                // Set the diagonal entry of the Jacobian matrix to one\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\n              });\n            }\n          });\n        }\n      });\n    } else if (this.meshDimension === \"2D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        if (this.boundaryConditions[boundaryKey][0] === \"constantTemp\") {\n          const tempValue = this.boundaryConditions[boundaryKey][1];\n          debugLog(\n            `Boundary ${boundaryKey}: Applying constant temperature of ${tempValue} K (Dirichlet condition)`\n          );\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            if (this.elementOrder === \"linear\") {\n              const boundarySides = {\n                0: [0, 2], // Nodes at the bottom side of the reference element\n                1: [0, 1], // Nodes at the left side of the reference element\n                2: [1, 3], // Nodes at the top side of the reference element\n                3: [2, 3], // Nodes at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied fixed temperature to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                // Set the residual vector to the ConstantTemp value\n                residualVector[globalNodeIndex] = tempValue;\n                // Set the Jacobian matrix row to zero\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\n                }\n                // Set the diagonal entry of the Jacobian matrix to one\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\n              });\n            } else if (this.elementOrder === \"quadratic\") {\n              const boundarySides = {\n                0: [0, 3, 6], // Nodes at the bottom side of the reference element\n                1: [0, 1, 2], // Nodes at the left side of the reference element\n                2: [2, 5, 8], // Nodes at the top side of the reference element\n                3: [6, 7, 8], // Nodes at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied fixed temperature to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                // Set the residual vector to the ConstantTemp value\n                residualVector[globalNodeIndex] = tempValue;\n                // Set the Jacobian matrix row to zero\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\n                }\n                // Set the diagonal entry of the Jacobian matrix to one\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\n              });\n            }\n          });\n        }\n      });\n    }\n  }\n\n  /**\n   * Function to impose convection boundary conditions (Robin type)\n   * @param {array} residualVector - The residual vector to be modified\n   * @param {array} jacobianMatrix - The Jacobian matrix to be modified\n   * @param {array} gaussPoints - Array of Gauss points for numerical integration\n   * @param {array} gaussWeights - Array of Gauss weights for numerical integration\n   * @param {array} nodesXCoordinates - Array of x-coordinates of nodes\n   * @param {array} nodesYCoordinates - Array of y-coordinates of nodes\n   * @param {object} basisFunctionsData - Object containing basis functions and their derivatives\n   */\n  imposeConvectionBoundaryConditions(\n    residualVector,\n    jacobianMatrix,\n    gaussPoints,\n    gaussWeights,\n    nodesXCoordinates,\n    nodesYCoordinates,\n    basisFunctionsData\n  ) {\n    basicLog(\"Applying convection boundary conditions (Robin type)\");\n    // Extract convection parameters from boundary conditions\n    let convectionHeatTranfCoeff = [];\n    let convectionExtTemp = [];\n    Object.keys(this.boundaryConditions).forEach((key) => {\n      const boundaryCondition = this.boundaryConditions[key];\n      if (boundaryCondition[0] === \"convection\") {\n        convectionHeatTranfCoeff[key] = boundaryCondition[1];\n        convectionExtTemp[key] = boundaryCondition[2];\n      }\n    });\n\n    if (this.meshDimension === \"1D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        if (this.boundaryConditions[boundaryKey][0] === \"convection\") {\n          const convectionCoeff = convectionHeatTranfCoeff[boundaryKey];\n          const extTemp = convectionExtTemp[boundaryKey];\n          debugLog(\n            `Boundary ${boundaryKey}: Applying convection with heat transfer coefficient h=${convectionCoeff} W/(m²·K) and external temperature T∞=${extTemp} K`\n          );\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            let nodeIndex;\n            if (this.elementOrder === \"linear\") {\n              if (side === 0) {\n                // Node at the left side of the reference element\n                nodeIndex = 0;\n              } else {\n                // Node at the right side of the reference element\n                nodeIndex = 1;\n              }\n            } else if (this.elementOrder === \"quadratic\") {\n              if (side === 0) {\n                // Node at the left side of the reference element\n                nodeIndex = 0;\n              } else {\n                // Node at the right side of the reference element\n                nodeIndex = 2;\n              }\n            }\n\n            const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n            debugLog(\n              `  - Applied convection boundary condition to node ${globalNodeIndex + 1} (element ${\n                elementIndex + 1\n              }, local node ${nodeIndex + 1})`\n            );\n            residualVector[globalNodeIndex] += -convectionCoeff * extTemp;\n            jacobianMatrix[globalNodeIndex][globalNodeIndex] += convectionCoeff;\n          });\n        }\n      });\n    } else if (this.meshDimension === \"2D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        if (this.boundaryConditions[boundaryKey][0] === \"convection\") {\n          const convectionCoeff = convectionHeatTranfCoeff[boundaryKey];\n          const extTemp = convectionExtTemp[boundaryKey];\n          debugLog(\n            `Boundary ${boundaryKey}: Applying convection with heat transfer coefficient h=${convectionCoeff} W/(m²·K) and external temperature T∞=${extTemp} K`\n          );\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            if (this.elementOrder === \"linear\") {\n              let gaussPoint1, gaussPoint2, firstNodeIndex, lastNodeIndex, nodeIncrement;\n              if (side === 0) {\n                // Nodes at the bottom side of the reference element\n                gaussPoint1 = gaussPoints[0];\n                gaussPoint2 = 0;\n                firstNodeIndex = 0;\n                lastNodeIndex = 3;\n                nodeIncrement = 2;\n              } else if (side === 1) {\n                // Nodes at the left side of the reference element\n                gaussPoint1 = 0;\n                gaussPoint2 = gaussPoints[0];\n                firstNodeIndex = 0;\n                lastNodeIndex = 2;\n                nodeIncrement = 1;\n              } else if (side === 2) {\n                // Nodes at the top side of the reference element\n                gaussPoint1 = gaussPoints[0];\n                gaussPoint2 = 1;\n                firstNodeIndex = 1;\n                lastNodeIndex = 4;\n                nodeIncrement = 2;\n              } else if (side === 3) {\n                // Nodes at the right side of the reference element\n                gaussPoint1 = 1;\n                gaussPoint2 = gaussPoints[0];\n                firstNodeIndex = 2;\n                lastNodeIndex = 4;\n                nodeIncrement = 1;\n              }\n\n              let basisFunctionsAndDerivatives = basisFunctionsData.getBasisFunctions(\n                gaussPoint1,\n                gaussPoint2\n              );\n              let basisFunction = basisFunctionsAndDerivatives.basisFunction;\n              let basisFunctionDerivKsi = basisFunctionsAndDerivatives.basisFunctionDerivKsi;\n              let basisFunctionDerivEta = basisFunctionsAndDerivatives.basisFunctionDerivEta;\n\n              let ksiDerivX = 0;\n              let ksiDerivY = 0;\n              let etaDerivX = 0;\n              let etaDerivY = 0;\n              const numNodes = this.nop[elementIndex].length;\n              for (let nodeIndex = 0; nodeIndex < numNodes; nodeIndex++) {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n\n                // For boundaries along Ksi (horizontal), use Ksi derivatives\n                if (side === 0 || side === 2) {\n                  ksiDerivX += nodesXCoordinates[globalNodeIndex] * basisFunctionDerivKsi[nodeIndex];\n                  ksiDerivY += nodesYCoordinates[globalNodeIndex] * basisFunctionDerivKsi[nodeIndex];\n                }\n                // For boundaries along Eta (vertical), use Eta derivatives\n                else if (side === 1 || side === 3) {\n                  etaDerivX += nodesXCoordinates[globalNodeIndex] * basisFunctionDerivEta[nodeIndex];\n                  etaDerivY += nodesYCoordinates[globalNodeIndex] * basisFunctionDerivEta[nodeIndex];\n                }\n              }\n\n              // Compute the length of tangent vector\n              const tangentVectorLength =\n                side === 0 || side === 2\n                  ? Math.sqrt(ksiDerivX ** 2 + ksiDerivY ** 2)\n                  : Math.sqrt(etaDerivX ** 2 + etaDerivY ** 2);\n\n              for (\n                let localNodeIndex = firstNodeIndex;\n                localNodeIndex < lastNodeIndex;\n                localNodeIndex += nodeIncrement\n              ) {\n                let globalNodeIndex = this.nop[elementIndex][localNodeIndex] - 1;\n                debugLog(\n                  `  - Applied convection boundary condition to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${localNodeIndex + 1})`\n                );\n\n                // Apply boundary condition with proper Jacobian for all sides\n                residualVector[globalNodeIndex] +=\n                  -gaussWeights[0] * tangentVectorLength * basisFunction[localNodeIndex] * convectionCoeff * extTemp;\n\n                for (\n                  let localNodeIndex2 = firstNodeIndex;\n                  localNodeIndex2 < lastNodeIndex;\n                  localNodeIndex2 += nodeIncrement\n                ) {\n                  let globalNodeIndex2 = this.nop[elementIndex][localNodeIndex2] - 1;\n                  jacobianMatrix[globalNodeIndex][globalNodeIndex2] +=\n                    -gaussWeights[0] *\n                    tangentVectorLength *\n                    basisFunction[localNodeIndex] *\n                    basisFunction[localNodeIndex2] *\n                    convectionCoeff;\n                }\n              }\n            } else if (this.elementOrder === \"quadratic\") {\n              for (let gaussPointIndex = 0; gaussPointIndex < 3; gaussPointIndex++) {\n                let gaussPoint1, gaussPoint2, firstNodeIndex, lastNodeIndex, nodeIncrement;\n                if (side === 0) {\n                  // Nodes at the bottom side of the reference element\n                  gaussPoint1 = gaussPoints[gaussPointIndex];\n                  gaussPoint2 = 0;\n                  firstNodeIndex = 0;\n                  lastNodeIndex = 7;\n                  nodeIncrement = 3;\n                } else if (side === 1) {\n                  // Nodes at the left side of the reference element\n                  gaussPoint1 = 0;\n                  gaussPoint2 = gaussPoints[gaussPointIndex];\n                  firstNodeIndex = 0;\n                  lastNodeIndex = 3;\n                  nodeIncrement = 1;\n                } else if (side === 2) {\n                  // Nodes at the top side of the reference element\n                  gaussPoint1 = gaussPoints[gaussPointIndex];\n                  gaussPoint2 = 1;\n                  firstNodeIndex = 2;\n                  lastNodeIndex = 9;\n                  nodeIncrement = 3;\n                } else if (side === 3) {\n                  // Nodes at the right side of the reference element\n                  gaussPoint1 = 1;\n                  gaussPoint2 = gaussPoints[gaussPointIndex];\n                  firstNodeIndex = 6;\n                  lastNodeIndex = 9;\n                  nodeIncrement = 1;\n                }\n                let basisFunctionsAndDerivatives = basisFunctionsData.getBasisFunctions(\n                  gaussPoint1,\n                  gaussPoint2\n                );\n                let basisFunction = basisFunctionsAndDerivatives.basisFunction;\n                let basisFunctionDerivKsi = basisFunctionsAndDerivatives.basisFunctionDerivKsi;\n                let basisFunctionDerivEta = basisFunctionsAndDerivatives.basisFunctionDerivEta;\n\n                let ksiDerivX = 0;\n                let ksiDerivY = 0;\n                let etaDerivX = 0;\n                let etaDerivY = 0;\n                const numNodes = this.nop[elementIndex].length;\n                for (let nodeIndex = 0; nodeIndex < numNodes; nodeIndex++) {\n                  const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n\n                  // For boundaries along Ksi (horizontal), use Ksi derivatives\n                  if (side === 0 || side === 2) {\n                    ksiDerivX += nodesXCoordinates[globalNodeIndex] * basisFunctionDerivKsi[nodeIndex];\n                    ksiDerivY += nodesYCoordinates[globalNodeIndex] * basisFunctionDerivKsi[nodeIndex];\n                  }\n                  // For boundaries along Eta (vertical), use Eta derivatives\n                  else if (side === 1 || side === 3) {\n                    etaDerivX += nodesXCoordinates[globalNodeIndex] * basisFunctionDerivEta[nodeIndex];\n                    etaDerivY += nodesYCoordinates[globalNodeIndex] * basisFunctionDerivEta[nodeIndex];\n                  }\n                }\n\n                // Compute the length of tangent vector\n                const tangentVectorLength =\n                  side === 0 || side === 2\n                    ? Math.sqrt(ksiDerivX ** 2 + ksiDerivY ** 2)\n                    : Math.sqrt(etaDerivX ** 2 + etaDerivY ** 2);\n\n                for (\n                  let localNodeIndex = firstNodeIndex;\n                  localNodeIndex < lastNodeIndex;\n                  localNodeIndex += nodeIncrement\n                ) {\n                  let globalNodeIndex = this.nop[elementIndex][localNodeIndex] - 1;\n                  debugLog(\n                    `  - Applied convection boundary condition to node ${globalNodeIndex + 1} (element ${\n                      elementIndex + 1\n                    }, local node ${localNodeIndex + 1})`\n                  );\n\n                  // Apply boundary condition with proper Jacobian for all sides\n                  residualVector[globalNodeIndex] +=\n                    -gaussWeights[gaussPointIndex] *\n                    tangentVectorLength *\n                    basisFunction[localNodeIndex] *\n                    convectionCoeff *\n                    extTemp;\n\n                  for (\n                    let localNodeIndex2 = firstNodeIndex;\n                    localNodeIndex2 < lastNodeIndex;\n                    localNodeIndex2 += nodeIncrement\n                  ) {\n                    let globalNodeIndex2 = this.nop[elementIndex][localNodeIndex2] - 1;\n                    jacobianMatrix[globalNodeIndex][globalNodeIndex2] +=\n                      -gaussWeights[gaussPointIndex] *\n                      tangentVectorLength *\n                      basisFunction[localNodeIndex] *\n                      basisFunction[localNodeIndex2] *\n                      convectionCoeff;\n                  }\n                }\n              }\n            }\n          });\n        }\n      });\n    }\n  }\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n// Internal imports\nimport { jacobiMethod } from \"./methods/jacobiMethodScript.js\";\nimport { assembleSolidHeatTransferMat } from \"./solvers/solidHeatTransferScript.js\";\nimport { basicLog, debugLog, errorLog } from \"./utilities/loggingScript.js\";\n\n/**\n * Class to implement finite element analysis in JavaScript\n * @param {string} solverConfig - Parameter specifying the type of solver\n * @param {object} meshConfig - Object containing computational mesh details\n * @param {object} boundaryConditions - Object containing boundary conditions for the finite element analysis\n * @returns {object} An object containing the solution vector and additional mesh information\n */\nexport class FEAScriptModel {\n  constructor() {\n    this.solverConfig = null;\n    this.meshConfig = {};\n    this.boundaryConditions = {};\n    this.solverMethod = \"lusolve\"; // Default solver method\n    basicLog(\"FEAScriptModel instance created\");\n  }\n\n  setSolverConfig(solverConfig) {\n    this.solverConfig = solverConfig;\n    debugLog(`Solver config set to: ${solverConfig}`);\n  }\n\n  setMeshConfig(meshConfig) {\n    this.meshConfig = meshConfig;\n    debugLog(\n      `Mesh config set with dimensions: ${meshConfig.meshDimension}`\n    );\n  }\n\n  addBoundaryCondition(boundaryKey, condition) {\n    this.boundaryConditions[boundaryKey] = condition;\n    debugLog(`Boundary condition added for boundary: ${boundaryKey}, type: ${condition[0]}`);\n  }\n\n  setSolverMethod(solverMethod) {\n    this.solverMethod = solverMethod;\n    debugLog(`Solver method set to: ${solverMethod}`);\n  }\n\n  solve() {\n    if (!this.solverConfig || !this.meshConfig || !this.boundaryConditions) {\n      const error = \"Solver config, mesh config, and boundary conditions must be set before solving.\";\n      console.error(error);\n      throw new Error(error);\n    }\n\n    let jacobianMatrix = [];\n    let residualVector = [];\n    let solutionVector = [];\n    let nodesCoordinates = {};\n\n    // Assembly matrices\n    basicLog(\"Beginning matrix assembly...\");\n    console.time(\"assemblyMatrices\");\n    if (this.solverConfig === \"solidHeatTransferScript\") {\n      basicLog(`Using solver: ${this.solverConfig}`);\n      ({ jacobianMatrix, residualVector, nodesCoordinates } = assembleSolidHeatTransferMat(\n        this.meshConfig,\n        this.boundaryConditions\n      ));\n    }\n    console.timeEnd(\"assemblyMatrices\");\n    basicLog(\"Matrix assembly completed\");\n\n    // System solving\n    basicLog(`Solving system using ${this.solverMethod}...`);\n    console.time(\"systemSolving\");\n    if (this.solverMethod === \"lusolve\") {\n      solutionVector = math.lusolve(jacobianMatrix, residualVector);\n    } else if (this.solverMethod === \"jacobi\") {\n      // Create initial guess of zeros\n      const initialGuess = new Array(residualVector.length).fill(0);\n      // Call Jacobi method with desired max iterations and tolerance\n      const jacobiResult = jacobiMethod(jacobianMatrix, residualVector, initialGuess, 1000, 1e-6);\n\n      // Log convergence information\n      if (jacobiResult.converged) {\n        debugLog(`Jacobi method converged in ${jacobiResult.iterations} iterations`);\n      } else {\n        debugLog(`Jacobi method did not converge after ${jacobiResult.iterations} iterations`);\n      }\n\n      solutionVector = jacobiResult.solution;\n    }\n    console.timeEnd(\"systemSolving\");\n    basicLog(\"System solved successfully\");\n\n    return { solutionVector, nodesCoordinates };\n  }\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n// Internal imports\nimport { numericalIntegration } from \"../methods/numericalIntegrationScript.js\";\nimport { basisFunctions } from \"../mesh/basisFunctionsScript.js\";\nimport { meshGeneration } from \"../mesh/meshGenerationScript.js\";\nimport { ThermalBoundaryConditions } from \"./thermalBoundaryConditionsScript.js\";\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Function to assemble the solid heat transfer matrix\n * @param {object} meshConfig - Object containing computational mesh details\n * @param {object} boundaryConditions - Object containing boundary conditions for the finite element analysis\n * @returns {object} An object containing:\n *  - jacobianMatrix: The assembled Jacobian matrix\n *  - residualVector: The assembled residual vector\n *  - nodesCoordinates: Object containing x and y coordinates of nodes\n */\nexport function assembleSolidHeatTransferMat(meshConfig, boundaryConditions) {\n  basicLog(\"Starting solid heat transfer matrix assembly...\");\n\n  // Extract mesh details from the configuration object\n  const {\n    meshDimension, // The dimension of the mesh\n    numElementsX, // Number of elements in x-direction\n    numElementsY, // Number of elements in y-direction (only for 2D)\n    maxX, // Max x-coordinate (m) of the domain\n    maxY, // Max y-coordinate (m) of the domain (only for 2D)\n    elementOrder, // The order of elements\n    parsedMesh, // The pre-parsed mesh data (if available)\n  } = meshConfig;\n\n  // Create a new instance of the meshGeneration class\n  debugLog(\"Generating mesh...\");\n  const meshGenerationData = new meshGeneration({\n    numElementsX,\n    numElementsY,\n    maxX,\n    maxY,\n    meshDimension,\n    elementOrder,\n    parsedMesh, // Pass the parsed mesh to the mesh generator\n  });\n\n  // Generate the mesh\n  const nodesCoordinatesAndNumbering = meshGenerationData.generateMesh();\n\n  // Extract nodes coordinates and nodal numbering (NOP) from the mesh data\n  let nodesXCoordinates = nodesCoordinatesAndNumbering.nodesXCoordinates;\n  let nodesYCoordinates = nodesCoordinatesAndNumbering.nodesYCoordinates;\n  let totalNodesX = nodesCoordinatesAndNumbering.totalNodesX;\n  let totalNodesY = nodesCoordinatesAndNumbering.totalNodesY;\n  let nop = nodesCoordinatesAndNumbering.nodalNumbering;\n  let boundaryElements = nodesCoordinatesAndNumbering.boundaryElements;\n\n  // Check the mesh type\n  const isParsedMesh = parsedMesh !== undefined && parsedMesh !== null;\n\n  // Calculate totalElements and totalNodes based on mesh type\n  let totalElements, totalNodes;\n\n  if (isParsedMesh) {\n    totalElements = nop.length; // Number of elements is the length of the nodal numbering array\n    totalNodes = nodesXCoordinates.length; // Number of nodes is the length of the coordinates array\n\n    // Debug log for mesh size\n    debugLog(`Using parsed mesh with ${totalElements} elements and ${totalNodes} nodes`);\n  } else {\n    // For structured mesh, calculate based on dimensions\n    totalElements = numElementsX * (meshDimension === \"2D\" ? numElementsY : 1);\n    totalNodes = totalNodesX * (meshDimension === \"2D\" ? totalNodesY : 1);\n    // Debug log for mesh size\n    debugLog(`Using mesh generated from geometry with ${totalElements} elements and ${totalNodes} nodes`);\n  }\n\n  // Initialize variables for matrix assembly\n  let localToGlobalMap = []; // Maps local element node indices to global mesh node indices\n  let gaussPoints = []; // Gauss points\n  let gaussWeights = []; // Gauss weights\n  let basisFunction = []; // Basis functions\n  let basisFunctionDerivKsi = []; // Derivatives of basis functions with respect to ksi\n  let basisFunctionDerivEta = []; // Derivatives of basis functions with respect to eta (only for 2D)\n  let basisFunctionDerivX = []; // The x-derivative of the basis function\n  let basisFunctionDerivY = []; // The y-derivative of the basis function (only for 2D)\n  let residualVector = []; // Galerkin residuals\n  let jacobianMatrix = []; // Jacobian matrix\n  let xCoordinates; // x-coordinate (physical coordinates)\n  let yCoordinates; // y-coordinate (physical coordinates) (only for 2D)\n  let ksiDerivX; // ksi-derivative of xCoordinates\n  let etaDerivX; // eta-derivative of xCoordinates (ksi and eta are natural coordinates that vary within a reference element) (only for 2D)\n  let ksiDerivY; // ksi-derivative of yCoordinates (only for 2D)\n  let etaDerivY; // eta-derivative of yCoordinates (only for 2D)\n  let detJacobian; // The jacobian of the isoparametric mapping\n\n  // Initialize jacobianMatrix and residualVector arrays\n  for (let nodeIndex = 0; nodeIndex < totalNodes; nodeIndex++) {\n    residualVector[nodeIndex] = 0;\n    jacobianMatrix.push([]);\n    for (let colIndex = 0; colIndex < totalNodes; colIndex++) {\n      jacobianMatrix[nodeIndex][colIndex] = 0;\n    }\n  }\n\n  // Initialize the basisFunctions class\n  const basisFunctionsData = new basisFunctions({\n    meshDimension,\n    elementOrder,\n  });\n\n  // Initialize the numericalIntegration class\n  const numIntegrationData = new numericalIntegration({\n    meshDimension,\n    elementOrder,\n  });\n\n  // Calculate Gauss points and weights\n  let gaussPointsAndWeights = numIntegrationData.getGaussPointsAndWeights();\n  gaussPoints = gaussPointsAndWeights.gaussPoints;\n  gaussWeights = gaussPointsAndWeights.gaussWeights;\n\n  // Determine the number of nodes in the reference element based on the first element in the nop array\n  const numNodes = nop[0].length;\n\n  // Matrix assembly\n  for (let elementIndex = 0; elementIndex < totalElements; elementIndex++) {\n    for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n      // Subtract 1 from nop in order to start numbering from 0\n      localToGlobalMap[localNodeIndex] = nop[elementIndex][localNodeIndex] - 1;\n    }\n\n    // Loop over Gauss points\n    for (let gaussPointIndex1 = 0; gaussPointIndex1 < gaussPoints.length; gaussPointIndex1++) {\n      // 1D solid heat transfer\n      if (meshDimension === \"1D\") {\n        let basisFunctionsAndDerivatives = basisFunctionsData.getBasisFunctions(\n          gaussPoints[gaussPointIndex1]\n        );\n        basisFunction = basisFunctionsAndDerivatives.basisFunction;\n        basisFunctionDerivKsi = basisFunctionsAndDerivatives.basisFunctionDerivKsi;\n        xCoordinates = 0;\n        ksiDerivX = 0;\n        detJacobian = 0;\n\n        // Isoparametric mapping\n        for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n          xCoordinates += nodesXCoordinates[localToGlobalMap[localNodeIndex]] * basisFunction[localNodeIndex];\n          ksiDerivX +=\n            nodesXCoordinates[localToGlobalMap[localNodeIndex]] * basisFunctionDerivKsi[localNodeIndex];\n          detJacobian = ksiDerivX;\n        }\n\n        // Compute x-derivative of basis functions\n        for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n          basisFunctionDerivX[localNodeIndex] = basisFunctionDerivKsi[localNodeIndex] / detJacobian; // The x-derivative of the n basis function\n        }\n\n        // Computation of Galerkin's residuals and Jacobian matrix\n        for (let localNodeIndex1 = 0; localNodeIndex1 < numNodes; localNodeIndex1++) {\n          let localToGlobalMap1 = localToGlobalMap[localNodeIndex1];\n          // residualVector is zero for this case\n\n          for (let localNodeIndex2 = 0; localNodeIndex2 < numNodes; localNodeIndex2++) {\n            let localToGlobalMap2 = localToGlobalMap[localNodeIndex2];\n            jacobianMatrix[localToGlobalMap1][localToGlobalMap2] +=\n              -gaussWeights[gaussPointIndex1] *\n              detJacobian *\n              (basisFunctionDerivX[localNodeIndex1] * basisFunctionDerivX[localNodeIndex2]);\n          }\n        }\n        // 2D solid heat transfer\n      } else if (meshDimension === \"2D\") {\n        for (let gaussPointIndex2 = 0; gaussPointIndex2 < gaussPoints.length; gaussPointIndex2++) {\n          // Initialise variables for isoparametric mapping\n          let basisFunctionsAndDerivatives = basisFunctionsData.getBasisFunctions(\n            gaussPoints[gaussPointIndex1],\n            gaussPoints[gaussPointIndex2]\n          );\n          basisFunction = basisFunctionsAndDerivatives.basisFunction;\n          basisFunctionDerivKsi = basisFunctionsAndDerivatives.basisFunctionDerivKsi;\n          basisFunctionDerivEta = basisFunctionsAndDerivatives.basisFunctionDerivEta;\n          xCoordinates = 0;\n          yCoordinates = 0;\n          ksiDerivX = 0;\n          etaDerivX = 0;\n          ksiDerivY = 0;\n          etaDerivY = 0;\n          detJacobian = 0;\n\n          // Isoparametric mapping\n          for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n            xCoordinates +=\n              nodesXCoordinates[localToGlobalMap[localNodeIndex]] * basisFunction[localNodeIndex];\n            yCoordinates +=\n              nodesYCoordinates[localToGlobalMap[localNodeIndex]] * basisFunction[localNodeIndex];\n            ksiDerivX +=\n              nodesXCoordinates[localToGlobalMap[localNodeIndex]] * basisFunctionDerivKsi[localNodeIndex];\n            etaDerivX +=\n              nodesXCoordinates[localToGlobalMap[localNodeIndex]] * basisFunctionDerivEta[localNodeIndex];\n            ksiDerivY +=\n              nodesYCoordinates[localToGlobalMap[localNodeIndex]] * basisFunctionDerivKsi[localNodeIndex];\n            etaDerivY +=\n              nodesYCoordinates[localToGlobalMap[localNodeIndex]] * basisFunctionDerivEta[localNodeIndex];\n            detJacobian = meshDimension === \"2D\" ? ksiDerivX * etaDerivY - etaDerivX * ksiDerivY : ksiDerivX;\n          }\n\n          // Compute x-derivative and y-derivative of basis functions\n          for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n            basisFunctionDerivX[localNodeIndex] =\n              (etaDerivY * basisFunctionDerivKsi[localNodeIndex] -\n                ksiDerivY * basisFunctionDerivEta[localNodeIndex]) /\n              detJacobian; // The x-derivative of the n basis function\n            basisFunctionDerivY[localNodeIndex] =\n              (ksiDerivX * basisFunctionDerivEta[localNodeIndex] -\n                etaDerivX * basisFunctionDerivKsi[localNodeIndex]) /\n              detJacobian; // The y-derivative of the n basis function\n          }\n\n          // Computation of Galerkin's residuals and Jacobian matrix\n          for (let localNodeIndex1 = 0; localNodeIndex1 < numNodes; localNodeIndex1++) {\n            let localToGlobalMap1 = localToGlobalMap[localNodeIndex1];\n            // residualVector is zero for this case\n\n            for (let localNodeIndex2 = 0; localNodeIndex2 < numNodes; localNodeIndex2++) {\n              let localToGlobalMap2 = localToGlobalMap[localNodeIndex2];\n              jacobianMatrix[localToGlobalMap1][localToGlobalMap2] +=\n                -gaussWeights[gaussPointIndex1] *\n                gaussWeights[gaussPointIndex2] *\n                detJacobian *\n                (basisFunctionDerivX[localNodeIndex1] * basisFunctionDerivX[localNodeIndex2] +\n                  basisFunctionDerivY[localNodeIndex1] * basisFunctionDerivY[localNodeIndex2]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Create an instance of ThermalBoundaryConditions\n  debugLog(\"Applying thermal boundary conditions...\");\n  const thermalBoundaryConditions = new ThermalBoundaryConditions(\n    boundaryConditions,\n    boundaryElements,\n    nop,\n    meshDimension,\n    elementOrder\n  );\n\n  // Impose Convection boundary conditions\n  thermalBoundaryConditions.imposeConvectionBoundaryConditions(\n    residualVector,\n    jacobianMatrix,\n    gaussPoints,\n    gaussWeights,\n    nodesXCoordinates,\n    nodesYCoordinates,\n    basisFunctionsData\n  );\n  debugLog(\"Convection boundary conditions applied\");\n\n  // Impose ConstantTemp boundary conditions\n  thermalBoundaryConditions.imposeConstantTempBoundaryConditions(residualVector, jacobianMatrix);\n  debugLog(\"Constant temperature boundary conditions applied\");\n\n  basicLog(\"Solid heat transfer matrix assembly completed\");\n\n  return {\n    jacobianMatrix,\n    residualVector,\n    nodesCoordinates: {\n      nodesXCoordinates,\n      nodesYCoordinates,\n    },\n  };\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\nimport * as Comlink from \"../vendor/comlink.mjs\";\nimport { WebGPUComputeEngine } from \"../utilities/webgpuComputeEngine.js\";\n\n/**\n * Function to solve a system of linear equations using the Jacobi iterative method\n * This version uses the WebGPU compute engine for maximum performance and reusability\n * @param {array} A - The coefficient matrix (must be square)\n * @param {array} b - The right-hand side vector\n * @param {array} x0 - Initial guess for solution vector\n * @param {number} [maxIterations=100] - Maximum number of iterations\n * @param {number} [tolerance=1e-7] - Convergence tolerance\n * @param {boolean} [useFloat64=true] - Whether to use Float64Array for higher precision\n * @returns {object} An object containing:\n *  - solution: The solution vector\n *  - iterations: The number of iterations performed\n *  - converged: Boolean indicating whether the method converged\n */\nexport async function jacobiMethod(A, b, x0, maxIterations = 100, tolerance = 1e-7, useFloat64 = true) {\n  // Use the dedicated worker file\n  const worker = new Worker('./workers/webgpuJacobiWorker.js', { type: 'module' });\n  const jacobiWorker = Comlink.wrap(worker);\n\n  try {\n    const result = await jacobiWorker.jacobiMethod(A, b, x0, maxIterations, tolerance, useFloat64);\n    return result;\n  } catch (error) {\n    console.error(\"Error in WebGPU Jacobi method:\", error);\n    throw error;\n  } finally {\n    worker.terminate();\n  }\n}","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n// External imports\nimport * as Comlink from \"../vendor/comlink.mjs\";\n\n// Internal imports\nimport { basicLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Class to facilitate communication with web workers for FEAScript operations\n */\nexport class FEAScriptWorker {\n  /**\n   * Constructor to initialize the FEAScriptWorker class\n   * Sets up the worker and initializes the workerWrapper.\n   */\n  constructor() {\n    this.worker = null;\n    this.feaWorker = null;\n    this.isReady = false;\n\n    this._initWorker();\n  }\n\n  /**\n   * Function to initialize the web worker and wrap it using Comlink.\n   * @private\n   * @throws Will throw an error if the worker fails to initialize.\n   */\n  async _initWorker() {\n    try {\n      this.worker = new Worker(new URL(\"./wrapperScript.js\", import.meta.url), {\n        type: \"module\",\n      });\n\n      this.worker.onerror = (event) => {\n        console.error(\"FEAScriptWorker: Worker error:\", event);\n      };\n      const workerWrapper = Comlink.wrap(this.worker);\n\n      this.feaWorker = await new workerWrapper();\n\n      this.isReady = true;\n    } catch (error) {\n      console.error(\"Failed to initialize worker\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Function to ensure that the worker is ready before performing any operations.\n   * @private\n   * @returns {Promise<void>} Resolves when the worker is ready.\n   * @throws Will throw an error if the worker is not ready within the timeout period.\n   */\n  async _ensureReady() {\n    if (this.isReady) return Promise.resolve();\n\n    return new Promise((resolve, reject) => {\n      let attempts = 0;\n      const maxAttempts = 50; // 5 seconds max\n\n      const checkReady = () => {\n        attempts++;\n        if (this.isReady) {\n          resolve();\n        } else if (attempts >= maxAttempts) {\n          reject(new Error(\"Timeout waiting for worker to be ready\"));\n        } else {\n          setTimeout(checkReady, 1000);\n        }\n      };\n      checkReady();\n    });\n  }\n\n  /**\n   * Function to set the solver configuration in the worker.\n   * @param {string} solverConfig - The solver configuration to set.\n   * @returns {Promise<boolean>} Resolves when the configuration is set.\n   */\n  async setSolverConfig(solverConfig) {\n    await this._ensureReady();\n    basicLog(`FEAScriptWorker: Setting solver config to: ${solverConfig}`);\n    return this.feaWorker.setSolverConfig(solverConfig);\n  }\n\n  /**\n   * Sets the mesh configuration in the worker.\n   * @param {object} meshConfig - The mesh configuration to set.\n   * @returns {Promise<boolean>} Resolves when the configuration is set.\n   */\n  async setMeshConfig(meshConfig) {\n    await this._ensureReady();\n    basicLog(`FEAScriptWorker: Setting mesh config`);\n    return this.feaWorker.setMeshConfig(meshConfig);\n  }\n\n  /**\n   * Adds a boundary condition to the worker.\n   * @param {string} boundaryKey - The key identifying the boundary.\n   * @param {array} condition - The boundary condition to add.\n   * @returns {Promise<boolean>} Resolves when the boundary condition is added.\n   */\n  async addBoundaryCondition(boundaryKey, condition) {\n    await this._ensureReady();\n    basicLog(`FEAScriptWorker: Adding boundary condition for boundary: ${boundaryKey}`);\n    return this.feaWorker.addBoundaryCondition(boundaryKey, condition);\n  }\n\n  /**\n   * Sets the solver method in the worker.\n   * @param {string} solverMethod - The solver method to set.\n   * @returns {Promise<boolean>} Resolves when the solver method is set.\n   */\n  async setSolverMethod(solverMethod) {\n    await this._ensureReady();\n    basicLog(`FEAScriptWorker: Setting solver method to: ${solverMethod}`);\n    return this.feaWorker.setSolverMethod(solverMethod);\n  }\n\n  /**\n   * Requests the worker to solve the problem.\n   * @returns {Promise<object>} Resolves with the solution result.\n   */\n  async solve() {\n    await this._ensureReady();\n    basicLog(\"FEAScriptWorker: Requesting solution from worker...\");\n\n    const startTime = performance.now();\n    const result = await this.feaWorker.solve();\n    const endTime = performance.now();\n\n    basicLog(`FEAScriptWorker: Solution completed in ${((endTime - startTime) / 1000).toFixed(2)}s`);\n    return result;\n  }\n\n  /**\n   * Retrieves model information from the worker.\n   * @returns {Promise<object>} Resolves with the model information.\n   */\n  async getModelInfo() {\n    await this._ensureReady();\n    return this.feaWorker.getModelInfo();\n  }\n\n  /**\n   * Sends a ping request to the worker to check its availability.\n   * @returns {Promise<boolean>} Resolves if the worker responds.\n   */\n  async ping() {\n    await this._ensureReady();\n    return this.feaWorker.ping();\n  }\n\n  /**\n   * Terminates the worker and cleans up resources.\n   */\n  terminate() {\n    if (this.worker) {\n      this.worker.terminate();\n      this.worker = null;\n      this.feaWorker = null;\n      this.isReady = false;\n    }\n  }\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n// Internal imports\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Function to import mesh data from Gmsh format containing quadrilateral and triangular elements\n * @param {File} file - The Gmsh file to be parsed (.msh version 4.1)\n * @returns {object} The parsed mesh data including node coordinates, element connectivity, and boundary conditions\n */\nconst importGmshQuadTri = async (file) => {\n  let result = {\n    nodesXCoordinates: [],\n    nodesYCoordinates: [],\n    nodalNumbering: {\n      quadElements: [],\n      triangleElements: [],\n    },\n    boundaryElements: [],\n    boundaryConditions: [],\n    boundaryNodePairs: {}, // Store boundary node pairs for processing in meshGenerationScript\n    gmshV: 0,\n    ascii: false,\n    fltBytes: \"8\",\n    totalNodesX: 0,\n    totalNodesY: 0,\n    physicalPropMap: [],\n    elementTypes: {},\n  };\n\n  let content = await file.text();\n  let lines = content\n    .split(\"\\n\")\n    .map((line) => line.trim())\n    .filter((line) => line !== \"\" && line !== \" \");\n\n  let section = \"\";\n  let lineIndex = 0;\n\n  let nodeEntityBlocks = 0;\n  let totalNodes = 0;\n  let nodeBlocksProcessed = 0;\n  let currentNodeBlock = { numNodes: 0 };\n  let nodeTagsCollected = 0;\n  let nodeTags = [];\n  let nodeCoordinatesCollected = 0;\n\n  let elementEntityBlocks = 0;\n  let totalElements = 0;\n  let elementBlocksProcessed = 0;\n  let currentElementBlock = {\n    dim: 0,\n    tag: 0,\n    elementType: 0,\n    numElements: 0,\n  };\n  let elementsProcessedInBlock = 0;\n\n  let boundaryElementsByTag = {};\n\n  while (lineIndex < lines.length) {\n    const line = lines[lineIndex];\n\n    if (line === \"$MeshFormat\") {\n      section = \"meshFormat\";\n      lineIndex++;\n      continue;\n    } else if (line === \"$EndMeshFormat\") {\n      section = \"\";\n      lineIndex++;\n      continue;\n    } else if (line === \"$PhysicalNames\") {\n      section = \"physicalNames\";\n      lineIndex++;\n      continue;\n    } else if (line === \"$EndPhysicalNames\") {\n      section = \"\";\n      lineIndex++;\n      continue;\n    } else if (line === \"$Entities\") {\n      section = \"entities\";\n      lineIndex++;\n      continue;\n    } else if (line === \"$EndEntities\") {\n      section = \"\";\n      lineIndex++;\n      continue;\n    } else if (line === \"$Nodes\") {\n      section = \"nodes\";\n      lineIndex++;\n      continue;\n    } else if (line === \"$EndNodes\") {\n      section = \"\";\n      lineIndex++;\n      continue;\n    } else if (line === \"$Elements\") {\n      section = \"elements\";\n      lineIndex++;\n      continue;\n    } else if (line === \"$EndElements\") {\n      section = \"\";\n      lineIndex++;\n      continue;\n    }\n\n    const parts = line.split(/\\s+/).filter((part) => part !== \"\");\n\n    if (section === \"meshFormat\") {\n      result.gmshV = parseFloat(parts[0]);\n      result.ascii = parts[1] === \"0\";\n      result.fltBytes = parts[2];\n    } else if (section === \"physicalNames\") {\n      if (parts.length >= 3) {\n        if (!/^\\d+$/.test(parts[0])) {\n          lineIndex++;\n          continue;\n        }\n\n        const dimension = parseInt(parts[0], 10);\n        const tag = parseInt(parts[1], 10);\n        let name = parts.slice(2).join(\" \");\n        name = name.replace(/^\"|\"$/g, \"\");\n\n        result.physicalPropMap.push({\n          tag,\n          dimension,\n          name,\n        });\n      }\n    } else if (section === \"nodes\") {\n      if (nodeEntityBlocks === 0) {\n        nodeEntityBlocks = parseInt(parts[0], 10);\n        totalNodes = parseInt(parts[1], 10);\n        result.nodesXCoordinates = new Array(totalNodes).fill(0);\n        result.nodesYCoordinates = new Array(totalNodes).fill(0);\n        lineIndex++;\n        continue;\n      }\n\n      if (nodeBlocksProcessed < nodeEntityBlocks && currentNodeBlock.numNodes === 0) {\n        currentNodeBlock = {\n          dim: parseInt(parts[0], 10),\n          tag: parseInt(parts[1], 10),\n          parametric: parseInt(parts[2], 10),\n          numNodes: parseInt(parts[3], 10),\n        };\n\n        nodeTags = [];\n        nodeTagsCollected = 0;\n        nodeCoordinatesCollected = 0;\n\n        lineIndex++;\n        continue;\n      }\n\n      if (nodeTagsCollected < currentNodeBlock.numNodes) {\n        for (let i = 0; i < parts.length && nodeTagsCollected < currentNodeBlock.numNodes; i++) {\n          nodeTags.push(parseInt(parts[i], 10));\n          nodeTagsCollected++;\n        }\n\n        if (nodeTagsCollected < currentNodeBlock.numNodes) {\n          lineIndex++;\n          continue;\n        }\n\n        lineIndex++;\n        continue;\n      }\n\n      if (nodeCoordinatesCollected < currentNodeBlock.numNodes) {\n        const nodeTag = nodeTags[nodeCoordinatesCollected] - 1;\n        const x = parseFloat(parts[0]);\n        const y = parseFloat(parts[1]);\n\n        result.nodesXCoordinates[nodeTag] = x;\n        result.nodesYCoordinates[nodeTag] = y;\n        result.totalNodesX++;\n        result.totalNodesY++;\n\n        nodeCoordinatesCollected++;\n\n        if (nodeCoordinatesCollected === currentNodeBlock.numNodes) {\n          nodeBlocksProcessed++;\n          currentNodeBlock = { numNodes: 0 };\n        }\n      }\n    } else if (section === \"elements\") {\n      if (elementEntityBlocks === 0) {\n        elementEntityBlocks = parseInt(parts[0], 10);\n        totalElements = parseInt(parts[1], 10);\n        lineIndex++;\n        continue;\n      }\n\n      if (elementBlocksProcessed < elementEntityBlocks && currentElementBlock.numElements === 0) {\n        currentElementBlock = {\n          dim: parseInt(parts[0], 10),\n          tag: parseInt(parts[1], 10),\n          elementType: parseInt(parts[2], 10),\n          numElements: parseInt(parts[3], 10),\n        };\n\n        result.elementTypes[currentElementBlock.elementType] =\n          (result.elementTypes[currentElementBlock.elementType] || 0) + currentElementBlock.numElements;\n\n        elementsProcessedInBlock = 0;\n        lineIndex++;\n        continue;\n      }\n\n      if (elementsProcessedInBlock < currentElementBlock.numElements) {\n        const elementTag = parseInt(parts[0], 10);\n        const nodeIndices = parts.slice(1).map((idx) => parseInt(idx, 10));\n\n        if (currentElementBlock.elementType === 1 || currentElementBlock.elementType === 8) {\n          const physicalTag = currentElementBlock.tag;\n\n          if (!boundaryElementsByTag[physicalTag]) {\n            boundaryElementsByTag[physicalTag] = [];\n          }\n\n          boundaryElementsByTag[physicalTag].push(nodeIndices);\n\n          // Store boundary node pairs for later processing in meshGenerationScript\n          if (!result.boundaryNodePairs[physicalTag]) {\n            result.boundaryNodePairs[physicalTag] = [];\n          }\n          result.boundaryNodePairs[physicalTag].push(nodeIndices);\n        } else if (currentElementBlock.elementType === 2) {\n          // Linear triangle elements (3 nodes)\n          result.nodalNumbering.triangleElements.push(nodeIndices);\n        } else if (currentElementBlock.elementType === 3) {\n          // Linear quadrilateral elements (4 nodes)\n          result.nodalNumbering.quadElements.push(nodeIndices);\n        } else if (currentElementBlock.elementType === 10) {\n          // Quadratic quadrilateral elements (9 nodes)\n          result.nodalNumbering.quadElements.push(nodeIndices);\n        }\n\n        elementsProcessedInBlock++;\n\n        if (elementsProcessedInBlock === currentElementBlock.numElements) {\n          elementBlocksProcessed++;\n          currentElementBlock = { numElements: 0 };\n        }\n      }\n    }\n\n    lineIndex++;\n  }\n\n  // Store boundary conditions information\n  result.physicalPropMap.forEach((prop) => {\n    if (prop.dimension === 1) {\n      const boundaryNodes = boundaryElementsByTag[prop.tag] || [];\n\n      if (boundaryNodes.length > 0) {\n        result.boundaryConditions.push({\n          name: prop.name,\n          tag: prop.tag,\n          nodes: boundaryNodes,\n        });\n      }\n    }\n  });\n\n  debugLog(\n    `Parsed boundary node pairs by physical tag: ${JSON.stringify(\n      result.boundaryNodePairs\n    )}. These pairs will be used to identify boundary elements in the mesh.`\n  );\n\n  return result;\n};\n\nexport { importGmshQuadTri };\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n/**\n * Function to create plots of the solution vector\n * @param {*} solutionVector - The computed solution vector\n * @param {*} nodesCoordinates - Object containing x and y coordinates for the nodes\n * @param {string} solverConfig - Parameter specifying the type of solver\n * @param {string} meshDimension - The dimension of the solution\n * @param {string} plotType - The type of plot\n * @param {string} plotDivId - The id of the div where the plot will be rendered\n * @param {string} [meshType=\"structured\"] - Type of mesh: \"structured\" or \"unstructured\"\n */\nexport function plotSolution(\n  solutionVector,\n  nodesCoordinates,\n  solverConfig,\n  meshDimension,\n  plotType,\n  plotDivId,\n  meshType = \"structured\"\n) {\n  const { nodesXCoordinates, nodesYCoordinates } = nodesCoordinates;\n\n  if (meshDimension === \"1D\" && plotType === \"line\") {\n    // Check if solutionVector is a nested array\n    let yData;\n    if (solutionVector.length > 0 && Array.isArray(solutionVector[0])) {\n      yData = solutionVector.map((arr) => arr[0]);\n    } else {\n      yData = solutionVector;\n    }\n    let xData = Array.from(nodesXCoordinates);\n\n    let lineData = {\n      x: xData,\n      y: yData,\n      mode: \"lines\",\n      type: \"scatter\",\n      line: { color: \"rgb(219, 64, 82)\", width: 2 },\n      name: \"Solution\",\n    };\n\n    let maxWindowWidth = Math.min(window.innerWidth, 700);\n    let maxPlotWidth = Math.max(...xData);\n    let zoomFactor = maxWindowWidth / maxPlotWidth;\n    let plotWidth = Math.max(zoomFactor * maxPlotWidth, 400);\n    let plotHeight = 350;\n\n    let layout = {\n      title: `line plot - ${solverConfig}`,\n      width: plotWidth,\n      height: plotHeight,\n      xaxis: { title: \"x\" },\n      yaxis: { title: \"Solution\" },\n      margin: { l: 70, r: 40, t: 50, b: 50 },\n    };\n\n    Plotly.newPlot(plotDivId, [lineData], layout, { responsive: true });\n  } else if (meshDimension === \"2D\" && plotType === \"contour\") {\n    // Use the user-provided mesh type\n    const isStructured = meshType === \"structured\";\n    \n    // For auto-detection (if needed)\n    const uniqueXCoords = new Set(nodesXCoordinates).size;\n    const uniqueYCoords = new Set(nodesYCoordinates).size;\n    \n    // Extract scalar values from solution vector\n    let zValues = Array.isArray(solutionVector[0]) \n      ? solutionVector.map(val => val[0]) \n      : solutionVector;\n    \n    // Common sizing parameters for both plot types\n    let maxWindowWidth = Math.min(window.innerWidth, 700);\n    let maxX = Math.max(...nodesXCoordinates);\n    let maxY = Math.max(...nodesYCoordinates);\n    let aspectRatio = maxY / maxX;\n    let plotWidth = Math.min(maxWindowWidth, 600);\n    let plotHeight = plotWidth * aspectRatio * 0.8; // Slightly reduce height for better appearance\n    \n    // Common layout properties\n    let layout = {\n      title: `${plotType} plot - ${solverConfig}`,\n      width: plotWidth,\n      height: plotHeight,\n      xaxis: { title: \"x\" },\n      yaxis: { title: \"y\" },\n      margin: { l: 50, r: 50, t: 50, b: 50 },\n      hovermode: 'closest'\n    };\n    \n    if (isStructured) {\n      // Calculate the number of nodes along the x-axis and y-axis\n      const numNodesX = uniqueXCoords;\n      const numNodesY = uniqueYCoords;\n\n      // Reshape the nodesXCoordinates and nodesYCoordinates arrays to match the grid dimensions\n      let reshapedXCoordinates = math.reshape(Array.from(nodesXCoordinates), [numNodesX, numNodesY]);\n      let reshapedYCoordinates = math.reshape(Array.from(nodesYCoordinates), [numNodesX, numNodesY]);\n\n      // Reshape the solution array to match the grid dimensions\n      let reshapedSolution = math.reshape(Array.from(solutionVector), [numNodesX, numNodesY]);\n\n      // Transpose the reshapedSolution array to get column-wise data\n      let transposedSolution = math.transpose(reshapedSolution);\n\n      // Create an array for x-coordinates used in the contour plot\n      let reshapedXForPlot = [];\n      for (let i = 0; i < numNodesX * numNodesY; i += numNodesY) {\n        let xValue = nodesXCoordinates[i];\n        reshapedXForPlot.push(xValue);\n      }\n\n      // Create the data structure for the contour plot\n      let contourData = {\n        z: transposedSolution,\n        type: \"contour\",\n        contours: {\n          coloring: \"heatmap\",\n          showlabels: false\n        },\n        //colorscale: 'Viridis',\n        colorbar: {\n          title: 'Solution'\n        },\n        x: reshapedXForPlot,\n        y: reshapedYCoordinates[0],\n        name: 'Solution Field'\n      };\n\n      // Create the plot using Plotly\n      Plotly.newPlot(plotDivId, [contourData], layout, { responsive: true });\n    } else {\n      // Create an interpolated contour plot for the unstructured mesh\n      let contourData = {\n        x: nodesXCoordinates,\n        y: nodesYCoordinates,\n        z: zValues,\n        type: 'contour',\n        contours: {\n          coloring: 'heatmap',\n          showlabels: false\n        },\n        //colorscale: 'Viridis',\n        colorbar: {\n          title: 'Solution'\n        },\n        name: 'Solution Field'\n      };\n      \n      // Create the plot using only the contour fill\n      Plotly.newPlot(plotDivId, [contourData], layout, { responsive: true });\n    }\n  }\n}\n"],"names":["proxyMarker","Symbol","createEndpoint","releaseProxy","finalizer","throwMarker","isObject","val","transferHandlers","Map","canHandle","serialize","obj","port1","port2","MessageChannel","expose","deserialize","port","start","wrap","value","serialized","Error","isError","message","name","stack","Object","assign","ep","globalThis","allowedOrigins","addEventListener","callback","ev","data","origin","allowedOrigin","RegExp","test","isAllowedOrigin","console","warn","id","type","path","argumentList","map","fromWireValue","returnValue","parent","slice","reduce","prop","rawValue","apply","proxy","transfers","transferCache","set","transfer","undefined","Promise","resolve","catch","then","wireValue","transferables","toWireValue","postMessage","removeEventListener","closeEndPoint","error","TypeError","endpoint","constructor","isMessagePort","close","target","pendingListeners","resolver","get","delete","createProxy","throwIfProxyReleased","isReleased","releaseEndpoint","requestResponseMessage","proxyCounter","WeakMap","proxyFinalizers","FinalizationRegistry","newCount","isProxyReleased","Proxy","_target","unregister","unregisterProxy","clear","length","r","p","toString","bind","_thisArg","rawArgumentList","last","processArguments","construct","register","registerProxy","processed","v","arr","Array","prototype","concat","handler","serializedValue","msg","fill","Math","floor","random","Number","MAX_SAFE_INTEGER","join","numericalIntegration","meshDimension","elementOrder","this","getGaussPointsAndWeights","gaussPoints","gaussWeights","sqrt","currentLogLevel","debugLog","log","basicLog","errorLog","basisFunctions","getBasisFunctions","ksi","eta","basisFunction","basisFunctionDerivKsi","basisFunctionDerivEta","l1","c","l2","l3","dl1","dl2","dl3","meshGeneration","numElementsX","maxX","numElementsY","maxY","parsedMesh","generateMesh","nodalNumbering","isArray","quadElements","triangleElements","JSON","stringify","elementTypes","mappedNodalNumbering","elemIdx","gmshNodes","feaScriptNodes","push","physicalPropMap","boundaryElements","fixedBoundaryElements","i","boundaryNodePairs","boundaryElementsProcessed","forEach","dimension","tag","nodesPair","node1","node2","foundElement","elemNodes","includes","side","node1Index","indexOf","node2Index","generateMeshFromGeometry","nodesXCoordinates","nodesYCoordinates","totalNodesX","totalNodesY","deltaX","deltaY","nodeIndex","generateNodalNumbering","findBoundaryElements","nodeIndexY","nodeIndexX","nnode","maxSides","sideIndex","elementIndexX","elementIndexY","elementIndex","nop","columnCounter","rowCounter","nodeIndex1","nodeIndex2","ThermalBoundaryConditions","boundaryConditions","imposeConstantTempBoundaryConditions","residualVector","jacobianMatrix","keys","boundaryKey","tempValue","globalNodeIndex","colIndex","imposeConvectionBoundaryConditions","basisFunctionsData","convectionHeatTranfCoeff","convectionExtTemp","key","boundaryCondition","convectionCoeff","extTemp","gaussPoint1","gaussPoint2","firstNodeIndex","lastNodeIndex","nodeIncrement","basisFunctionsAndDerivatives","ksiDerivX","ksiDerivY","etaDerivX","etaDerivY","numNodes","tangentVectorLength","localNodeIndex","localNodeIndex2","globalNodeIndex2","gaussPointIndex","solverConfig","meshConfig","solverMethod","setSolverConfig","setMeshConfig","addBoundaryCondition","condition","setSolverMethod","solve","solutionVector","nodesCoordinates","time","nodesCoordinatesAndNumbering","totalElements","totalNodes","xCoordinates","yCoordinates","detJacobian","localToGlobalMap","basisFunctionDerivX","basisFunctionDerivY","gaussPointsAndWeights","gaussPointIndex1","localNodeIndex1","localToGlobalMap1","localToGlobalMap2","gaussPointIndex2","thermalBoundaryConditions","assembleSolidHeatTransferMat","timeEnd","math","lusolve","jacobiResult","async","A","b","x0","maxIterations","tolerance","useFloat64","worker","Worker","jacobiWorker","Comlink.wrap","jacobiMethod","terminate","converged","iterations","solution","feaWorker","isReady","_initWorker","URL","document","require","__filename","href","currentScript","tagName","toUpperCase","src","baseURI","onerror","event","workerWrapper","_ensureReady","reject","attempts","checkReady","setTimeout","startTime","performance","now","result","toFixed","getModelInfo","ping","file","gmshV","ascii","fltBytes","lines","text","split","line","trim","filter","section","lineIndex","nodeEntityBlocks","nodeBlocksProcessed","currentNodeBlock","nodeTagsCollected","nodeTags","nodeCoordinatesCollected","elementEntityBlocks","elementBlocksProcessed","currentElementBlock","dim","elementType","numElements","elementsProcessedInBlock","boundaryElementsByTag","parts","part","parseFloat","parseInt","replace","parametric","nodeTag","x","y","nodeIndices","idx","physicalTag","boundaryNodes","nodes","level","plotType","plotDivId","meshType","yData","xData","from","lineData","mode","color","width","maxWindowWidth","min","window","innerWidth","maxPlotWidth","max","zoomFactor","layout","title","height","xaxis","yaxis","margin","l","t","Plotly","newPlot","responsive","isStructured","uniqueXCoords","Set","size","uniqueYCoords","zValues","aspectRatio","plotWidth","hovermode","numNodesX","numNodesY","reshape","reshapedYCoordinates","reshapedSolution","transposedSolution","transpose","reshapedXForPlot","xValue","contourData","z","contours","coloring","showlabels","colorbar","commitResponse","fetch","commitData","json","latestCommitDate","Date","commit","committer","date","toLocaleString"],"mappings":"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"}