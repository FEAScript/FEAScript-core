"use strict";function e(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n]*e[n];return t=Math.sqrt(t),t}Object.defineProperty(exports,"__esModule",{value:!0});let t="basic";function n(e){"debug"===t&&console.log("%c[DEBUG] "+e,"color: #2196F3; font-weight: bold;")}function o(e){console.log("%c[INFO] "+e,"color: #4CAF50; font-weight: bold;")}function s(e){console.log("%c[ERROR] "+e,"color: #F44336; font-weight: bold;")}function i(e,t,i,r={}){const{maxIterations:a=1e3,tolerance:l=1e-6}=r;let d=[],u=!0,c=0;if(o(`Solving system using ${e}...`),console.time("systemSolving"),"lusolve"===e){const e=math.sparse(t),n=math.slu(e,1,1);let o=math.lusolve(n,i);d=math.squeeze(o).valueOf()}else if("jacobi"===e){const e=function(e,t,n,o={}){const{maxIterations:s=1e3,tolerance:i=1e-6}=o,r=e.length;let a=[...n],l=new Array(r);for(let n=0;n<s;n++){for(let n=0;n<r;n++){let o=0;for(let t=0;t<r;t++)t!==n&&(o+=e[n][t]*a[t]);l[n]=(t[n]-o)/e[n][n]}let o=0;for(let e=0;e<r;e++)o=Math.max(o,Math.abs(l[e]-a[e]));if(a=[...l],o<i)return{solutionVector:a,iterations:n+1,converged:!0}}return{solutionVector:a,iterations:s,converged:!1}}(t,i,new Array(i.length).fill(0),{maxIterations:a,tolerance:l});e.converged?n(`Jacobi method converged in ${e.iterations} iterations`):s(`Jacobi method did not converge after ${e.iterations} iterations`),d=e.solutionVector,u=e.converged,c=e.iterations}else s(`Unknown solver method: ${e}`);return console.timeEnd("systemSolving"),o("System solved successfully"),{solutionVector:d,converged:u,iterations:c}}class r{constructor({meshDimension:e,elementOrder:t}){this.meshDimension=e,this.elementOrder=t}getBasisFunctions(e,t=null){let n=[],o=[],i=[];if("1D"===this.meshDimension)"linear"===this.elementOrder?(n[0]=1-e,n[1]=e,o[0]=-1,o[1]=1):"quadratic"===this.elementOrder&&(n[0]=1-3*e+2*e**2,n[1]=4*e-4*e**2,n[2]=2*e**2-e,o[0]=4*e-3,o[1]=4-8*e,o[2]=4*e-1);else if("2D"===this.meshDimension){if(null===t)return void s("Eta coordinate is required for 2D elements");if("linear"===this.elementOrder){function r(e){return 1-e}n[0]=r(e)*r(t),n[1]=r(e)*t,n[2]=e*r(t),n[3]=e*t,o[0]=-1*r(t),o[1]=-1*t,o[2]=1*r(t),o[3]=1*t,i[0]=-1*r(e),i[1]=1*r(e),i[2]=-1*e,i[3]=1*e}else if("quadratic"===this.elementOrder){function a(e){return 2*e**2-3*e+1}function l(e){return-4*e**2+4*e}function d(e){return 2*e**2-e}function u(e){return 4*e-3}function c(e){return-8*e+4}function m(e){return 4*e-1}n[0]=a(e)*a(t),n[1]=a(e)*l(t),n[2]=a(e)*d(t),n[3]=l(e)*a(t),n[4]=l(e)*l(t),n[5]=l(e)*d(t),n[6]=d(e)*a(t),n[7]=d(e)*l(t),n[8]=d(e)*d(t),o[0]=u(e)*a(t),o[1]=u(e)*l(t),o[2]=u(e)*d(t),o[3]=c(e)*a(t),o[4]=c(e)*l(t),o[5]=c(e)*d(t),o[6]=m(e)*a(t),o[7]=m(e)*l(t),o[8]=m(e)*d(t),i[0]=a(e)*u(t),i[1]=a(e)*c(t),i[2]=a(e)*m(t),i[3]=l(e)*u(t),i[4]=l(e)*c(t),i[5]=l(e)*m(t),i[6]=d(e)*u(t),i[7]=d(e)*c(t),i[8]=d(e)*m(t)}}return{basisFunction:n,basisFunctionDerivKsi:o,basisFunctionDerivEta:i}}}class a{constructor({numElementsX:e=null,maxX:t=null,numElementsY:n=null,maxY:s=null,meshDimension:i=null,elementOrder:r="linear",parsedMesh:a=null}){this.numElementsX=e,this.numElementsY=n,this.maxX=t,this.maxY=s,this.meshDimension=i,this.elementOrder=r,this.parsedMesh=a,this.boundaryElementsProcessed=!1,this.parsedMesh&&(o("Using pre-parsed mesh from gmshReader data for mesh generation."),this.parseMeshFromGmsh())}parseMeshFromGmsh(){if(this.parsedMesh.nodalNumbering||s("No valid nodal numbering found in the parsed mesh."),"object"==typeof this.parsedMesh.nodalNumbering&&!Array.isArray(this.parsedMesh.nodalNumbering)){const e=this.parsedMesh.nodalNumbering.quadElements||[];if(this.parsedMesh.nodalNumbering.triangleElements,n("Initial parsed mesh nodal numbering from GMSH format: "+JSON.stringify(this.parsedMesh.nodalNumbering)),this.parsedMesh.elementTypes[3]||this.parsedMesh.elementTypes[10]){const t=[];for(let n=0;n<e.length;n++){const o=e[n],s=new Array(o.length);4===o.length?(s[0]=o[0],s[1]=o[3],s[2]=o[1],s[3]=o[2]):9===o.length&&(s[0]=o[0],s[1]=o[7],s[2]=o[3],s[3]=o[4],s[4]=o[8],s[5]=o[6],s[6]=o[1],s[7]=o[5],s[8]=o[2]),t.push(s)}this.parsedMesh.nodalNumbering=t}else this.parsedMesh.elementTypes[2]&&s("Element type is neither triangle nor quad; mapping for this type is not implemented yet.");if(n("Nodal numbering after mapping from GMSH to FEAScript format: "+JSON.stringify(this.parsedMesh.nodalNumbering)),this.parsedMesh.physicalPropMap&&this.parsedMesh.boundaryElements){if(Array.isArray(this.parsedMesh.boundaryElements)&&this.parsedMesh.boundaryElements.length>0&&void 0===this.parsedMesh.boundaryElements[0]){const e=[];for(let t=1;t<this.parsedMesh.boundaryElements.length;t++)this.parsedMesh.boundaryElements[t]&&e.push(this.parsedMesh.boundaryElements[t]);this.parsedMesh.boundaryElements=e}if(this.parsedMesh.boundaryNodePairs&&!this.parsedMesh.boundaryElementsProcessed&&(this.parsedMesh.boundaryElements=[],this.parsedMesh.physicalPropMap.forEach((e=>{if(1===e.dimension){const t=this.parsedMesh.boundaryNodePairs[e.tag]||[];t.length>0&&(this.parsedMesh.boundaryElements[e.tag]||(this.parsedMesh.boundaryElements[e.tag]=[]),t.forEach((t=>{const o=t[0],i=t[1];n(`Processing boundary node pair: [${o}, ${i}] for boundary ${e.tag} (${e.name||"unnamed"})`);let r=!1;for(let t=0;t<this.parsedMesh.nodalNumbering.length;t++){const s=this.parsedMesh.nodalNumbering[t];if(4===s.length){if(s.includes(o)&&s.includes(i)){let a;const l=s.indexOf(o),d=s.indexOf(i);n(`  Found element ${t} containing boundary nodes. Element nodes: [${s.join(", ")}]`),n(`  Node ${o} is at index ${l}, Node ${i} is at index ${d} in the element`),0===l&&2===d||2===l&&0===d?(a=0,n(`  These nodes form the BOTTOM side (${a}) of element ${t}`)):0===l&&1===d||1===l&&0===d?(a=1,n(`  These nodes form the LEFT side (${a}) of element ${t}`)):1===l&&3===d||3===l&&1===d?(a=2,n(`  These nodes form the TOP side (${a}) of element ${t}`)):(2===l&&3===d||3===l&&2===d)&&(a=3,n(`  These nodes form the RIGHT side (${a}) of element ${t}`)),this.parsedMesh.boundaryElements[e.tag].push([t,a]),n(`  Added element-side pair [${t}, ${a}] to boundary tag ${e.tag}`),r=!0;break}}else if(9===s.length&&s.includes(o)&&s.includes(i)){let a;const l=s.indexOf(o),d=s.indexOf(i);n(`  Found element ${t} containing boundary nodes. Element nodes: [${s.join(", ")}]`),n(`  Node ${o} is at index ${l}, Node ${i} is at index ${d} in the element`),0===l&&6===d||6===l&&0===d||0===l&&3===d||3===l&&0===d||3===l&&6===d||6===l&&3===d?(a=0,n(`  These nodes form the BOTTOM side (${a}) of element ${t}`)):0===l&&2===d||2===l&&0===d||0===l&&1===d||1===l&&0===d||1===l&&2===d||2===l&&1===d?(a=1,n(`  These nodes form the LEFT side (${a}) of element ${t}`)):2===l&&8===d||8===l&&2===d||2===l&&5===d||5===l&&2===d||5===l&&8===d||8===l&&5===d?(a=2,n(`  These nodes form the TOP side (${a}) of element ${t}`)):(6===l&&8===d||8===l&&6===d||6===l&&7===d||7===l&&6===d||7===l&&8===d||8===l&&7===d)&&(a=3,n(`  These nodes form the RIGHT side (${a}) of element ${t}`)),this.parsedMesh.boundaryElements[e.tag].push([t,a]),n(`  Added element-side pair [${t}, ${a}] to boundary tag ${e.tag}`),r=!0;break}}r||s(`Could not find element containing boundary nodes ${o} and ${i}. Boundary may be incomplete.`)})))}})),this.boundaryElementsProcessed=!0,this.parsedMesh.boundaryElements.length>0&&void 0===this.parsedMesh.boundaryElements[0])){const e=[];for(let t=1;t<this.parsedMesh.boundaryElements.length;t++)this.parsedMesh.boundaryElements[t]&&e.push(this.parsedMesh.boundaryElements[t]);this.parsedMesh.boundaryElements=e}}}return this.parsedMesh}}class l extends a{constructor({numElementsX:e=null,maxX:t=null,elementOrder:n="linear",parsedMesh:o=null}){super({numElementsX:e,maxX:t,numElementsY:1,maxY:0,meshDimension:"1D",elementOrder:n,parsedMesh:o}),null!==this.numElementsX&&null!==this.maxX||s("numElementsX and maxX are required parameters when generating a 1D mesh from geometry")}generateMesh(){let e=[];let t,o;if("linear"===this.elementOrder){t=this.numElementsX+1,o=(this.maxX-0)/this.numElementsX,e[0]=0;for(let n=1;n<t;n++)e[n]=e[n-1]+o}else if("quadratic"===this.elementOrder){t=2*this.numElementsX+1,o=(this.maxX-0)/this.numElementsX,e[0]=0;for(let n=1;n<t;n++)e[n]=e[n-1]+o/2}const s=this.generate1DNodalNumbering(this.numElementsX,t,this.elementOrder),i=this.findBoundaryElements();return n("Generated node X coordinates: "+JSON.stringify(e)),{nodesXCoordinates:e,totalNodesX:t,nodalNumbering:s,boundaryElements:i}}generate1DNodalNumbering(e,t,n){let o=[];if("linear"===n)for(let t=0;t<e;t++){o[t]=[];for(let e=1;e<=2;e++)o[t][e-1]=t+e}else if("quadratic"===n){let t=0;for(let n=0;n<e;n++){o[n]=[];for(let e=1;e<=3;e++)o[n][e-1]=n+e+t;t+=1}}return o}findBoundaryElements(){const e=[];for(let t=0;t<2;t++)e.push([]);return e[0].push([0,0]),e[1].push([this.numElementsX-1,1]),n("Identified boundary elements by side: "+JSON.stringify(e)),this.boundaryElementsProcessed=!0,e}}class d extends a{constructor({numElementsX:e=null,maxX:t=null,numElementsY:n=null,maxY:o=null,elementOrder:i="linear",parsedMesh:r=null}){super({numElementsX:e,maxX:t,numElementsY:n,maxY:o,meshDimension:"2D",elementOrder:i,parsedMesh:r}),r||null!==this.numElementsX&&null!==this.maxX&&null!==this.numElementsY&&null!==this.maxY||s("numElementsX, maxX, numElementsY, and maxY are required parameters when generating a 2D mesh from geometry")}generateMesh(){let e=[],t=[];let o,s,i,r;if("linear"===this.elementOrder){o=this.numElementsX+1,s=this.numElementsY+1,i=(this.maxX-0)/this.numElementsX,r=(this.maxY-0)/this.numElementsY,e[0]=0,t[0]=0;for(let n=1;n<s;n++)e[n]=e[0],t[n]=t[0]+n*r;for(let n=1;n<o;n++){const o=n*s;e[o]=e[0]+n*i,t[o]=t[0];for(let n=1;n<s;n++)e[o+n]=e[o],t[o+n]=t[o]+n*r}}else if("quadratic"===this.elementOrder){o=2*this.numElementsX+1,s=2*this.numElementsY+1,i=(this.maxX-0)/this.numElementsX,r=(this.maxY-0)/this.numElementsY,e[0]=0,t[0]=0;for(let n=1;n<s;n++)e[n]=e[0],t[n]=t[0]+n*r/2;for(let n=1;n<o;n++){const o=n*s;e[o]=e[0]+n*i/2,t[o]=t[0];for(let n=1;n<s;n++)e[o+n]=e[o],t[o+n]=t[o]+n*r/2}}const a=this.generate2DNodalNumbering(this.numElementsX,this.numElementsY,s,this.elementOrder),l=this.findBoundaryElements();return n("Generated node X coordinates: "+JSON.stringify(e)),n("Generated node Y coordinates: "+JSON.stringify(t)),{nodesXCoordinates:e,nodesYCoordinates:t,totalNodesX:o,totalNodesY:s,nodalNumbering:a,boundaryElements:l}}generate2DNodalNumbering(e,t,n,o){let s=0,i=[];if("linear"===o){let n=0,o=2;for(let s=0;s<e*t;s++)n+=1,i[s]=[],i[s][0]=s+o-1,i[s][1]=s+o,i[s][2]=s+o+t,i[s][3]=s+o+t+1,n===t&&(o+=1,n=0)}else if("quadratic"===o)for(let o=1;o<=e;o++)for(let e=1;e<=t;e++){i[s]=[];for(let t=1;t<=3;t++){let r=3*t-2;i[s][r-1]=n*(2*o+t-3)+2*e-1,i[s][r]=i[s][r-1]+1,i[s][r+1]=i[s][r-1]+2}s+=1}return i}findBoundaryElements(){const e=[];for(let t=0;t<4;t++)e.push([]);for(let t=0;t<this.numElementsX;t++)for(let n=0;n<this.numElementsY;n++){const o=t*this.numElementsY+n;0===n&&e[0].push([o,0]),0===t&&e[1].push([o,1]),n===this.numElementsY-1&&e[2].push([o,2]),t===this.numElementsX-1&&e[3].push([o,3])}return n("Identified boundary elements by side: "+JSON.stringify(e)),this.boundaryElementsProcessed=!0,e}}class u{constructor({meshDimension:e,elementOrder:t}){this.meshDimension=e,this.elementOrder=t}getGaussPointsAndWeights(){let e=[],t=[];return"linear"===this.elementOrder?(e[0]=.5,t[0]=1):"quadratic"===this.elementOrder&&(e[0]=(1-Math.sqrt(.6))/2,e[1]=.5,e[2]=(1+Math.sqrt(.6))/2,t[0]=5/18,t[1]=8/18,t[2]=5/18),{gaussPoints:e,gaussWeights:t}}}function c(e){const{totalNodes:t,nop:n,meshDimension:o,elementOrder:s}=e;let i=[],a=[];for(let e=0;e<t;e++){i[e]=0,a.push([]);for(let n=0;n<t;n++)a[e][n]=0}const l=new r({meshDimension:o,elementOrder:s});let d=new u({meshDimension:o,elementOrder:s}).getGaussPointsAndWeights();return{residualVector:i,jacobianMatrix:a,localToGlobalMap:[],basisFunctions:l,gaussPoints:d.gaussPoints,gaussWeights:d.gaussWeights,numNodes:n[0].length}}function m(e){const{basisFunction:t,basisFunctionDerivKsi:n,nodesXCoordinates:o,localToGlobalMap:s,numNodes:i}=e;let r=0,a=0;for(let e=0;e<i;e++)r+=o[s[e]]*t[e],a+=o[s[e]]*n[e];let l=a,d=[];for(let e=0;e<i;e++)d[e]=n[e]/l;return{xCoordinates:r,detJacobian:l,basisFunctionDerivX:d}}function h(e){const{basisFunction:t,basisFunctionDerivKsi:n,basisFunctionDerivEta:o,nodesXCoordinates:s,nodesYCoordinates:i,localToGlobalMap:r,numNodes:a}=e;let l=0,d=0,u=0,c=0,m=0,h=0;for(let e=0;e<a;e++)l+=s[r[e]]*t[e],d+=i[r[e]]*t[e],u+=s[r[e]]*n[e],c+=s[r[e]]*o[e],m+=i[r[e]]*n[e],h+=i[r[e]]*o[e];let f=u*h-c*m,p=[],b=[];for(let e=0;e<a;e++)p[e]=(h*n[e]-m*o[e])/f,b[e]=(u*o[e]-c*n[e])/f;return{xCoordinates:l,yCoordinates:d,detJacobian:f,basisFunctionDerivX:p,basisFunctionDerivY:b}}class f{constructor(e,t,n,o,s){this.boundaryConditions=e,this.boundaryElements=t,this.nop=n,this.meshDimension=o,this.elementOrder=s}imposeConstantTempBoundaryConditions(e,t){"1D"===this.meshDimension?Object.keys(this.boundaryConditions).forEach((o=>{if("constantTemp"===this.boundaryConditions[o][0]){const s=this.boundaryConditions[o][1];n(`Boundary ${o}: Applying constant temperature of ${s} K (Dirichlet condition)`),this.boundaryElements[o].forEach((([o,i])=>{if("linear"===this.elementOrder){({0:[0],1:[1]})[i].forEach((i=>{const r=this.nop[o][i]-1;n(`  - Applied constant temperature to node ${r+1} (element ${o+1}, local node ${i+1})`),e[r]=s;for(let n=0;n<e.length;n++)t[r][n]=0;t[r][r]=1}))}else if("quadratic"===this.elementOrder){({0:[0],2:[2]})[i].forEach((i=>{const r=this.nop[o][i]-1;n(`  - Applied constant temperature to node ${r+1} (element ${o+1}, local node ${i+1})`),e[r]=s;for(let n=0;n<e.length;n++)t[r][n]=0;t[r][r]=1}))}}))}})):"2D"===this.meshDimension&&Object.keys(this.boundaryConditions).forEach((o=>{if("constantTemp"===this.boundaryConditions[o][0]){const s=this.boundaryConditions[o][1];n(`Boundary ${o}: Applying constant temperature of ${s} K (Dirichlet condition)`),this.boundaryElements[o].forEach((([o,i])=>{if("linear"===this.elementOrder){({0:[0,2],1:[0,1],2:[1,3],3:[2,3]})[i].forEach((i=>{const r=this.nop[o][i]-1;n(`  - Applied constant temperature to node ${r+1} (element ${o+1}, local node ${i+1})`),e[r]=s;for(let n=0;n<e.length;n++)t[r][n]=0;t[r][r]=1}))}else if("quadratic"===this.elementOrder){({0:[0,3,6],1:[0,1,2],2:[2,5,8],3:[6,7,8]})[i].forEach((i=>{const r=this.nop[o][i]-1;n(`  - Applied constant temperature to node ${r+1} (element ${o+1}, local node ${i+1})`),e[r]=s;for(let n=0;n<e.length;n++)t[r][n]=0;t[r][r]=1}))}}))}}))}imposeConstantTempBoundaryConditionsFront(e,t){"1D"===this.meshDimension?Object.keys(this.boundaryConditions).forEach((o=>{if("constantTemp"===this.boundaryConditions[o][0]){const s=this.boundaryConditions[o][1];n(`Boundary ${o}: Applying constant temperature of ${s} K (Dirichlet condition)`),this.boundaryElements[o].forEach((([o,i])=>{if("linear"===this.elementOrder){({0:[0],1:[1]})[i].forEach((i=>{const r=this.nop[o][i]-1;n(`  - Applied constant temperature to node ${r+1} (element ${o+1}, local node ${i+1})`),e[r]=1,t[r]=s}))}else if("quadratic"===this.elementOrder){({0:[0],2:[2]})[i].forEach((i=>{const r=this.nop[o][i]-1;n(`  - Applied constant temperature to node ${r+1} (element ${o+1}, local node ${i+1})`),e[r]=1,t[r]=s}))}}))}})):"2D"===this.meshDimension&&Object.keys(this.boundaryConditions).forEach((o=>{if("constantTemp"===this.boundaryConditions[o][0]){const s=this.boundaryConditions[o][1];n(`Boundary ${o}: Applying constant temperature of ${s} K (Dirichlet condition)`),this.boundaryElements[o].forEach((([o,i])=>{if("linear"===this.elementOrder){({0:[0,2],1:[0,1],2:[1,3],3:[2,3]})[i].forEach((i=>{const r=this.nop[o][i]-1;n(`  - Applied constant temperature to node ${r+1} (element ${o+1}, local node ${i+1})`),e[r]=1,t[r]=s}))}else if("quadratic"===this.elementOrder){({0:[0,3,6],1:[0,1,2],2:[2,5,8],3:[6,7,8]})[i].forEach((i=>{const r=this.nop[o][i]-1;n(`  - Applied constant temperature to node ${r+1} (element ${o+1}, local node ${i+1})`),e[r]=1,t[r]=s}))}}))}}))}imposeConvectionBoundaryConditions(e,t,o,s,i,r,a){let l=[],d=[];Object.keys(this.boundaryConditions).forEach((e=>{const t=this.boundaryConditions[e];"convection"===t[0]&&(l[e]=t[1],d[e]=t[2])})),"1D"===this.meshDimension?Object.keys(this.boundaryConditions).forEach((o=>{if("convection"===this.boundaryConditions[o][0]){const s=l[o],i=d[o];n(`Boundary ${o}: Applying convection with heat transfer coefficient h=${s} W/(m²·K) and external temperature T∞=${i} K`),this.boundaryElements[o].forEach((([o,r])=>{let a;"linear"===this.elementOrder?a=0===r?0:1:"quadratic"===this.elementOrder&&(a=0===r?0:2);const l=this.nop[o][a]-1;n(`  - Applied convection boundary condition to node ${l+1} (element ${o+1}, local node ${a+1})`),e[l]+=-s*i,t[l][l]+=s}))}})):"2D"===this.meshDimension&&Object.keys(this.boundaryConditions).forEach((u=>{if("convection"===this.boundaryConditions[u][0]){const c=l[u],m=d[u];n(`Boundary ${u}: Applying convection with heat transfer coefficient h=${c} W/(m²·K) and external temperature T∞=${m} K`),this.boundaryElements[u].forEach((([l,d])=>{if("linear"===this.elementOrder){let u,h,f,p,b;0===d?(u=o[0],h=0,f=0,p=3,b=2):1===d?(u=0,h=o[0],f=0,p=2,b=1):2===d?(u=o[0],h=1,f=1,p=4,b=2):3===d&&(u=1,h=o[0],f=2,p=4,b=1);let y=a.getBasisFunctions(u,h),g=y.basisFunction,E=y.basisFunctionDerivKsi,v=y.basisFunctionDerivEta,M=0,C=0,D=0,$=0;const F=this.nop[l].length;for(let e=0;e<F;e++){const t=this.nop[l][e]-1;0===d||2===d?(M+=i[t]*E[e],C+=r[t]*E[e]):1!==d&&3!==d||(D+=i[t]*v[e],$+=r[t]*v[e])}let x;x=0===d||2===d?Math.sqrt(M**2+C**2):Math.sqrt(D**2+$**2);for(let o=f;o<p;o+=b){let i=this.nop[l][o]-1;n(`  - Applied convection boundary condition to node ${i+1} (element ${l+1}, local node ${o+1})`),e[i]+=-s[0]*x*g[o]*c*m;for(let e=f;e<p;e+=b){let n=this.nop[l][e]-1;t[i][n]+=-s[0]*x*g[o]*g[e]*c}}}else if("quadratic"===this.elementOrder)for(let u=0;u<3;u++){let h,f,p,b,y;0===d?(h=o[u],f=0,p=0,b=7,y=3):1===d?(h=0,f=o[u],p=0,b=3,y=1):2===d?(h=o[u],f=1,p=2,b=9,y=3):3===d&&(h=1,f=o[u],p=6,b=9,y=1);let g=a.getBasisFunctions(h,f),E=g.basisFunction,v=g.basisFunctionDerivKsi,M=g.basisFunctionDerivEta,C=0,D=0,$=0,F=0;const x=this.nop[l].length;for(let e=0;e<x;e++){const t=this.nop[l][e]-1;0===d||2===d?(C+=i[t]*v[e],D+=r[t]*v[e]):1!==d&&3!==d||($+=i[t]*M[e],F+=r[t]*M[e])}let A;A=0===d||2===d?Math.sqrt(C**2+D**2):Math.sqrt($**2+F**2);for(let o=p;o<b;o+=y){let i=this.nop[l][o]-1;n(`  - Applied convection boundary condition to node ${i+1} (element ${l+1}, local node ${o+1})`),e[i]+=-s[u]*A*E[o]*c*m;for(let e=p;e<b;e+=y){let n=this.nop[l][e]-1;t[i][n]+=-s[u]*A*E[o]*E[e]*c}}}}))}}))}imposeConvectionBoundaryConditionsFront(e,t,o,s,i,r){let a=[],l=[];Object.keys(this.boundaryConditions).forEach((e=>{const t=this.boundaryConditions[e];"convection"===t[0]&&(a[e]=t[1],l[e]=t[2])}));const d=this.nop[e].length,u=Array(d).fill().map((()=>Array(d).fill(0))),c=Array(d).fill(0);for(const m in this.boundaryElements)if("convection"===this.boundaryConditions[m]?.[0]){const h=a[m],f=l[m];n(`Boundary ${m}: Applying convection with heat transfer coefficient h=${h} W/(m²·K) and external temperature T∞=${f} K`);const p=this.boundaryElements[m].find((([t,n])=>t===e));if(p){const a=p[1];if("1D"===this.meshDimension){let t;"linear"===this.elementOrder?t=0===a?0:1:"quadratic"===this.elementOrder&&(t=0===a?0:2),n(`  - Applied convection boundary condition to node ${t+1} (element ${e+1}, local node ${t+1})`),c[t]+=-h*f,u[t][t]+=h}else if("2D"===this.meshDimension)if("linear"===this.elementOrder){let n,l,m,p,b;0===a?(n=s[0],l=0,m=0,p=3,b=2):1===a?(n=0,l=s[0],m=0,p=2,b=1):2===a?(n=s[0],l=1,m=1,p=4,b=2):3===a&&(n=1,l=s[0],m=2,p=4,b=1);const y=r.getBasisFunctions(n,l),g=y.basisFunction,E=y.basisFunctionDerivKsi,v=y.basisFunctionDerivEta;let M,C=0,D=0,$=0,F=0;for(let n=0;n<d;n++){const s=this.nop[e][n]-1;0===a||2===a?(C+=t[s]*E[n],D+=o[s]*E[n]):1!==a&&3!==a||($+=t[s]*v[n],F+=o[s]*v[n])}M=0===a||2===a?Math.sqrt(C**2+D**2):Math.sqrt($**2+F**2);for(let e=m;e<p;e+=b){c[e]+=-i[0]*M*g[e]*h*f;for(let t=m;t<p;t+=b)u[e][t]+=-i[0]*M*g[e]*g[t]*h}}else if("quadratic"===this.elementOrder)for(let n=0;n<3;n++){let l,d,m,p,b;0===a?(l=s[n],d=0,m=0,p=7,b=3):1===a?(l=0,d=s[n],m=0,p=3,b=1):2===a?(l=s[n],d=1,m=2,p=9,b=3):3===a&&(l=1,d=s[n],m=6,p=9,b=1);let y=r.getBasisFunctions(l,d),g=y.basisFunction,E=y.basisFunctionDerivKsi,v=y.basisFunctionDerivEta,M=0,C=0,D=0,$=0;const F=this.nop[e].length;for(let n=0;n<F;n++){const s=this.nop[e][n]-1;0===a||2===a?(M+=t[s]*E[n],C+=o[s]*E[n]):1!==a&&3!==a||(D+=t[s]*v[n],$+=o[s]*v[n])}let x;x=0===a||2===a?Math.sqrt(M**2+C**2):Math.sqrt(D**2+$**2);for(let e=m;e<p;e+=b){c[e]+=-i[n]*x*g[e]*h*f;for(let t=m;t<p;t+=b)u[e][t]+=-i[n]*x*g[e]*g[t]*h}}}}return{localJacobianMatrix:u,localResidualVector:c}}}function p({elementIndex:e,nop:t,meshData:n,basisFunctions:o,FEAData:s}){const{gaussPoints:i,gaussWeights:r,numNodes:a}=s,{nodesXCoordinates:l,nodesYCoordinates:d,meshDimension:u}=n,c=Array(a).fill().map((()=>Array(a).fill(0))),f=Array(a).fill(0),p=Array(a),b=Array(a);for(let n=0;n<a;n++)p[n]=Math.abs(t[e][n]),b[n]=Math.abs(t[e][n])-1;if("1D"===u)for(let e=0;e<i.length;e++){const{basisFunction:t,basisFunctionDerivKsi:n}=o.getBasisFunctions(i[e]),{detJacobian:s,basisFunctionDerivX:d}=m({basisFunction:t,basisFunctionDerivKsi:n,nodesXCoordinates:l,localToGlobalMap:b,numNodes:a});for(let t=0;t<a;t++)for(let n=0;n<a;n++)c[t][n]-=r[e]*s*(d[t]*d[n])}else if("2D"===u)for(let e=0;e<i.length;e++)for(let t=0;t<i.length;t++){const{basisFunction:n,basisFunctionDerivKsi:s,basisFunctionDerivEta:u}=o.getBasisFunctions(i[e],i[t]),m=p.map((e=>e-1)),{detJacobian:f,basisFunctionDerivX:b,basisFunctionDerivY:y}=h({basisFunction:n,basisFunctionDerivKsi:s,basisFunctionDerivEta:u,nodesXCoordinates:l,nodesYCoordinates:d,localToGlobalMap:m,numNodes:a});for(let n=0;n<a;n++)for(let o=0;o<a;o++)c[n][o]-=r[e]*r[t]*f*(b[n]*b[o]+y[n]*y[o])}return{localJacobianMatrix:c,localResidualVector:f,ngl:p}}class b{constructor(e,t,n,o,s){this.boundaryConditions=e,this.boundaryElements=t,this.nop=n,this.meshDimension=o,this.elementOrder=s}imposeDirichletBoundaryConditions(e,t){"1D"===this.meshDimension?Object.keys(this.boundaryConditions).forEach((o=>{if("constantValue"===this.boundaryConditions[o][0]){const s=this.boundaryConditions[o][1];n(`Boundary ${o}: Applying constant value of ${s} (Dirichlet condition)`),this.boundaryElements[o].forEach((([o,i])=>{if("linear"===this.elementOrder){({0:[0],1:[1]})[i].forEach((i=>{const r=this.nop[o][i]-1;n(`  - Applied constant value to node ${r+1} (element ${o+1}, local node ${i+1})`),e[r]=s;for(let n=0;n<e.length;n++)t[r][n]=0;t[r][r]=1}))}else if("quadratic"===this.elementOrder){({0:[0],2:[2]})[i].forEach((i=>{const r=this.nop[o][i]-1;n(`  - Applied constant value to node ${r+1} (element ${o+1}, local node ${i+1})`),e[r]=s;for(let n=0;n<e.length;n++)t[r][n]=0;t[r][r]=1}))}}))}})):"2D"===this.meshDimension&&Object.keys(this.boundaryConditions).forEach((o=>{if("constantValue"===this.boundaryConditions[o][0]){const s=this.boundaryConditions[o][1];n(`Boundary ${o}: Applying constant value of ${s} (Dirichlet condition)`),this.boundaryElements[o].forEach((([o,i])=>{if("linear"===this.elementOrder){({0:[0,2],1:[0,1],2:[1,3],3:[2,3]})[i].forEach((i=>{const r=this.nop[o][i]-1;n(`  - Applied constant value to node ${r+1} (element ${o+1}, local node ${i+1})`),e[r]=s;for(let n=0;n<e.length;n++)t[r][n]=0;t[r][r]=1}))}else if("quadratic"===this.elementOrder){({0:[0,3,6],1:[0,1,2],2:[2,5,8],3:[6,7,8]})[i].forEach((i=>{const r=this.nop[o][i]-1;n(`  - Applied constant value to node ${r+1} (element ${o+1}, local node ${i+1})`),e[r]=s;for(let n=0;n<e.length;n++)t[r][n]=0;t[r][r]=1}))}}))}}))}imposeConstantValueBoundaryConditionsFront(e,t){"1D"===this.meshDimension?Object.keys(this.boundaryConditions).forEach((o=>{if("constantValue"===this.boundaryConditions[o][0]){const s=this.boundaryConditions[o][1];n(`Boundary ${o}: Applying constant value of ${s} (Dirichlet condition)`),this.boundaryElements[o].forEach((([o,i])=>{if("linear"===this.elementOrder){({0:[0],1:[1]})[i].forEach((i=>{const r=this.nop[o][i]-1;n(`  - Applied constant value to node ${r+1} (element ${o+1}, local node ${i+1})`),e[r]=1,t[r]=s}))}else if("quadratic"===this.elementOrder){({0:[0],2:[2]})[i].forEach((i=>{const r=this.nop[o][i]-1;n(`  - Applied constant value to node ${r+1} (element ${o+1}, local node ${i+1})`),e[r]=1,t[r]=s}))}}))}})):"2D"===this.meshDimension&&Object.keys(this.boundaryConditions).forEach((o=>{if("constantValue"===this.boundaryConditions[o][0]){const s=this.boundaryConditions[o][1];n(`Boundary ${o}: Applying constant value of ${s} (Dirichlet condition)`),this.boundaryElements[o].forEach((([o,i])=>{if("linear"===this.elementOrder){({0:[0,2],1:[0,1],2:[1,3],3:[2,3]})[i].forEach((i=>{const r=this.nop[o][i]-1;n(`  - Applied constant value to node ${r+1} (element ${o+1}, local node ${i+1})`),e[r]=1,t[r]=s}))}else if("quadratic"===this.elementOrder){({0:[0,3,6],1:[0,1,2],2:[2,5,8],3:[6,7,8]})[i].forEach((i=>{const r=this.nop[o][i]-1;n(`  - Applied constant value to node ${r+1} (element ${o+1}, local node ${i+1})`),e[r]=1,t[r]=s}))}}))}}))}}function y(e,t,s,i){o("Starting front propagation matrix assembly...");let r=1-i+.01;n(`eikonalViscousTerm: ${r}`),n(`eikonalActivationFlag: ${i}`);const{nodesXCoordinates:a,nodesYCoordinates:l,nop:d,boundaryElements:u,totalElements:f,meshDimension:p,elementOrder:y}=e,g=c(e),{residualVector:E,jacobianMatrix:v,localToGlobalMap:M,basisFunctions:C,gaussPoints:D,gaussWeights:$,numNodes:F}=g;for(let e=0;e<f;e++){for(let t=0;t<F;t++)M[t]=d[e][t]-1;for(let e=0;e<D.length;e++)if("1D"===p){errorLog("1D front propagation is not yet supported");let t=C.getBasisFunctions(D[e]);const n=m({basisFunction:t.basisFunction,basisFunctionDerivKsi:t.basisFunctionDerivKsi,nodesXCoordinates:a,localToGlobalMap:M,numNodes:F}),{detJacobian:o,basisFunctionDerivX:i}=n;t.basisFunction;let r=0;for(let e=0;e<F;e++)r+=s[M[e]]*i[e];for(let e=0;e<F;e++){M[e];for(let e=0;e<F;e++)M[e]}}else if("2D"===p)for(let t=0;t<D.length;t++){let n=C.getBasisFunctions(D[e],D[t]);const o=h({basisFunction:n.basisFunction,basisFunctionDerivKsi:n.basisFunctionDerivKsi,basisFunctionDerivEta:n.basisFunctionDerivEta,nodesXCoordinates:a,nodesYCoordinates:l,localToGlobalMap:M,numNodes:F}),{detJacobian:d,basisFunctionDerivX:u,basisFunctionDerivY:c}=o,m=n.basisFunction;let f=0,p=0;for(let e=0;e<F;e++)f+=s[M[e]]*u[e],p+=s[M[e]]*c[e];for(let n=0;n<F;n++){let o=M[n];E[o]+=r*$[e]*$[t]*d*u[n]*f+r*$[e]*$[t]*d*c[n]*p,0!==i&&(E[o]+=i*($[e]*$[t]*d*m[n]*Math.sqrt(f**2+p**2)-$[e]*$[t]*d*m[n]));for(let s=0;s<F;s++){let a=M[s];v[o][a]+=-r*$[e]*$[t]*d*(u[n]*u[s]+c[n]*c[s]),0!==i&&(v[o][a]+=i*(-d*f*m[n]*$[e]*$[t]/Math.sqrt(f**2+p**2+1e-8))*u[s]-i*(d*p*m[n]*$[e]*$[t]/Math.sqrt(f**2+p**2+1e-8))*c[s])}}}}return new b(t,u,d,p,y).imposeDirichletBoundaryConditions(E,v),o("Front propagation matrix assembly completed"),{jacobianMatrix:v,residualVector:E}}function g({elementIndex:e,nop:t,meshData:n,basisFunctions:o,FEAData:s,solutionVector:i,eikonalActivationFlag:r}){const{gaussPoints:a,gaussWeights:l,numNodes:d}=s,{nodesXCoordinates:u,nodesYCoordinates:c,meshDimension:f}=n;let p=1-r+.01;const b=Array(d).fill().map((()=>Array(d).fill(0))),y=Array(d).fill(0),g=Array(d),E=Array(d);for(let n=0;n<d;n++)g[n]=Math.abs(t[e][n]),E[n]=Math.abs(t[e][n])-1;for(let e=0;e<a.length;e++)if("1D"===f){errorLog("1D front propagation is not yet supported");let t=o.getBasisFunctions(a[e]);const n=m({basisFunction:t.basisFunction,basisFunctionDerivKsi:t.basisFunctionDerivKsi,nodesXCoordinates:u,localToGlobalMap:E,numNodes:d}),{detJacobian:s,basisFunctionDerivX:r}=n;t.basisFunction;let l=0;for(let e=0;e<d;e++)l+=i[E[e]]*r[e];for(let e=0;e<d;e++){E[e];for(let e=0;e<d;e++)E[e]}}else if("2D"===f)for(let t=0;t<a.length;t++){const{basisFunction:n,basisFunctionDerivKsi:s,basisFunctionDerivEta:m}=o.getBasisFunctions(a[e],a[t]),{detJacobian:f,basisFunctionDerivX:g,basisFunctionDerivY:v}=h({basisFunction:n,basisFunctionDerivKsi:s,basisFunctionDerivEta:m,nodesXCoordinates:u,nodesYCoordinates:c,localToGlobalMap:E,numNodes:d});let M=0,C=0;for(let e=0;e<d;e++)M+=i[E[e]]*g[e],C+=i[E[e]]*v[e];for(let o=0;o<d;o++){E[o],y[o]+=p*l[e]*l[t]*f*g[o]*M+p*l[e]*l[t]*f*v[o]*C,0!==r&&(y[o]+=r*(l[e]*l[t]*f*n[o]*Math.sqrt(M**2+C**2)-l[e]*l[t]*f*n[o]));for(let s=0;s<d;s++)b[o][s]-=p*l[e]*l[t]*f*(g[o]*g[s]+v[o]*v[s]),0!==r&&(b[o][s]+=r*(-f*M*n[o]*l[e]*l[t]/Math.sqrt(M**2+C**2+1e-8))*g[s]-r*(f*C*n[o]*l[e]*l[t]/Math.sqrt(M**2+C**2+1e-8))*v[s])}}return{localJacobianMatrix:b,localResidualVector:y,ngl:g}}const E={},v={},M={currentElementIndex:0},C={};let D;function $(e,t,i,a={}){const l=c(t),d=t.nodesXCoordinates.length,u=t.totalElements;!function(e,t){E.nodalNumbering=Array(t).fill().map((()=>Array(e).fill(0))),E.nodeConstraintCode=Array(e).fill(0),E.boundaryValues=Array(e).fill(0),E.globalResidualVector=Array(e).fill(0),E.solutionVector=Array(e).fill(0),E.topologyData=Array(t).fill(0),E.lateralData=Array(t).fill(0),v.writeFlag=0,v.totalNodes=e,v.transformationFlag=0,v.nodesPerElement=Array(t).fill(0),v.determinant=1;const n=Math.max(e,2e3);v.globalSolutionVector=Array(n).fill(0),v.frontDataIndex=0,M.localJacobianMatrix=Array(e).fill().map((()=>Array(e).fill(0))),M.currentElementIndex=0;const o=function(e,t){const n=Math.max(Math.ceil(Math.sqrt(t))*e,2*e);return n*t}(e,t);C.frontValues=Array(o).fill(0),C.columnHeaders=Array(n).fill(0),C.pivotRow=Array(n).fill(0),C.pivotData=Array(o).fill(0)}(l.numNodes,u),o("Solving system using frontal..."),console.time("systemSolving"),D=new r({meshDimension:t.meshDimension,elementOrder:t.elementOrder});for(let e=0;e<t.totalElements;e++)for(let n=0;n<l.numNodes;n++)E.nodalNumbering[e][n]=t.nop[e][n];for(let e=0;e<t.nodesXCoordinates.length;e++)E.nodeConstraintCode[e]=0,E.boundaryValues[e]=0;let m;e===p?(m=new f(i,t.boundaryElements,t.nop,t.meshDimension,t.elementOrder),m.imposeConstantTempBoundaryConditionsFront(E.nodeConstraintCode,E.boundaryValues)):e===g&&(m=new b(i,t.boundaryElements,t.nop,t.meshDimension,t.elementOrder),m.imposeConstantValueBoundaryConditionsFront(E.nodeConstraintCode,E.boundaryValues));for(let e=0;e<t.nodesXCoordinates.length;e++)E.globalResidualVector[e]=0;v.totalNodes=t.nodesXCoordinates.length,v.writeFlag=0,v.transformationFlag=1,v.determinant=1;for(let e=0;e<t.totalElements;e++)v.nodesPerElement[e]=l.numNodes;v.currentSolutionVector=a.solutionVector,v.eikonalActivationFlag=a.eikonalActivationFlag,function(e,t,o,i){const r=e.totalElements,a=e.nodesXCoordinates.length,l=Math.max(a,v.globalSolutionVector.length);let d,u=Array(t.numNodes).fill(0),c=Array(t.numNodes).fill(0),m=Array(l).fill(0),h=Array(l).fill(0),f=Array(l).fill(0),p=Array(l).fill(0),b=Array(l).fill(0),y=Array(l).fill().map((()=>Array(l).fill(0))),g=Array(a).fill(0),D=Array(a).fill(0),$=Array(a).fill(0),A=1;v.writeFlag++;let N=1,w=1;M.currentElementIndex=0;for(let e=0;e<v.totalNodes;e++)g[e]=0,D[e]=0;if(0!==v.transformationFlag){for(let e=0;e<v.totalNodes;e++)$[e]=0;for(let e=0;e<r;e++){let t=r-e-1;for(let e=0;e<v.nodesPerElement[t];e++){let n=E.nodalNumbering[t][e];0===$[n-1]&&($[n-1]=1,E.nodalNumbering[t][e]=-E.nodalNumbering[t][e])}}}v.transformationFlag=0;let O=0,S=0;for(let e=0;e<l;e++)for(let t=0;t<l;t++)y[t][e]=0;for(;;){let a=!1,$=0,X=0;if(M.currentElementIndex<r&&(M.currentElementIndex++,a=F(e,t,o,i)),a){const e=M.currentElementIndex;$=v.nodesPerElement[e-1],X=v.nodesPerElement[e-1];for(let t=0;t<X;t++){let n,o,s=E.nodalNumbering[e-1][t];if(0===O)O++,u[t]=O,C.columnHeaders[O-1]=s;else{for(n=0;n<O&&Math.abs(s)!==Math.abs(C.columnHeaders[n]);n++);n===O?(O++,u[t]=O,C.columnHeaders[O-1]=s):(u[t]=n+1,C.columnHeaders[n]=s)}if(0===S)S++,c[t]=S,m[S-1]=s;else{for(o=0;o<S&&Math.abs(s)!==Math.abs(m[o]);o++);o===S?(S++,c[t]=S,m[S-1]=s):(c[t]=o+1,m[o]=s)}}if(S>l||O>l)return void s("Error: systemSize not large enough");for(let e=0;e<X;e++){let t=u[e];for(let n=0;n<$;n++){y[c[n]-1][t-1]+=M.localJacobianMatrix[n][e]}}}let V=0;for(let e=0;e<O;e++)C.columnHeaders[e]<0&&(f[V]=e+1,V++);let T=0,k=0;for(let e=0;e<S;e++){let t=m[e];if(t<0){h[k]=e+1,k++;let n=Math.abs(t);1===E.nodeConstraintCode[n-1]&&(p[T]=e+1,T++,E.nodeConstraintCode[n-1]=2,E.globalResidualVector[n-1]=E.boundaryValues[n-1])}}if(T>0)for(let e=0;e<T;e++){let t=p[e]-1,n=Math.abs(m[t]);for(let e=0;e<O;e++){y[t][e]=0,Math.abs(C.columnHeaders[e])===n&&(y[t][e]=1)}}if(V>w||M.currentElementIndex<r){if(0===V)return void s("Error: no more rows fully summed");let e=h[0],t=f[0],o=y[e-1][t-1];if(Math.abs(o)<1e-4){o=0;for(let n=0;n<V;n++){let s=f[n];for(let n=0;n<k;n++){let i=h[n],r=y[i-1][s-1];Math.abs(r)>Math.abs(o)&&(o=r,t=s,e=i)}}}let i=Math.abs(m[e-1]);d=Math.abs(C.columnHeaders[t-1]);let a=i+d+g[i-1]+D[d-1];v.determinant=v.determinant*o*(-1)**a/Math.abs(o);for(let e=0;e<v.totalNodes;e++)e>=i&&g[e]--,e>=d&&D[e]--;if(Math.abs(o)<1e-10&&s(`Matrix singular or ill-conditioned, currentElementIndex=${M.currentElementIndex}, pivotGlobalRowIndex=${i}, pivotColumnGlobalIndex=${d}, pivotValue=${o}`),0===o)return;for(let t=0;t<O;t++)C.pivotRow[t]=y[e-1][t]/o;let l=E.globalResidualVector[i-1]/o;if(E.globalResidualVector[i-1]=l,b[e-1]=o,e>1)for(let n=0;n<e-1;n++){let e=Math.abs(m[n]),o=y[n][t-1];if(b[n]=o,t>1&&0!==o)for(let e=0;e<t-1;e++)y[n][e]-=o*C.pivotRow[e];if(t<O)for(let e=t;e<O;e++)y[n][e-1]=y[n][e]-o*C.pivotRow[e];E.globalResidualVector[e-1]-=o*l}if(e<S)for(let n=e;n<S;n++){let e=Math.abs(m[n]),o=y[n][t-1];if(b[n]=o,t>1)for(let e=0;e<t-1;e++)y[n-1][e]=y[n][e]-o*C.pivotRow[e];if(t<O)for(let e=t;e<O;e++)y[n-1][e-1]=y[n][e]-o*C.pivotRow[e];E.globalResidualVector[e-1]-=o*l}for(let e=0;e<S;e++)C.pivotData[N+e-1]=b[e];N+=S;for(let e=0;e<S;e++)C.pivotData[N+e-1]=m[e];N+=S,C.pivotData[N-1]=e,N++;for(let e=0;e<O;e++)C.frontValues[A-1+e]=C.pivotRow[e];A+=O;for(let e=0;e<O;e++)C.frontValues[A-1+e]=C.columnHeaders[e];A+=O,C.frontValues[A-1]=i,C.frontValues[A]=O,C.frontValues[A+1]=t,C.frontValues[A+2]=o,A+=4;for(let e=0;e<S;e++)y[e][O-1]=0;for(let e=0;e<O;e++)y[S-1][e]=0;if(O--,t<O+1)for(let e=t-1;e<O;e++)C.columnHeaders[e]=C.columnHeaders[e+1];if(S--,e<S+1)for(let t=e-1;t<S;t++)m[t]=m[t+1];if(S>1||M.currentElementIndex<r)continue;if(d=Math.abs(C.columnHeaders[0]),e=1,o=y[0][0],i=Math.abs(m[0]),t=1,a=i+d+g[i-1]+D[d-1],v.determinant=v.determinant*o*(-1)**a/Math.abs(o),C.pivotRow[0]=1,Math.abs(o)<1e-10&&s(`Matrix singular or ill-conditioned, currentElementIndex=${M.currentElementIndex}, pivotGlobalRowIndex=${i}, pivotColumnGlobalIndex=${d}, pivotValue=${o}`),0===o)return;E.globalResidualVector[i-1]=E.globalResidualVector[i-1]/o,C.frontValues[A-1]=C.pivotRow[0],A++,C.frontValues[A-1]=C.columnHeaders[0],A++,C.frontValues[A-1]=i,C.frontValues[A]=O,C.frontValues[A+1]=t,C.frontValues[A+2]=o,A+=4,C.pivotData[N-1]=b[0],N++,C.pivotData[N-1]=m[0],N++,C.pivotData[N-1]=e,N++,v.frontDataIndex=A,1===v.writeFlag&&n(`total ecs transfer in matrix reduction=${A}`),x(A);break}}}(t,l,m,e);for(let e=0;e<t.nodesXCoordinates.length;e++)E.solutionVector[e]=v.globalSolutionVector[e];const{nodesXCoordinates:h,nodesYCoordinates:y}=t;for(let e=0;e<t.nodesXCoordinates.length;e++)"1D"===t.meshDimension?n(`${h[e].toExponential(5)}  ${E.solutionVector[e].toExponential(5)}`):n(`${h[e].toExponential(5)}  ${y[e].toExponential(5)}  ${E.solutionVector[e].toExponential(5)}`);console.timeEnd("systemSolving"),o("System solved successfully");const{nodesXCoordinates:$,nodesYCoordinates:A}=t;return{solutionVector:E.solutionVector.slice(0,d),nodesCoordinates:{nodesXCoordinates:$,nodesYCoordinates:A}}}function F(e,t,n,o){const i=M.currentElementIndex-1;if(i<0||i>=e.totalElements)return s(`Skipping out-of-range elementIndex=${i} (totalElements=${e.totalElements})`),!1;const{localJacobianMatrix:r,localResidualVector:a,ngl:l}=o({elementIndex:i,nop:E.nodalNumbering,meshData:e,basisFunctions:D,FEAData:t,solutionVector:v.currentSolutionVector,eikonalActivationFlag:v.eikonalActivationFlag});let d=Array(t.numNodes).fill().map((()=>Array(t.numNodes).fill(0))),u=Array(t.numNodes).fill(0);if(o===p){let o=!1;for(const t in e.boundaryElements)if("convection"===n.boundaryConditions[t]?.[0]&&e.boundaryElements[t].some((([e,t])=>e===i))){o=!0;break}if(o){const{gaussPoints:o,gaussWeights:s}=t,r=n.imposeConvectionBoundaryConditionsFront(i,e.nodesXCoordinates,e.nodesYCoordinates,o,s,D);d=r.localJacobianMatrix,u=r.localResidualVector}}for(let e=0;e<t.numNodes;e++)for(let n=0;n<t.numNodes;n++)M.localJacobianMatrix[e][n]=r[e][n]+d[e][n];for(let e=0;e<t.numNodes;e++){const t=l[e]-1;E.globalResidualVector[t]+=a[e]+u[e]}return!0}function x(e){for(let e=0;e<v.totalNodes;e++)v.globalSolutionVector[e]=E.boundaryValues[e];for(let t=1;t<=v.totalNodes;t++){e-=4;let n=C.frontValues[e-1],o=C.frontValues[e],s=C.frontValues[e+1];if(C.frontValues[e+2],1===t)e--,C.columnHeaders[0]=C.frontValues[e-1],e--,C.pivotRow[0]=C.frontValues[e-1];else{e-=o;for(let t=0;t<o;t++)C.columnHeaders[t]=C.frontValues[e-1+t];e-=o;for(let t=0;t<o;t++)C.pivotRow[t]=C.frontValues[e-1+t]}let i=Math.abs(C.columnHeaders[s-1]);if(E.nodeConstraintCode[i-1]>0)continue;let r=0;C.pivotRow[s-1]=0;for(let e=0;e<o;e++)r-=C.pivotRow[e]*v.globalSolutionVector[Math.abs(C.columnHeaders[e])-1];v.globalSolutionVector[i-1]=r+E.globalResidualVector[n-1],E.nodeConstraintCode[i-1]=1}1===v.writeFlag&&n(`value of frontDataCounter after backsubstitution=${e}`)}function A(t,n,r=100,a=1e-4){let l=0,d=!1,u=0,c=[],m=[],h=[],f=[],p=n.meshData.nodesXCoordinates.length;for(let e=0;e<p;e++)c[e]=0,m[e]=0;for(n.initialSolution&&n.initialSolution.length===p&&(m=[...n.initialSolution]);u<r&&!d;){for(let e=0;e<m.length;e++)m[e]=Number(m[e])+Number(c[e]);if("frontal"===n.solverMethod){c=$(g,n.meshData,n.boundaryConditions,{solutionVector:m,eikonalActivationFlag:n.eikonalActivationFlag}).solutionVector}else{({jacobianMatrix:h,residualVector:f}=t(n.meshData,n.boundaryConditions,m,n.eikonalActivationFlag));c=i(n.solverMethod,h,f).solutionVector}if(l=e(c),o(`Newton-Raphson iteration ${u+1}: Error norm = ${l.toExponential(4)}`),l<=a)d=!0;else if(l>100){s(`Solution not converged. Error norm: ${l}`);break}u++}return{solutionVector:m,converged:d,iterations:u,jacobianMatrix:h,residualVector:f}}
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const N=Symbol("Comlink.proxy"),w=Symbol("Comlink.endpoint"),O=Symbol("Comlink.releaseProxy"),S=Symbol("Comlink.finalizer"),X=Symbol("Comlink.thrown"),V=e=>"object"==typeof e&&null!==e||"function"==typeof e,T=new Map([["proxy",{canHandle:e=>V(e)&&e[N],serialize(e){const{port1:t,port2:n}=new MessageChannel;return k(e,t),[n,[n]]},deserialize:e=>(e.start(),R(e))}],["throw",{canHandle:e=>V(e)&&X in e,serialize({value:e}){let t;return t=e instanceof Error?{isError:!0,value:{message:e.message,name:e.name,stack:e.stack}}:{isError:!1,value:e},[t,[]]},deserialize(e){if(e.isError)throw Object.assign(new Error(e.value.message),e.value);throw e.value}}]]);function k(e,t=globalThis,n=["*"]){t.addEventListener("message",(function o(s){if(!s||!s.data)return;if(!function(e,t){for(const n of e){if(t===n||"*"===n)return!0;if(n instanceof RegExp&&n.test(t))return!0}return!1}(n,s.origin))return void console.warn(`Invalid origin '${s.origin}' for comlink proxy`);const{id:i,type:r,path:a}=Object.assign({path:[]},s.data),l=(s.data.argumentList||[]).map(J);let d;try{const t=a.slice(0,-1).reduce(((e,t)=>e[t]),e),n=a.reduce(((e,t)=>e[t]),e);switch(r){case"GET":d=n;break;case"SET":t[a.slice(-1)[0]]=J(s.data.value),d=!0;break;case"APPLY":d=n.apply(t,l);break;case"CONSTRUCT":d=function(e){return Object.assign(e,{[N]:!0})}(new n(...l));break;case"ENDPOINT":{const{port1:t,port2:n}=new MessageChannel;k(e,n),d=function(e,t){return G.set(e,t),e}(t,[t])}break;case"RELEASE":d=void 0;break;default:return}}catch(e){d={value:e,[X]:0}}Promise.resolve(d).catch((e=>({value:e,[X]:0}))).then((n=>{const[s,a]=K(n);t.postMessage(Object.assign(Object.assign({},s),{id:i}),a),"RELEASE"===r&&(t.removeEventListener("message",o),P(t),S in e&&"function"==typeof e[S]&&e[S]())})).catch((e=>{const[n,o]=K({value:new TypeError("Unserializable return value"),[X]:0});t.postMessage(Object.assign(Object.assign({},n),{id:i}),o)}))})),t.start&&t.start()}function P(e){(function(e){return"MessagePort"===e.constructor.name})(e)&&e.close()}function R(e,t){const n=new Map;return e.addEventListener("message",(function(e){const{data:t}=e;if(!t||!t.id)return;const o=n.get(t.id);if(o)try{o(t)}finally{n.delete(t.id)}})),j(e,n,[],t)}function Y(e){if(e)throw new Error("Proxy has been released and is not useable")}function I(e){return H(e,new Map,{type:"RELEASE"}).then((()=>{P(e)}))}const B=new WeakMap,q="FinalizationRegistry"in globalThis&&new FinalizationRegistry((e=>{const t=(B.get(e)||0)-1;B.set(e,t),0===t&&I(e)}));function j(e,t,n=[],o=function(){}){let s=!1;const i=new Proxy(o,{get(o,r){if(Y(s),r===O)return()=>{!function(e){q&&q.unregister(e)}(i),I(e),t.clear(),s=!0};if("then"===r){if(0===n.length)return{then:()=>i};const o=H(e,t,{type:"GET",path:n.map((e=>e.toString()))}).then(J);return o.then.bind(o)}return j(e,t,[...n,r])},set(o,i,r){Y(s);const[a,l]=K(r);return H(e,t,{type:"SET",path:[...n,i].map((e=>e.toString())),value:a},l).then(J)},apply(o,i,r){Y(s);const a=n[n.length-1];if(a===w)return H(e,t,{type:"ENDPOINT"}).then(J);if("bind"===a)return j(e,t,n.slice(0,-1));const[l,d]=W(r);return H(e,t,{type:"APPLY",path:n.map((e=>e.toString())),argumentList:l},d).then(J)},construct(o,i){Y(s);const[r,a]=W(i);return H(e,t,{type:"CONSTRUCT",path:n.map((e=>e.toString())),argumentList:r},a).then(J)}});return function(e,t){const n=(B.get(t)||0)+1;B.set(t,n),q&&q.register(e,t,e)}(i,e),i}function W(e){const t=e.map(K);return[t.map((e=>e[0])),(n=t.map((e=>e[1])),Array.prototype.concat.apply([],n))];var n}const G=new WeakMap;function K(e){for(const[t,n]of T)if(n.canHandle(e)){const[o,s]=n.serialize(e);return[{type:"HANDLER",name:t,value:o},s]}return[{type:"RAW",value:e},G.get(e)||[]]}function J(e){switch(e.type){case"HANDLER":return T.get(e.name).deserialize(e.value);case"RAW":return e.value}}function H(e,t,n,o){return new Promise((s=>{const i=new Array(4).fill(0).map((()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16))).join("-");t.set(i,s),e.start&&e.start(),e.postMessage(Object.assign({id:i},n),o)}))}exports.FEAScriptModel=class{constructor(){this.solverConfig=null,this.meshConfig={},this.boundaryConditions={},this.solverMethod="lusolve",this.coefficientFunctions=null,o("FEAScriptModel instance created")}setSolverConfig(e,t={}){this.solverConfig=e,t&&t.coefficientFunctions&&(this.coefficientFunctions=t.coefficientFunctions,n("Coefficient functions set")),n(`Solver config set to: ${e}`)}setMeshConfig(e){this.meshConfig=e,n(`Mesh config set with dimensions: ${e.meshDimension}`)}addBoundaryCondition(e,t){this.boundaryConditions[e]=t,n(`Boundary condition added for boundary: ${e}, type: ${t[0]}`)}setSolverMethod(e){this.solverMethod=e,n(`Solver method set to: ${e}`)}solve(){if(!this.solverConfig||!this.meshConfig||!this.boundaryConditions){const e="Solver config, mesh config, and boundary conditions must be set before solving.";throw console.error(e),new Error(e)}let e=[],t=[],r=[],a=[];o("Preparing mesh...");const u=function(e){const{meshDimension:t,numElementsX:o,numElementsY:i,maxX:r,maxY:a,elementOrder:u,parsedMesh:c}=e;let m;"1D"===t?m=new l({numElementsX:o,maxX:r,elementOrder:u,parsedMesh:c}):"2D"===t?m=new d({numElementsX:o,maxX:r,numElementsY:i,maxY:a,elementOrder:u,parsedMesh:c}):s("Mesh dimension must be either '1D' or '2D'.");const h=m.boundaryElementsProcessed?m.parsedMesh:m.generateMesh();let f,p,b=h.nodesXCoordinates,y=h.nodesYCoordinates,g=h.totalNodesX,E=h.totalNodesY,v=h.nodalNumbering,M=h.boundaryElements;return null!=c?(f=v.length,p=b.length,n(`Using parsed mesh with ${f} elements and ${p} nodes`)):(f=o*("2D"===t?i:1),p=g*("2D"===t?E:1),n(`Using mesh generated from geometry with ${f} elements and ${p} nodes`)),{nodesXCoordinates:b,nodesYCoordinates:y,totalNodesX:g,totalNodesY:E,nop:v,boundaryElements:M,totalElements:f,totalNodes:p,meshDimension:t,elementOrder:u}}(this.meshConfig);o("Mesh preparation completed");const g={nodesXCoordinates:u.nodesXCoordinates,nodesYCoordinates:u.nodesYCoordinates};if(o("Beginning solving process..."),console.time("totalSolvingTime"),"heatConductionScript"===this.solverConfig)if(o(`Using solver: ${this.solverConfig}`),"frontal"===this.solverMethod){r=$(p,u,this.boundaryConditions).solutionVector}else{({jacobianMatrix:e,residualVector:t}=function(e,t){o("Starting solid heat transfer matrix assembly...");const{nodesXCoordinates:n,nodesYCoordinates:s,nop:i,boundaryElements:r,totalElements:a,meshDimension:l,elementOrder:d}=e,u=c(e),{residualVector:p,jacobianMatrix:b,localToGlobalMap:y,basisFunctions:g,gaussPoints:E,gaussWeights:v,numNodes:M}=u;for(let e=0;e<a;e++){for(let t=0;t<M;t++)y[t]=i[e][t]-1;for(let e=0;e<E.length;e++)if("1D"===l){const t=g.getBasisFunctions(E[e]),o=m({basisFunction:t.basisFunction,basisFunctionDerivKsi:t.basisFunctionDerivKsi,nodesXCoordinates:n,localToGlobalMap:y,numNodes:M}),{detJacobian:s,basisFunctionDerivX:i}=o;for(let t=0;t<M;t++){let n=y[t];for(let o=0;o<M;o++){let r=y[o];b[n][r]+=-v[e]*s*(i[t]*i[o])}}}else if("2D"===l)for(let t=0;t<E.length;t++){const o=g.getBasisFunctions(E[e],E[t]),i=h({basisFunction:o.basisFunction,basisFunctionDerivKsi:o.basisFunctionDerivKsi,basisFunctionDerivEta:o.basisFunctionDerivEta,nodesXCoordinates:n,nodesYCoordinates:s,localToGlobalMap:y,numNodes:M}),{detJacobian:r,basisFunctionDerivX:a,basisFunctionDerivY:l}=i;for(let n=0;n<M;n++){let o=y[n];for(let s=0;s<M;s++){let i=y[s];b[o][i]+=-v[e]*v[t]*r*(a[n]*a[s]+l[n]*l[s])}}}}const C=new f(t,r,i,l,d);return C.imposeConvectionBoundaryConditions(p,b,E,v,n,s,g),C.imposeConstantTempBoundaryConditions(p,b),o("Solid heat transfer matrix assembly completed"),{jacobianMatrix:b,residualVector:p}}(u,this.boundaryConditions));r=i(this.solverMethod,e,t).solutionVector}else if("frontPropagationScript"===this.solverConfig){o(`Using solver: ${this.solverConfig}`);let n=0;const s=5,i={meshData:u,boundaryConditions:this.boundaryConditions,eikonalActivationFlag:n,solverMethod:this.solverMethod,initialSolution:a};for(;n<=1;){i.eikonalActivationFlag=n,r.length>0&&(i.initialSolution=[...r]);const o=A(y,i,100,1e-4);e=o.jacobianMatrix,t=o.residualVector,r=o.solutionVector,n+=1/s}}else if("generalFormPDEScript"===this.solverConfig)if(o(`Using solver: ${this.solverConfig}`),"frontal"===this.solverMethod)s("Frontal solver is not yet supported for generalFormPDEScript. Please use 'lusolve' or 'jacobi'.");else{({jacobianMatrix:e,residualVector:t}=function(e,t,n){o("Starting general form PDE matrix assembly...");const{nodesXCoordinates:i,nodesYCoordinates:r,nop:a,boundaryElements:l,totalElements:d,meshDimension:u,elementOrder:h}=e,{A:f,B:p,C:y,D:g}=n,E=c(e),{residualVector:v,jacobianMatrix:M,localToGlobalMap:C,basisFunctions:D,gaussPoints:$,gaussWeights:F,numNodes:x}=E;if("1D"===u)for(let e=0;e<d;e++){for(let t=0;t<x;t++)C[t]=Math.abs(a[e][t])-1;for(let e=0;e<$.length;e++){const{basisFunction:t,basisFunctionDerivKsi:n}=D.getBasisFunctions($[e]),{detJacobian:o,basisFunctionDerivX:s}=m({basisFunction:t,basisFunctionDerivKsi:n,nodesXCoordinates:i,localToGlobalMap:C,numNodes:x});let r=0;for(let e=0;e<x;e++)r+=i[C[e]]*t[e];const a=f(r),l=p(r),d=y(r),u=g(r);for(let n=0;n<x;n++){const i=C[n];v[i]-=F[e]*o*u*t[n];for(let r=0;r<x;r++){const u=C[r];M[i][u]+=F[e]*o*a*s[n]*s[r],M[i][u]-=F[e]*o*l*s[r]*t[n],M[i][u]+=F[e]*o*d*t[n]*t[r]}}}}else"2D"===u&&s("2D general form PDE is not yet supported in assembleGeneralFormPDEMat.");return new b(t,l,a,u,h).imposeDirichletBoundaryConditions(v,M),o("General form PDE matrix assembly completed"),{jacobianMatrix:M,residualVector:v}}(u,this.boundaryConditions,this.coefficientFunctions));r=i(this.solverMethod,e,t).solutionVector}return console.timeEnd("totalSolvingTime"),o("Solving process completed"),{solutionVector:r,nodesCoordinates:g}}},exports.FEAScriptWorker=class{constructor(){this.worker=null,this.feaWorker=null,this.isReady=!1,this._initWorker()}async _initWorker(){try{this.worker=new Worker(new URL("./wrapperScript.js","undefined"==typeof document?new(require("url").URL)("file:"+__filename).href:document.currentScript&&"SCRIPT"===document.currentScript.tagName.toUpperCase()&&document.currentScript.src||new URL("feascript.cjs.js",document.baseURI).href),{type:"module"}),this.worker.onerror=e=>{console.error("FEAScriptWorker: Worker error:",e)};const e=R(this.worker);this.feaWorker=await new e,this.isReady=!0}catch(e){throw console.error("Failed to initialize worker",e),e}}async _ensureReady(){return this.isReady?Promise.resolve():new Promise(((e,t)=>{let n=0;const o=()=>{n++,this.isReady?e():n>=50?t(new Error("Timeout waiting for worker to be ready")):setTimeout(o,1e3)};o()}))}async setSolverConfig(e){return await this._ensureReady(),o(`FEAScriptWorker: Setting solver config to: ${e}`),this.feaWorker.setSolverConfig(e)}async setMeshConfig(e){return await this._ensureReady(),o("FEAScriptWorker: Setting mesh config"),this.feaWorker.setMeshConfig(e)}async addBoundaryCondition(e,t){return await this._ensureReady(),o(`FEAScriptWorker: Adding boundary condition for boundary: ${e}`),this.feaWorker.addBoundaryCondition(e,t)}async setSolverMethod(e){return await this._ensureReady(),o(`FEAScriptWorker: Setting solver method to: ${e}`),this.feaWorker.setSolverMethod(e)}async solve(){await this._ensureReady(),o("FEAScriptWorker: Requesting solution from worker...");const e=performance.now(),t=await this.feaWorker.solve();return o(`FEAScriptWorker: Solution completed in ${((performance.now()-e)/1e3).toFixed(2)}s`),t}async getModelInfo(){return await this._ensureReady(),this.feaWorker.getModelInfo()}async ping(){return await this._ensureReady(),this.feaWorker.ping()}terminate(){this.worker&&(this.worker.terminate(),this.worker=null,this.feaWorker=null,this.isReady=!1)}},exports.importGmshQuadTri=async e=>{let t={nodesXCoordinates:[],nodesYCoordinates:[],nodalNumbering:{quadElements:[],triangleElements:[]},boundaryElements:[],boundaryConditions:[],boundaryNodePairs:{},gmshV:0,ascii:!1,fltBytes:"8",totalNodesX:0,totalNodesY:0,physicalPropMap:[],elementTypes:{}},o=(await e.text()).split("\n").map((e=>e.trim())).filter((e=>""!==e&&" "!==e)),s="",i=0,r=0,a=0,l=0,d={numNodes:0},u=0,c=[],m=0,h=0,f=0,p={dim:0,tag:0,elementType:0,numElements:0},b=0,y={};for(;i<o.length;){const e=o[i];if("$MeshFormat"===e){s="meshFormat",i++;continue}if("$EndMeshFormat"===e){s="",i++;continue}if("$PhysicalNames"===e){s="physicalNames",i++;continue}if("$EndPhysicalNames"===e){s="",i++;continue}if("$Entities"===e){s="entities",i++;continue}if("$EndEntities"===e){s="",i++;continue}if("$Nodes"===e){s="nodes",i++;continue}if("$EndNodes"===e){s="",i++;continue}if("$Elements"===e){s="elements",i++;continue}if("$EndElements"===e){s="",i++;continue}const n=e.split(/\s+/).filter((e=>""!==e));if("meshFormat"===s)t.gmshV=parseFloat(n[0]),t.ascii="0"===n[1],t.fltBytes=n[2];else if("physicalNames"===s){if(n.length>=3){if(!/^\d+$/.test(n[0])){i++;continue}const e=parseInt(n[0],10),o=parseInt(n[1],10);let s=n.slice(2).join(" ");s=s.replace(/^"|"$/g,""),t.physicalPropMap.push({tag:o,dimension:e,name:s})}}else if("nodes"===s){if(0===r){r=parseInt(n[0],10),a=parseInt(n[1],10),t.nodesXCoordinates=new Array(a).fill(0),t.nodesYCoordinates=new Array(a).fill(0),i++;continue}if(l<r&&0===d.numNodes){d={dim:parseInt(n[0],10),tag:parseInt(n[1],10),parametric:parseInt(n[2],10),numNodes:parseInt(n[3],10)},c=[],u=0,m=0,i++;continue}if(u<d.numNodes){for(let e=0;e<n.length&&u<d.numNodes;e++)c.push(parseInt(n[e],10)),u++;if(u<d.numNodes){i++;continue}i++;continue}if(m<d.numNodes){const e=c[m]-1,o=parseFloat(n[0]),s=parseFloat(n[1]);t.nodesXCoordinates[e]=o,t.nodesYCoordinates[e]=s,t.totalNodesX++,t.totalNodesY++,m++,m===d.numNodes&&(l++,d={numNodes:0})}}else if("elements"===s){if(0===h){h=parseInt(n[0],10),parseInt(n[1],10),i++;continue}if(f<h&&0===p.numElements){p={dim:parseInt(n[0],10),tag:parseInt(n[1],10),elementType:parseInt(n[2],10),numElements:parseInt(n[3],10)},t.elementTypes[p.elementType]=(t.elementTypes[p.elementType]||0)+p.numElements,b=0,i++;continue}if(b<p.numElements){parseInt(n[0],10);const e=n.slice(1).map((e=>parseInt(e,10)));if(1===p.elementType||8===p.elementType){const n=p.tag;y[n]||(y[n]=[]),y[n].push(e),t.boundaryNodePairs[n]||(t.boundaryNodePairs[n]=[]),t.boundaryNodePairs[n].push(e)}else 2===p.elementType?t.nodalNumbering.triangleElements.push(e):(3===p.elementType||10===p.elementType)&&t.nodalNumbering.quadElements.push(e);b++,b===p.numElements&&(f++,p={numElements:0})}}i++}return t.physicalPropMap.forEach((e=>{if(1===e.dimension){const n=y[e.tag]||[];n.length>0&&t.boundaryConditions.push({name:e.name,tag:e.tag,nodes:n})}})),n(`Parsed boundary node pairs by physical tag: ${JSON.stringify(t.boundaryNodePairs)}. These pairs will be used to identify boundary elements in the mesh.`),t},exports.logSystem=function(e){"basic"!==e&&"debug"!==e?(console.log("%c[WARN] Invalid log level: "+e+". Using basic instead.","color: #FFC107; font-weight: bold;"),t="basic"):(t=e,o(`Log level set to: ${e}`))},exports.plotSolution=function(e,t,n,o,s,i,r="structured"){const{nodesXCoordinates:a,nodesYCoordinates:l}=t;if("1D"===o&&"line"===s){let t;t=e.length>0&&Array.isArray(e[0])?e.map((e=>e[0])):e;let o=Array.from(a),s={x:o,y:t,mode:"lines",type:"scatter",line:{color:"rgb(219, 64, 82)",width:2},name:"Solution"},r=Math.min(window.innerWidth,700),l=Math.max(...o),d=r/l,u={title:`line plot - ${n}`,width:Math.max(d*l,400),height:350,xaxis:{title:"x"},yaxis:{title:"Solution"},margin:{l:70,r:40,t:50,b:50}};Plotly.newPlot(i,[s],u,{responsive:!0})}else if("2D"===o&&"contour"===s){const t="structured"===r,o=new Set(a).size,d=new Set(l).size;let u;u=Array.isArray(e[0])?e.map((e=>e[0])):e;let c=Math.min(window.innerWidth,700),m=Math.max(...a),h=Math.max(...l)/m,f=Math.min(c,600),p={title:`${s} plot - ${n}`,width:f,height:f*h*.8,xaxis:{title:"x"},yaxis:{title:"y"},margin:{l:50,r:50,t:50,b:50},hovermode:"closest"};if(t){const t=o,n=d;math.reshape(Array.from(a),[t,n]);let s=math.reshape(Array.from(l),[t,n]),r=math.reshape(Array.from(e),[t,n]),u=math.transpose(r),c=[];for(let e=0;e<t*n;e+=n){let t=a[e];c.push(t)}let m={z:u,type:"contour",contours:{coloring:"heatmap",showlabels:!1},colorbar:{title:"Solution"},x:c,y:s[0],name:"Solution Field"};Plotly.newPlot(i,[m],p,{responsive:!0})}else{let e={x:a,y:l,z:u,type:"contour",contours:{coloring:"heatmap",showlabels:!1},colorbar:{title:"Solution"},name:"Solution Field"};Plotly.newPlot(i,[e],p,{responsive:!0})}}},exports.printVersion="0.1.3";
//# sourceMappingURL=feascript.cjs.js.map
