"use strict";function e(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n]*e[n];return t=Math.sqrt(t),t}Object.defineProperty(exports,"__esModule",{value:!0});let t="basic";function n(e){"debug"===t&&console.log("%c[DEBUG] "+e,"color: #2196F3; font-weight: bold;")}function o(e){console.log("%c[INFO] "+e,"color: #4CAF50; font-weight: bold;")}function s(e){console.log("%c[ERROR] "+e,"color: #F44336; font-weight: bold;")}function i(e,t,i,d={}){const{maxIterations:m=1e3,tolerance:u=1e-9}=d,h=e.length;let c=[...i],f=r(e,t,c),p=[...f],g=l(f,f),y=0,b=!1;for(o(`Starting CPU Conjugate Gradient solver for system of size ${h}`);y<m&&!b;){const t=a(e,p),o=l(p,t);if(Math.abs(o)<1e-16){s("Matrix is not positive definite or numerical breakdown occurred");break}const i=g/o;for(let e=0;e<h;e++)c[e]=Number(c[e])+Number(i*p[e]);for(let e=0;e<h;e++)f[e]=Number(f[e])-Number(i*t[e]);const r=l(f,f),d=Math.sqrt(r);if(d<u){b=!0,n(`CPU CG converged in ${y+1} iterations with residual norm ${d.toExponential(6)}`);break}const m=r/g;for(let e=0;e<h;e++)p[e]=Number(f[e])+Number(m*p[e]);g=r,y++,y%100==0&&n(`CPU CG iteration ${y}: residual norm = ${d.toExponential(6)}`)}const E=Math.sqrt(l(f,f));return b||n(`CPU CG did not converge after ${m} iterations. Final residual norm: ${E.toExponential(6)}`),{solutionVector:c,iterations:y,converged:b,residualNorm:E}}function r(e,t,n){const o=e.length,s=new Array(o);for(let i=0;i<o;i++){let r=0;for(let t=0;t<o;t++)r+=Number(e[i][t])*Number(n[t]);s[i]=Number(t[i])-r}return s}function a(e,t){const n=e.length,o=new Array(n);for(let s=0;s<n;s++){let i=0;for(let o=0;o<n;o++)i+=Number(e[s][o])*Number(t[o]);o[s]=i}return o}function l(e,t){let n=0;for(let o=0;o<e.length;o++)n+=Number(e[o])*Number(t[o]);return n}async function d(e,t,d,m={}){const{maxIterations:u=1e3,tolerance:h=1e-6}=m;let c=[],f=!0,p=0;if(o(`Solving system using ${e}...`),console.time("systemSolving"),"lusolve"===e)c=math.lusolve(t,d);else if("jacobi"===e){const e=function(e,t,n,o={}){const{maxIterations:s=1e3,tolerance:i=1e-6}=o,r=e.length;let a=[...n],l=new Array(r);for(let n=0;n<s;n++){for(let n=0;n<r;n++){let o=0;for(let t=0;t<r;t++)t!==n&&(o+=e[n][t]*a[t]);l[n]=(t[n]-o)/e[n][n]}let o=0;for(let e=0;e<r;e++)o=Math.max(o,Math.abs(l[e]-a[e]));if(a=[...l],o<i)return{solutionVector:a,iterations:n+1,converged:!0}}return{solutionVector:a,iterations:s,converged:!1}}(t,d,new Array(d.length).fill(0),{maxIterations:u,tolerance:h});e.converged?n(`Jacobi method converged in ${e.iterations} iterations`):n(`Jacobi method did not converge after ${e.iterations} iterations`),c=e.solutionVector,f=e.converged,p=e.iterations}else if("conjugate-gradient-webgpu"===e){const e=new Array(d.length).fill(0),m=Math.min(h,1e-9),g=await async function(e,t,d,m={}){const{maxIterations:u=1e3,tolerance:h=1e-9,enablePrecision:c=!0}=m;if(!navigator.gpu)return n("WebGPU not available, falling back to CPU implementation"),i(e,t,d,m);try{const c=await navigator.gpu.requestAdapter();if(!c)return n("WebGPU adapter not available, falling back to CPU implementation"),i(e,t,d,m);await c.requestDevice();const f=e.length;let p=[...d],g=r(e,t,p),y=[...g],b=l(g,g),E=0,$=!1;for(o(`Starting WebGPU Conjugate Gradient solver for system of size ${f}`);E<u&&!$;){const t=a(e,y),o=l(y,t);if(Math.abs(o)<1e-16){s("Matrix is not positive definite or numerical breakdown occurred");break}const i=b/o;for(let e=0;e<f;e++)p[e]+=i*y[e];for(let e=0;e<f;e++)g[e]-=i*t[e];const r=l(g,g),d=Math.sqrt(r);if(d<h){$=!0,n(`WebGPU CG converged in ${E+1} iterations with residual norm ${d.toExponential(6)}`);break}const m=r/b;for(let e=0;e<f;e++)y[e]=g[e]+m*y[e];b=r,E++,E%100==0&&n(`WebGPU CG iteration ${E}: residual norm = ${d.toExponential(6)}`)}const v=Math.sqrt(l(g,g));return $||n(`WebGPU CG did not converge after ${u} iterations. Final residual norm: ${v.toExponential(6)}`),{solutionVector:p,iterations:E,converged:$,residualNorm:v}}catch(o){return s(`WebGPU error occurred: ${o.message}`),n("Falling back to CPU implementation"),i(e,t,d,m)}}(t,d,e,{maxIterations:u,tolerance:m,enablePrecision:!0});g.converged?n(`WebGPU Conjugate Gradient method converged in ${g.iterations} iterations with residual norm ${g.residualNorm.toExponential(6)}`):n(`WebGPU Conjugate Gradient method did not converge after ${g.iterations} iterations. Final residual norm: ${g.residualNorm.toExponential(6)}`),c=g.solutionVector,f=g.converged,p=g.iterations}else s(`Unknown solver method: ${e}`);return console.timeEnd("systemSolving"),o("System solved successfully"),{solutionVector:c,converged:f,iterations:p}}async function m(t,n,i=100,r=1e-4){let a=0,l=!1,m=0,u=[],h=[],c=[],f=[],p={},g=function(e){const{meshDimension:t,numElementsX:n,numElementsY:o,elementOrder:s,parsedMesh:i}=e;if(i&&i.nodesXCoordinates)return i.nodesXCoordinates.length;{let e,i=1;return"linear"===s?(e=n+1,"2D"===t&&(i=o+1)):"quadratic"===s&&(e=2*n+1,"2D"===t&&(i=2*o+1)),e*i}}(n.meshConfig);for(let e=0;e<g;e++)u[e]=0,h[e]=0;for(n.initialSolution&&n.initialSolution.length===g&&(h=[...n.initialSolution]);m<i&&!l;){for(let e=0;e<h.length;e++)h[e]=Number(h[e])+Number(u[e]);({jacobianMatrix:c,residualVector:f,nodesCoordinates:p}=t(n.meshConfig,n.boundaryConditions,h,n.eikonalActivationFlag));if(u=(await d(n.solverMethod,c,f)).solutionVector,a=e(u),o(`Newton-Raphson iteration ${m+1}: Error norm = ${a.toExponential(4)}`),a<=r)l=!0;else if(a>100){s(`Solution not converged. Error norm: ${a}`);break}m++}return{solutionVector:h,converged:l,iterations:m,jacobianMatrix:c,residualVector:f,nodesCoordinates:p}}class u{constructor(e,t,n,o,s){this.boundaryConditions=e,this.boundaryElements=t,this.nop=n,this.meshDimension=o,this.elementOrder=s}imposeConstantValueBoundaryConditions(e,t){o("Applying constant value boundary conditions (Dirichlet type)"),"1D"===this.meshDimension?Object.keys(this.boundaryConditions).forEach((o=>{if("constantValue"===this.boundaryConditions[o][0]){const s=this.boundaryConditions[o][1];n(`Boundary ${o}: Applying constant value of ${s} (Dirichlet condition)`),this.boundaryElements[o].forEach((([o,i])=>{if("linear"===this.elementOrder){({0:[0],1:[1]})[i].forEach((i=>{const r=this.nop[o][i]-1;n(`  - Applied constant value to node ${r+1} (element ${o+1}, local node ${i+1})`),e[r]=s;for(let n=0;n<e.length;n++)t[r][n]=0;t[r][r]=1}))}else if("quadratic"===this.elementOrder){({0:[0],2:[2]})[i].forEach((i=>{const r=this.nop[o][i]-1;n(`  - Applied constant value to node ${r+1} (element ${o+1}, local node ${i+1})`),e[r]=s;for(let n=0;n<e.length;n++)t[r][n]=0;t[r][r]=1}))}}))}})):"2D"===this.meshDimension&&Object.keys(this.boundaryConditions).forEach((o=>{if("constantValue"===this.boundaryConditions[o][0]){const s=this.boundaryConditions[o][1];n(`Boundary ${o}: Applying constant value of ${s} (Dirichlet condition)`),this.boundaryElements[o].forEach((([o,i])=>{if("linear"===this.elementOrder){({0:[0,2],1:[0,1],2:[1,3],3:[2,3]})[i].forEach((i=>{const r=this.nop[o][i]-1;n(`  - Applied constant value to node ${r+1} (element ${o+1}, local node ${i+1})`),e[r]=s;for(let n=0;n<e.length;n++)t[r][n]=0;t[r][r]=1}))}else if("quadratic"===this.elementOrder){({0:[0,3,6],1:[0,1,2],2:[2,5,8],3:[6,7,8]})[i].forEach((i=>{const r=this.nop[o][i]-1;n(`  - Applied constant value to node ${r+1} (element ${o+1}, local node ${i+1})`),e[r]=s;for(let n=0;n<e.length;n++)t[r][n]=0;t[r][r]=1}))}}))}}))}}class h{constructor({meshDimension:e,elementOrder:t}){this.meshDimension=e,this.elementOrder=t}getBasisFunctions(e,t=null){let n=[],o=[],i=[];if("1D"===this.meshDimension)"linear"===this.elementOrder?(n[0]=1-e,n[1]=e,o[0]=-1,o[1]=1):"quadratic"===this.elementOrder&&(n[0]=1-3*e+2*e**2,n[1]=4*e-4*e**2,n[2]=2*e**2-e,o[0]=4*e-3,o[1]=4-8*e,o[2]=4*e-1);else if("2D"===this.meshDimension){if(null===t)return void s("Eta coordinate is required for 2D elements");if("linear"===this.elementOrder){function r(e){return 1-e}n[0]=r(e)*r(t),n[1]=r(e)*t,n[2]=e*r(t),n[3]=e*t,o[0]=-1*r(t),o[1]=-1*t,o[2]=1*r(t),o[3]=1*t,i[0]=-1*r(e),i[1]=1*r(e),i[2]=-1*e,i[3]=1*e}else if("quadratic"===this.elementOrder){function a(e){return 2*e**2-3*e+1}function l(e){return-4*e**2+4*e}function d(e){return 2*e**2-e}function m(e){return 4*e-3}function u(e){return-8*e+4}function h(e){return 4*e-1}n[0]=a(e)*a(t),n[1]=a(e)*l(t),n[2]=a(e)*d(t),n[3]=l(e)*a(t),n[4]=l(e)*l(t),n[5]=l(e)*d(t),n[6]=d(e)*a(t),n[7]=d(e)*l(t),n[8]=d(e)*d(t),o[0]=m(e)*a(t),o[1]=m(e)*l(t),o[2]=m(e)*d(t),o[3]=u(e)*a(t),o[4]=u(e)*l(t),o[5]=u(e)*d(t),o[6]=h(e)*a(t),o[7]=h(e)*l(t),o[8]=h(e)*d(t),i[0]=a(e)*m(t),i[1]=a(e)*u(t),i[2]=a(e)*h(t),i[3]=l(e)*m(t),i[4]=l(e)*u(t),i[5]=l(e)*h(t),i[6]=d(e)*m(t),i[7]=d(e)*u(t),i[8]=d(e)*h(t)}}return{basisFunction:n,basisFunctionDerivKsi:o,basisFunctionDerivEta:i}}}class c{constructor({numElementsX:e=null,maxX:t=null,numElementsY:n=null,maxY:s=null,meshDimension:i=null,elementOrder:r="linear",parsedMesh:a=null}){this.numElementsX=e,this.numElementsY=n,this.maxX=t,this.maxY=s,this.meshDimension=i,this.elementOrder=r,this.parsedMesh=a,this.boundaryElementsProcessed=!1,this.parsedMesh&&(o("Using pre-parsed mesh from gmshReader data for mesh generation."),this.parseMeshFromGmsh())}parseMeshFromGmsh(){if(this.parsedMesh.nodalNumbering||s("No valid nodal numbering found in the parsed mesh."),"object"==typeof this.parsedMesh.nodalNumbering&&!Array.isArray(this.parsedMesh.nodalNumbering)){const e=this.parsedMesh.nodalNumbering.quadElements||[];if(this.parsedMesh.nodalNumbering.triangleElements,n("Initial parsed mesh nodal numbering from GMSH format: "+JSON.stringify(this.parsedMesh.nodalNumbering)),this.parsedMesh.elementTypes[3]||this.parsedMesh.elementTypes[10]){const t=[];for(let n=0;n<e.length;n++){const o=e[n],s=new Array(o.length);4===o.length?(s[0]=o[0],s[1]=o[3],s[2]=o[1],s[3]=o[2]):9===o.length&&(s[0]=o[0],s[1]=o[7],s[2]=o[3],s[3]=o[4],s[4]=o[8],s[5]=o[6],s[6]=o[1],s[7]=o[5],s[8]=o[2]),t.push(s)}this.parsedMesh.nodalNumbering=t}else this.parsedMesh.elementTypes[2]&&n("Element type is neither triangle nor quad; mapping for this type is not implemented yet.");if(n("Nodal numbering after mapping from GMSH to FEAScript format: "+JSON.stringify(this.parsedMesh.nodalNumbering)),this.parsedMesh.physicalPropMap&&this.parsedMesh.boundaryElements){if(Array.isArray(this.parsedMesh.boundaryElements)&&this.parsedMesh.boundaryElements.length>0&&void 0===this.parsedMesh.boundaryElements[0]){const e=[];for(let t=1;t<this.parsedMesh.boundaryElements.length;t++)this.parsedMesh.boundaryElements[t]&&e.push(this.parsedMesh.boundaryElements[t]);this.parsedMesh.boundaryElements=e}if(this.parsedMesh.boundaryNodePairs&&!this.parsedMesh.boundaryElementsProcessed&&(this.parsedMesh.boundaryElements=[],this.parsedMesh.physicalPropMap.forEach((e=>{if(1===e.dimension){const t=this.parsedMesh.boundaryNodePairs[e.tag]||[];t.length>0&&(this.parsedMesh.boundaryElements[e.tag]||(this.parsedMesh.boundaryElements[e.tag]=[]),t.forEach((t=>{const o=t[0],i=t[1];n(`Processing boundary node pair: [${o}, ${i}] for boundary ${e.tag} (${e.name||"unnamed"})`);let r=!1;for(let t=0;t<this.parsedMesh.nodalNumbering.length;t++){const s=this.parsedMesh.nodalNumbering[t];if(4===s.length){if(s.includes(o)&&s.includes(i)){let a;const l=s.indexOf(o),d=s.indexOf(i);n(`  Found element ${t} containing boundary nodes. Element nodes: [${s.join(", ")}]`),n(`  Node ${o} is at index ${l}, Node ${i} is at index ${d} in the element`),0===l&&2===d||2===l&&0===d?(a=0,n(`  These nodes form the BOTTOM side (${a}) of element ${t}`)):0===l&&1===d||1===l&&0===d?(a=1,n(`  These nodes form the LEFT side (${a}) of element ${t}`)):1===l&&3===d||3===l&&1===d?(a=2,n(`  These nodes form the TOP side (${a}) of element ${t}`)):(2===l&&3===d||3===l&&2===d)&&(a=3,n(`  These nodes form the RIGHT side (${a}) of element ${t}`)),this.parsedMesh.boundaryElements[e.tag].push([t,a]),n(`  Added element-side pair [${t}, ${a}] to boundary tag ${e.tag}`),r=!0;break}}else if(9===s.length&&s.includes(o)&&s.includes(i)){let a;const l=s.indexOf(o),d=s.indexOf(i);n(`  Found element ${t} containing boundary nodes. Element nodes: [${s.join(", ")}]`),n(`  Node ${o} is at index ${l}, Node ${i} is at index ${d} in the element`),0===l&&6===d||6===l&&0===d||0===l&&3===d||3===l&&0===d||3===l&&6===d||6===l&&3===d?(a=0,n(`  These nodes form the BOTTOM side (${a}) of element ${t}`)):0===l&&2===d||2===l&&0===d||0===l&&1===d||1===l&&0===d||1===l&&2===d||2===l&&1===d?(a=1,n(`  These nodes form the LEFT side (${a}) of element ${t}`)):2===l&&8===d||8===l&&2===d||2===l&&5===d||5===l&&2===d||5===l&&8===d||8===l&&5===d?(a=2,n(`  These nodes form the TOP side (${a}) of element ${t}`)):(6===l&&8===d||8===l&&6===d||6===l&&7===d||7===l&&6===d||7===l&&8===d||8===l&&7===d)&&(a=3,n(`  These nodes form the RIGHT side (${a}) of element ${t}`)),this.parsedMesh.boundaryElements[e.tag].push([t,a]),n(`  Added element-side pair [${t}, ${a}] to boundary tag ${e.tag}`),r=!0;break}}r||s(`Could not find element containing boundary nodes ${o} and ${i}. Boundary may be incomplete.`)})))}})),this.boundaryElementsProcessed=!0,this.parsedMesh.boundaryElements.length>0&&void 0===this.parsedMesh.boundaryElements[0])){const e=[];for(let t=1;t<this.parsedMesh.boundaryElements.length;t++)this.parsedMesh.boundaryElements[t]&&e.push(this.parsedMesh.boundaryElements[t]);this.parsedMesh.boundaryElements=e}}}return this.parsedMesh}}class f extends c{constructor({numElementsX:e=null,maxX:t=null,elementOrder:n="linear",parsedMesh:o=null}){super({numElementsX:e,maxX:t,numElementsY:1,maxY:0,meshDimension:"1D",elementOrder:n,parsedMesh:o}),null!==this.numElementsX&&null!==this.maxX||s("numElementsX and maxX are required parameters when generating a 1D mesh from geometry")}generateMesh(){let e=[];let t,o;if("linear"===this.elementOrder){t=this.numElementsX+1,o=(this.maxX-0)/this.numElementsX,e[0]=0;for(let n=1;n<t;n++)e[n]=e[n-1]+o}else if("quadratic"===this.elementOrder){t=2*this.numElementsX+1,o=(this.maxX-0)/this.numElementsX,e[0]=0;for(let n=1;n<t;n++)e[n]=e[n-1]+o/2}const s=this.generate1DNodalNumbering(this.numElementsX,t,this.elementOrder),i=this.findBoundaryElements();return n("Generated node X coordinates: "+JSON.stringify(e)),{nodesXCoordinates:e,totalNodesX:t,nodalNumbering:s,boundaryElements:i}}generate1DNodalNumbering(e,t,n){let o=[];if("linear"===n)for(let t=0;t<e;t++){o[t]=[];for(let e=1;e<=2;e++)o[t][e-1]=t+e}else if("quadratic"===n){let t=0;for(let n=0;n<e;n++){o[n]=[];for(let e=1;e<=3;e++)o[n][e-1]=n+e+t;t+=1}}return o}findBoundaryElements(){const e=[];for(let t=0;t<2;t++)e.push([]);return e[0].push([0,0]),e[1].push([this.numElementsX-1,1]),n("Identified boundary elements by side: "+JSON.stringify(e)),this.boundaryElementsProcessed=!0,e}}class p extends c{constructor({numElementsX:e=null,maxX:t=null,numElementsY:n=null,maxY:o=null,elementOrder:i="linear",parsedMesh:r=null}){super({numElementsX:e,maxX:t,numElementsY:n,maxY:o,meshDimension:"2D",elementOrder:i,parsedMesh:r}),null!==this.numElementsX&&null!==this.maxX&&null!==this.numElementsY&&null!==this.maxY||s("numElementsX, maxX, numElementsY, and maxY are required parameters when generating a 2D mesh from geometry")}generateMesh(){let e=[],t=[];let o,s,i,r;if("linear"===this.elementOrder){o=this.numElementsX+1,s=this.numElementsY+1,i=(this.maxX-0)/this.numElementsX,r=(this.maxY-0)/this.numElementsY,e[0]=0,t[0]=0;for(let n=1;n<s;n++)e[n]=e[0],t[n]=t[0]+n*r;for(let n=1;n<o;n++){const o=n*s;e[o]=e[0]+n*i,t[o]=t[0];for(let n=1;n<s;n++)e[o+n]=e[o],t[o+n]=t[o]+n*r}}else if("quadratic"===this.elementOrder){o=2*this.numElementsX+1,s=2*this.numElementsY+1,i=(this.maxX-0)/this.numElementsX,r=(this.maxY-0)/this.numElementsY,e[0]=0,t[0]=0;for(let n=1;n<s;n++)e[n]=e[0],t[n]=t[0]+n*r/2;for(let n=1;n<o;n++){const o=n*s;e[o]=e[0]+n*i/2,t[o]=t[0];for(let n=1;n<s;n++)e[o+n]=e[o],t[o+n]=t[o]+n*r/2}}const a=this.generate2DNodalNumbering(this.numElementsX,this.numElementsY,s,this.elementOrder),l=this.findBoundaryElements();return n("Generated node X coordinates: "+JSON.stringify(e)),n("Generated node Y coordinates: "+JSON.stringify(t)),{nodesXCoordinates:e,nodesYCoordinates:t,totalNodesX:o,totalNodesY:s,nodalNumbering:a,boundaryElements:l}}generate2DNodalNumbering(e,t,n,o){let s=0,i=[];if("linear"===o){let n=0,o=2;for(let s=0;s<e*t;s++)n+=1,i[s]=[],i[s][0]=s+o-1,i[s][1]=s+o,i[s][2]=s+o+t,i[s][3]=s+o+t+1,n===t&&(o+=1,n=0)}else if("quadratic"===o)for(let o=1;o<=e;o++)for(let e=1;e<=t;e++){i[s]=[];for(let t=1;t<=3;t++){let r=3*t-2;i[s][r-1]=n*(2*o+t-3)+2*e-1,i[s][r]=i[s][r-1]+1,i[s][r+1]=i[s][r-1]+2}s+=1}return i}findBoundaryElements(){const e=[];for(let t=0;t<4;t++)e.push([]);for(let t=0;t<this.numElementsX;t++)for(let n=0;n<this.numElementsY;n++){const o=t*this.numElementsY+n;0===n&&e[0].push([o,0]),0===t&&e[1].push([o,1]),n===this.numElementsY-1&&e[2].push([o,2]),t===this.numElementsX-1&&e[3].push([o,3])}return n("Identified boundary elements by side: "+JSON.stringify(e)),this.boundaryElementsProcessed=!0,e}}class g{constructor({meshDimension:e,elementOrder:t}){this.meshDimension=e,this.elementOrder=t}getGaussPointsAndWeights(){let e=[],t=[];return"linear"===this.elementOrder?(e[0]=.5,t[0]=1):"quadratic"===this.elementOrder&&(e[0]=(1-Math.sqrt(.6))/2,e[1]=.5,e[2]=(1+Math.sqrt(.6))/2,t[0]=5/18,t[1]=8/18,t[2]=5/18),{gaussPoints:e,gaussWeights:t}}}function y(e,t,i,r){o("Starting front propagation matrix assembly...");let a=1-r+.01;o(`eikonalViscousTerm: ${a}`),o(`eikonalActivationFlag: ${r}`);const{meshDimension:l,numElementsX:d,numElementsY:m,maxX:c,maxY:y,elementOrder:b,parsedMesh:E}=e;let $;n("Generating mesh..."),"1D"===l?$=new f({numElementsX:d,maxX:c,elementOrder:b,parsedMesh:E}):"2D"===l?$=new p({numElementsX:d,maxX:c,numElementsY:m,maxY:y,elementOrder:b,parsedMesh:E}):s("Mesh dimension must be either '1D' or '2D'.");const v=$.boundaryElementsProcessed?$.parsedMesh:$.generateMesh();let M=v.nodesXCoordinates,C=v.nodesYCoordinates,w=v.totalNodesX,N=v.totalNodesY,x=v.nodalNumbering,S=v.boundaryElements;let D,O;null!=E?(D=x.length,O=M.length,n(`Using parsed mesh with ${D} elements and ${O} nodes`)):(D=d*("2D"===l?m:1),O=w*("2D"===l?N:1),n(`Using mesh generated from geometry with ${D} elements and ${O} nodes`));let A,F,k,P,X,T,Y,W,R,q=[],I=[],j=[],G=[],B=[],U=[],V=[],L=[],z=[],_=[];for(let e=0;e<O;e++){z[e]=0,_.push([]);for(let t=0;t<O;t++)_[e][t]=0}const K=new h({meshDimension:l,elementOrder:b});let H=new g({meshDimension:l,elementOrder:b}).getGaussPointsAndWeights();I=H.gaussPoints,j=H.gaussWeights;const J=x[0].length;for(let e=0;e<D;e++){for(let t=0;t<J;t++)q[t]=x[e][t]-1;for(let e=0;e<I.length;e++)if("1D"===l){let t=K.getBasisFunctions(I[e]);G=t.basisFunction,B=t.basisFunctionDerivKsi,A=0,k=0,Y=0;for(let e=0;e<J;e++)A+=M[q[e]]*G[e],k+=M[q[e]]*B[e],Y=k;for(let e=0;e<J;e++)V[e]=B[e]/Y}else if("2D"===l)for(let t=0;t<I.length;t++){let n=K.getBasisFunctions(I[e],I[t]);G=n.basisFunction,B=n.basisFunctionDerivKsi,U=n.basisFunctionDerivEta,A=0,F=0,k=0,P=0,X=0,T=0,W=0,R=0;for(let e=0;e<J;e++)A+=M[q[e]]*G[e],F+=C[q[e]]*G[e],k+=M[q[e]]*B[e],P+=M[q[e]]*U[e],X+=C[q[e]]*B[e],T+=C[q[e]]*U[e];Y=k*T-P*X;for(let e=0;e<J;e++)V[e]=(T*B[e]-X*U[e])/Y,L[e]=(k*U[e]-P*B[e])/Y,W+=i[q[e]]*V[e],R+=i[q[e]]*L[e];for(let n=0;n<J;n++){let o=q[n];z[o]+=a*j[e]*j[t]*Y*V[n]*W+a*j[e]*j[t]*Y*L[n]*R,0!==r&&(z[o]+=r*(j[e]*j[t]*Y*G[n]*Math.sqrt(W**2+R**2)-j[e]*j[t]*Y*G[n]));for(let s=0;s<J;s++){let i=q[s];_[o][i]+=-a*j[e]*j[t]*Y*(V[n]*V[s]+L[n]*L[s]),0!==r&&(_[o][i]+=r*(-Y*W*G[n]*j[e]*j[t]/Math.sqrt(W**2+R**2+1e-8)*V[s]-Y*R*G[n]*j[e]*j[t]/Math.sqrt(W**2+R**2+1e-8)*L[s]))}}}}o("Applying generic boundary conditions...");new u(t,S,x,l,b).imposeConstantValueBoundaryConditions(z,_),o("Constant value boundary conditions applied"),n("Residuals at each node:");for(let e=0;e<z.length;e++)n(`Node ${e}: ${z[e].toExponential(6)}`);return o("Front propagation matrix assembly completed"),{jacobianMatrix:_,residualVector:z,nodesCoordinates:{nodesXCoordinates:M,nodesYCoordinates:C}}}class b{constructor(e,t,n,o,s){this.boundaryConditions=e,this.boundaryElements=t,this.nop=n,this.meshDimension=o,this.elementOrder=s}imposeConstantTempBoundaryConditions(e,t){o("Applying constant temperature boundary conditions (Dirichlet type)"),"1D"===this.meshDimension?Object.keys(this.boundaryConditions).forEach((o=>{if("constantTemp"===this.boundaryConditions[o][0]){const s=this.boundaryConditions[o][1];n(`Boundary ${o}: Applying constant temperature of ${s} K (Dirichlet condition)`),this.boundaryElements[o].forEach((([o,i])=>{if("linear"===this.elementOrder){({0:[0],1:[1]})[i].forEach((i=>{const r=this.nop[o][i]-1;n(`  - Applied constant temperature to node ${r+1} (element ${o+1}, local node ${i+1})`),e[r]=s;for(let n=0;n<e.length;n++)t[r][n]=0;t[r][r]=1}))}else if("quadratic"===this.elementOrder){({0:[0],2:[2]})[i].forEach((i=>{const r=this.nop[o][i]-1;n(`  - Applied constant temperature to node ${r+1} (element ${o+1}, local node ${i+1})`),e[r]=s;for(let n=0;n<e.length;n++)t[r][n]=0;t[r][r]=1}))}}))}})):"2D"===this.meshDimension&&Object.keys(this.boundaryConditions).forEach((o=>{if("constantTemp"===this.boundaryConditions[o][0]){const s=this.boundaryConditions[o][1];n(`Boundary ${o}: Applying constant temperature of ${s} K (Dirichlet condition)`),this.boundaryElements[o].forEach((([o,i])=>{if("linear"===this.elementOrder){({0:[0,2],1:[0,1],2:[1,3],3:[2,3]})[i].forEach((i=>{const r=this.nop[o][i]-1;n(`  - Applied constant temperature to node ${r+1} (element ${o+1}, local node ${i+1})`),e[r]=s;for(let n=0;n<e.length;n++)t[r][n]=0;t[r][r]=1}))}else if("quadratic"===this.elementOrder){({0:[0,3,6],1:[0,1,2],2:[2,5,8],3:[6,7,8]})[i].forEach((i=>{const r=this.nop[o][i]-1;n(`  - Applied constant temperature to node ${r+1} (element ${o+1}, local node ${i+1})`),e[r]=s;for(let n=0;n<e.length;n++)t[r][n]=0;t[r][r]=1}))}}))}}))}imposeConvectionBoundaryConditions(e,t,s,i,r,a,l){o("Applying convection boundary conditions (Robin type)");let d=[],m=[];Object.keys(this.boundaryConditions).forEach((e=>{const t=this.boundaryConditions[e];"convection"===t[0]&&(d[e]=t[1],m[e]=t[2])})),"1D"===this.meshDimension?Object.keys(this.boundaryConditions).forEach((o=>{if("convection"===this.boundaryConditions[o][0]){const s=d[o],i=m[o];n(`Boundary ${o}: Applying convection with heat transfer coefficient h=${s} W/(m²·K) and external temperature T∞=${i} K`),this.boundaryElements[o].forEach((([o,r])=>{let a;"linear"===this.elementOrder?a=0===r?0:1:"quadratic"===this.elementOrder&&(a=0===r?0:2);const l=this.nop[o][a]-1;n(`  - Applied convection boundary condition to node ${l+1} (element ${o+1}, local node ${a+1})`),e[l]+=-s*i,t[l][l]+=s}))}})):"2D"===this.meshDimension&&Object.keys(this.boundaryConditions).forEach((o=>{if("convection"===this.boundaryConditions[o][0]){const u=d[o],h=m[o];n(`Boundary ${o}: Applying convection with heat transfer coefficient h=${u} W/(m²·K) and external temperature T∞=${h} K`),this.boundaryElements[o].forEach((([o,d])=>{if("linear"===this.elementOrder){let m,c,f,p,g;0===d?(m=s[0],c=0,f=0,p=3,g=2):1===d?(m=0,c=s[0],f=0,p=2,g=1):2===d?(m=s[0],c=1,f=1,p=4,g=2):3===d&&(m=1,c=s[0],f=2,p=4,g=1);let y=l.getBasisFunctions(m,c),b=y.basisFunction,E=y.basisFunctionDerivKsi,$=y.basisFunctionDerivEta,v=0,M=0,C=0,w=0;const N=this.nop[o].length;for(let e=0;e<N;e++){const t=this.nop[o][e]-1;0===d||2===d?(v+=r[t]*E[e],M+=a[t]*E[e]):1!==d&&3!==d||(C+=r[t]*$[e],w+=a[t]*$[e])}let x;x=0===d||2===d?Math.sqrt(v**2+M**2):Math.sqrt(C**2+w**2);for(let s=f;s<p;s+=g){let r=this.nop[o][s]-1;n(`  - Applied convection boundary condition to node ${r+1} (element ${o+1}, local node ${s+1})`),e[r]+=-i[0]*x*b[s]*u*h;for(let e=f;e<p;e+=g){let n=this.nop[o][e]-1;t[r][n]+=-i[0]*x*b[s]*b[e]*u}}}else if("quadratic"===this.elementOrder)for(let m=0;m<3;m++){let c,f,p,g,y;0===d?(c=s[m],f=0,p=0,g=7,y=3):1===d?(c=0,f=s[m],p=0,g=3,y=1):2===d?(c=s[m],f=1,p=2,g=9,y=3):3===d&&(c=1,f=s[m],p=6,g=9,y=1);let b=l.getBasisFunctions(c,f),E=b.basisFunction,$=b.basisFunctionDerivKsi,v=b.basisFunctionDerivEta,M=0,C=0,w=0,N=0;const x=this.nop[o].length;for(let e=0;e<x;e++){const t=this.nop[o][e]-1;0===d||2===d?(M+=r[t]*$[e],C+=a[t]*$[e]):1!==d&&3!==d||(w+=r[t]*v[e],N+=a[t]*v[e])}let S;S=0===d||2===d?Math.sqrt(M**2+C**2):Math.sqrt(w**2+N**2);for(let s=p;s<g;s+=y){let r=this.nop[o][s]-1;n(`  - Applied convection boundary condition to node ${r+1} (element ${o+1}, local node ${s+1})`),e[r]+=-i[m]*S*E[s]*u*h;for(let e=p;e<g;e+=y){let n=this.nop[o][e]-1;t[r][n]+=-i[m]*S*E[s]*E[e]*u}}}}))}}))}}
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const E=Symbol("Comlink.proxy"),$=Symbol("Comlink.endpoint"),v=Symbol("Comlink.releaseProxy"),M=Symbol("Comlink.finalizer"),C=Symbol("Comlink.thrown"),w=e=>"object"==typeof e&&null!==e||"function"==typeof e,N=new Map([["proxy",{canHandle:e=>w(e)&&e[E],serialize(e){const{port1:t,port2:n}=new MessageChannel;return x(e,t),[n,[n]]},deserialize:e=>(e.start(),D(e))}],["throw",{canHandle:e=>w(e)&&C in e,serialize({value:e}){let t;return t=e instanceof Error?{isError:!0,value:{message:e.message,name:e.name,stack:e.stack}}:{isError:!1,value:e},[t,[]]},deserialize(e){if(e.isError)throw Object.assign(new Error(e.value.message),e.value);throw e.value}}]]);function x(e,t=globalThis,n=["*"]){t.addEventListener("message",(function o(s){if(!s||!s.data)return;if(!function(e,t){for(const n of e){if(t===n||"*"===n)return!0;if(n instanceof RegExp&&n.test(t))return!0}return!1}(n,s.origin))return void console.warn(`Invalid origin '${s.origin}' for comlink proxy`);const{id:i,type:r,path:a}=Object.assign({path:[]},s.data),l=(s.data.argumentList||[]).map(W);let d;try{const t=a.slice(0,-1).reduce(((e,t)=>e[t]),e),n=a.reduce(((e,t)=>e[t]),e);switch(r){case"GET":d=n;break;case"SET":t[a.slice(-1)[0]]=W(s.data.value),d=!0;break;case"APPLY":d=n.apply(t,l);break;case"CONSTRUCT":d=function(e){return Object.assign(e,{[E]:!0})}(new n(...l));break;case"ENDPOINT":{const{port1:t,port2:n}=new MessageChannel;x(e,n),d=function(e,t){return T.set(e,t),e}(t,[t])}break;case"RELEASE":d=void 0;break;default:return}}catch(e){d={value:e,[C]:0}}Promise.resolve(d).catch((e=>({value:e,[C]:0}))).then((n=>{const[s,a]=Y(n);t.postMessage(Object.assign(Object.assign({},s),{id:i}),a),"RELEASE"===r&&(t.removeEventListener("message",o),S(t),M in e&&"function"==typeof e[M]&&e[M]())})).catch((e=>{const[n,o]=Y({value:new TypeError("Unserializable return value"),[C]:0});t.postMessage(Object.assign(Object.assign({},n),{id:i}),o)}))})),t.start&&t.start()}function S(e){(function(e){return"MessagePort"===e.constructor.name})(e)&&e.close()}function D(e,t){const n=new Map;return e.addEventListener("message",(function(e){const{data:t}=e;if(!t||!t.id)return;const o=n.get(t.id);if(o)try{o(t)}finally{n.delete(t.id)}})),P(e,n,[],t)}function O(e){if(e)throw new Error("Proxy has been released and is not useable")}function A(e){return R(e,new Map,{type:"RELEASE"}).then((()=>{S(e)}))}const F=new WeakMap,k="FinalizationRegistry"in globalThis&&new FinalizationRegistry((e=>{const t=(F.get(e)||0)-1;F.set(e,t),0===t&&A(e)}));function P(e,t,n=[],o=function(){}){let s=!1;const i=new Proxy(o,{get(o,r){if(O(s),r===v)return()=>{!function(e){k&&k.unregister(e)}(i),A(e),t.clear(),s=!0};if("then"===r){if(0===n.length)return{then:()=>i};const o=R(e,t,{type:"GET",path:n.map((e=>e.toString()))}).then(W);return o.then.bind(o)}return P(e,t,[...n,r])},set(o,i,r){O(s);const[a,l]=Y(r);return R(e,t,{type:"SET",path:[...n,i].map((e=>e.toString())),value:a},l).then(W)},apply(o,i,r){O(s);const a=n[n.length-1];if(a===$)return R(e,t,{type:"ENDPOINT"}).then(W);if("bind"===a)return P(e,t,n.slice(0,-1));const[l,d]=X(r);return R(e,t,{type:"APPLY",path:n.map((e=>e.toString())),argumentList:l},d).then(W)},construct(o,i){O(s);const[r,a]=X(i);return R(e,t,{type:"CONSTRUCT",path:n.map((e=>e.toString())),argumentList:r},a).then(W)}});return function(e,t){const n=(F.get(t)||0)+1;F.set(t,n),k&&k.register(e,t,e)}(i,e),i}function X(e){const t=e.map(Y);return[t.map((e=>e[0])),(n=t.map((e=>e[1])),Array.prototype.concat.apply([],n))];var n}const T=new WeakMap;function Y(e){for(const[t,n]of N)if(n.canHandle(e)){const[o,s]=n.serialize(e);return[{type:"HANDLER",name:t,value:o},s]}return[{type:"RAW",value:e},T.get(e)||[]]}function W(e){switch(e.type){case"HANDLER":return N.get(e.name).deserialize(e.value);case"RAW":return e.value}}function R(e,t,n,o){return new Promise((s=>{const i=new Array(4).fill(0).map((()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16))).join("-");t.set(i,s),e.start&&e.start(),e.postMessage(Object.assign({id:i},n),o)}))}exports.FEAScriptModel=class{constructor(){this.solverConfig=null,this.meshConfig={},this.boundaryConditions={},this.solverMethod="lusolve",o("FEAScriptModel instance created")}setSolverConfig(e){this.solverConfig=e,n(`Solver config set to: ${e}`)}setMeshConfig(e){this.meshConfig=e,n(`Mesh config set with dimensions: ${e.meshDimension}`)}addBoundaryCondition(e,t){this.boundaryConditions[e]=t,n(`Boundary condition added for boundary: ${e}, type: ${t[0]}`)}setSolverMethod(e){this.solverMethod=e,n(`Solver method set to: ${e}`)}async solve(){if(!this.solverConfig||!this.meshConfig||!this.boundaryConditions){const e="Solver config, mesh config, and boundary conditions must be set before solving.";throw console.error(e),new Error(e)}let e=[],t=[],i=[],r=[],a={};if(o("Beginning solving process..."),console.time("totalSolvingTime"),"solidHeatTransferScript"===this.solverConfig){o(`Using solver: ${this.solverConfig}`),({jacobianMatrix:e,residualVector:t,nodesCoordinates:a}=function(e,t){o("Starting solid heat transfer matrix assembly...");const{meshDimension:i,numElementsX:r,numElementsY:a,maxX:l,maxY:d,elementOrder:m,parsedMesh:u}=e;let c;n("Generating mesh..."),"1D"===i?c=new f({numElementsX:r,maxX:l,elementOrder:m,parsedMesh:u}):"2D"===i?c=new p({numElementsX:r,maxX:l,numElementsY:a,maxY:d,elementOrder:m,parsedMesh:u}):s("Mesh dimension must be either '1D' or '2D'.");const y=c.boundaryElementsProcessed?c.parsedMesh:c.generateMesh();let E,$,v=y.nodesXCoordinates,M=y.nodesYCoordinates,C=y.totalNodesX,w=y.totalNodesY,N=y.nodalNumbering,x=y.boundaryElements;null!=u?(E=N.length,$=v.length,n(`Using parsed mesh with ${E} elements and ${$} nodes`)):(E=r*("2D"===i?a:1),$=C*("2D"===i?w:1),n(`Using mesh generated from geometry with ${E} elements and ${$} nodes`));let S,D,O,A,F,k,P,X=[],T=[],Y=[],W=[],R=[],q=[],I=[],j=[],G=[],B=[];for(let e=0;e<$;e++){G[e]=0,B.push([]);for(let t=0;t<$;t++)B[e][t]=0}const U=new h({meshDimension:i,elementOrder:m});let V=new g({meshDimension:i,elementOrder:m}).getGaussPointsAndWeights();T=V.gaussPoints,Y=V.gaussWeights;const L=N[0].length;for(let e=0;e<E;e++){for(let t=0;t<L;t++)X[t]=N[e][t]-1;for(let e=0;e<T.length;e++)if("1D"===i){let t=U.getBasisFunctions(T[e]);W=t.basisFunction,R=t.basisFunctionDerivKsi,S=0,O=0;for(let e=0;e<L;e++)S+=v[X[e]]*W[e],O+=v[X[e]]*R[e];P=O;for(let e=0;e<L;e++)I[e]=R[e]/P;for(let t=0;t<L;t++){let n=X[t];for(let o=0;o<L;o++){let s=X[o];B[n][s]+=-Y[e]*P*(I[t]*I[o])}}}else if("2D"===i)for(let t=0;t<T.length;t++){let n=U.getBasisFunctions(T[e],T[t]);W=n.basisFunction,R=n.basisFunctionDerivKsi,q=n.basisFunctionDerivEta,S=0,D=0,O=0,A=0,F=0,k=0;for(let e=0;e<L;e++)S+=v[X[e]]*W[e],D+=M[X[e]]*W[e],O+=v[X[e]]*R[e],A+=v[X[e]]*q[e],F+=M[X[e]]*R[e],k+=M[X[e]]*q[e];P=O*k-A*F;for(let e=0;e<L;e++)I[e]=(k*R[e]-F*q[e])/P,j[e]=(O*q[e]-A*R[e])/P;for(let n=0;n<L;n++){let o=X[n];for(let s=0;s<L;s++){let i=X[s];B[o][i]+=-Y[e]*Y[t]*P*(I[n]*I[s]+j[n]*j[s])}}}}o("Applying thermal boundary conditions...");const z=new b(t,x,N,i,m);return z.imposeConvectionBoundaryConditions(G,B,T,Y,v,M,U),o("Convection boundary conditions applied"),z.imposeConstantTempBoundaryConditions(G,B),o("Constant temperature boundary conditions applied"),o("Solid heat transfer matrix assembly completed"),{jacobianMatrix:B,residualVector:G,nodesCoordinates:{nodesXCoordinates:v,nodesYCoordinates:M}}}(this.meshConfig,this.boundaryConditions));i=(await d(this.solverMethod,e,t)).solutionVector}else if("frontPropagationScript"===this.solverConfig){o(`Using solver: ${this.solverConfig}`);let n=0;const s={meshConfig:this.meshConfig,boundaryConditions:this.boundaryConditions,eikonalActivationFlag:n,solverMethod:this.solverMethod,initialSolution:r};for(;n<=1;){s.eikonalActivationFlag=n,i.length>0&&(s.initialSolution=[...i]);const o=await m(y,s,100,1e-4);e=o.jacobianMatrix,t=o.residualVector,a=o.nodesCoordinates,i=o.solutionVector,o.iterations,n+=.2}}return console.timeEnd("totalSolvingTime"),o("Solving process completed"),{solutionVector:i,nodesCoordinates:a}}},exports.FEAScriptWorker=class{constructor(){this.worker=null,this.feaWorker=null,this.isReady=!1,this._initWorker()}async _initWorker(){try{this.worker=new Worker(new URL("./wrapperScript.js","undefined"==typeof document?new(require("url").URL)("file:"+__filename).href:document.currentScript&&"SCRIPT"===document.currentScript.tagName.toUpperCase()&&document.currentScript.src||new URL("feascript.cjs.js",document.baseURI).href),{type:"module"}),this.worker.onerror=e=>{console.error("FEAScriptWorker: Worker error:",e)};const e=D(this.worker);this.feaWorker=await new e,this.isReady=!0}catch(e){throw console.error("Failed to initialize worker",e),e}}async _ensureReady(){return this.isReady?Promise.resolve():new Promise(((e,t)=>{let n=0;const o=()=>{n++,this.isReady?e():n>=50?t(new Error("Timeout waiting for worker to be ready")):setTimeout(o,1e3)};o()}))}async setSolverConfig(e){return await this._ensureReady(),o(`FEAScriptWorker: Setting solver config to: ${e}`),this.feaWorker.setSolverConfig(e)}async setMeshConfig(e){return await this._ensureReady(),o("FEAScriptWorker: Setting mesh config"),this.feaWorker.setMeshConfig(e)}async addBoundaryCondition(e,t){return await this._ensureReady(),o(`FEAScriptWorker: Adding boundary condition for boundary: ${e}`),this.feaWorker.addBoundaryCondition(e,t)}async setSolverMethod(e){return await this._ensureReady(),o(`FEAScriptWorker: Setting solver method to: ${e}`),this.feaWorker.setSolverMethod(e)}async solve(){await this._ensureReady(),o("FEAScriptWorker: Requesting solution from worker...");const e=performance.now(),t=await this.feaWorker.solve();return o(`FEAScriptWorker: Solution completed in ${((performance.now()-e)/1e3).toFixed(2)}s`),t}async getModelInfo(){return await this._ensureReady(),this.feaWorker.getModelInfo()}async ping(){return await this._ensureReady(),this.feaWorker.ping()}terminate(){this.worker&&(this.worker.terminate(),this.worker=null,this.feaWorker=null,this.isReady=!1)}},exports.VERSION="0.1.3",exports.importGmshQuadTri=async e=>{let t={nodesXCoordinates:[],nodesYCoordinates:[],nodalNumbering:{quadElements:[],triangleElements:[]},boundaryElements:[],boundaryConditions:[],boundaryNodePairs:{},gmshV:0,ascii:!1,fltBytes:"8",totalNodesX:0,totalNodesY:0,physicalPropMap:[],elementTypes:{}},o=(await e.text()).split("\n").map((e=>e.trim())).filter((e=>""!==e&&" "!==e)),s="",i=0,r=0,a=0,l=0,d={numNodes:0},m=0,u=[],h=0,c=0,f=0,p={dim:0,tag:0,elementType:0,numElements:0},g=0,y={};for(;i<o.length;){const e=o[i];if("$MeshFormat"===e){s="meshFormat",i++;continue}if("$EndMeshFormat"===e){s="",i++;continue}if("$PhysicalNames"===e){s="physicalNames",i++;continue}if("$EndPhysicalNames"===e){s="",i++;continue}if("$Entities"===e){s="entities",i++;continue}if("$EndEntities"===e){s="",i++;continue}if("$Nodes"===e){s="nodes",i++;continue}if("$EndNodes"===e){s="",i++;continue}if("$Elements"===e){s="elements",i++;continue}if("$EndElements"===e){s="",i++;continue}const n=e.split(/\s+/).filter((e=>""!==e));if("meshFormat"===s)t.gmshV=parseFloat(n[0]),t.ascii="0"===n[1],t.fltBytes=n[2];else if("physicalNames"===s){if(n.length>=3){if(!/^\d+$/.test(n[0])){i++;continue}const e=parseInt(n[0],10),o=parseInt(n[1],10);let s=n.slice(2).join(" ");s=s.replace(/^"|"$/g,""),t.physicalPropMap.push({tag:o,dimension:e,name:s})}}else if("nodes"===s){if(0===r){r=parseInt(n[0],10),a=parseInt(n[1],10),t.nodesXCoordinates=new Array(a).fill(0),t.nodesYCoordinates=new Array(a).fill(0),i++;continue}if(l<r&&0===d.numNodes){d={dim:parseInt(n[0],10),tag:parseInt(n[1],10),parametric:parseInt(n[2],10),numNodes:parseInt(n[3],10)},u=[],m=0,h=0,i++;continue}if(m<d.numNodes){for(let e=0;e<n.length&&m<d.numNodes;e++)u.push(parseInt(n[e],10)),m++;if(m<d.numNodes){i++;continue}i++;continue}if(h<d.numNodes){const e=u[h]-1,o=parseFloat(n[0]),s=parseFloat(n[1]);t.nodesXCoordinates[e]=o,t.nodesYCoordinates[e]=s,t.totalNodesX++,t.totalNodesY++,h++,h===d.numNodes&&(l++,d={numNodes:0})}}else if("elements"===s){if(0===c){c=parseInt(n[0],10),parseInt(n[1],10),i++;continue}if(f<c&&0===p.numElements){p={dim:parseInt(n[0],10),tag:parseInt(n[1],10),elementType:parseInt(n[2],10),numElements:parseInt(n[3],10)},t.elementTypes[p.elementType]=(t.elementTypes[p.elementType]||0)+p.numElements,g=0,i++;continue}if(g<p.numElements){parseInt(n[0],10);const e=n.slice(1).map((e=>parseInt(e,10)));if(1===p.elementType||8===p.elementType){const n=p.tag;y[n]||(y[n]=[]),y[n].push(e),t.boundaryNodePairs[n]||(t.boundaryNodePairs[n]=[]),t.boundaryNodePairs[n].push(e)}else 2===p.elementType?t.nodalNumbering.triangleElements.push(e):(3===p.elementType||10===p.elementType)&&t.nodalNumbering.quadElements.push(e);g++,g===p.numElements&&(f++,p={numElements:0})}}i++}return t.physicalPropMap.forEach((e=>{if(1===e.dimension){const n=y[e.tag]||[];n.length>0&&t.boundaryConditions.push({name:e.name,tag:e.tag,nodes:n})}})),n(`Parsed boundary node pairs by physical tag: ${JSON.stringify(t.boundaryNodePairs)}. These pairs will be used to identify boundary elements in the mesh.`),t},exports.logSystem=function(e){"basic"!==e&&"debug"!==e?(console.log("%c[WARN] Invalid log level: "+e+". Using basic instead.","color: #FFC107; font-weight: bold;"),t="basic"):(t=e,o(`Log level set to: ${e}`))},exports.plotSolution=function(e,t,n,o,s,i,r="structured"){const{nodesXCoordinates:a,nodesYCoordinates:l}=t;if("1D"===o&&"line"===s){let t;t=e.length>0&&Array.isArray(e[0])?e.map((e=>e[0])):e;let o=Array.from(a),s={x:o,y:t,mode:"lines",type:"scatter",line:{color:"rgb(219, 64, 82)",width:2},name:"Solution"},r=Math.min(window.innerWidth,700),l=Math.max(...o),d=r/l,m={title:`line plot - ${n}`,width:Math.max(d*l,400),height:350,xaxis:{title:"x"},yaxis:{title:"Solution"},margin:{l:70,r:40,t:50,b:50}};Plotly.newPlot(i,[s],m,{responsive:!0})}else if("2D"===o&&"contour"===s){const t="structured"===r,o=new Set(a).size,d=new Set(l).size;let m;m=Array.isArray(e[0])?e.map((e=>e[0])):e;let u=Math.min(window.innerWidth,700),h=Math.max(...a),c=Math.max(...l)/h,f=Math.min(u,600),p={title:`${s} plot - ${n}`,width:f,height:f*c*.8,xaxis:{title:"x"},yaxis:{title:"y"},margin:{l:50,r:50,t:50,b:50},hovermode:"closest"};if(t){const t=o,n=d;math.reshape(Array.from(a),[t,n]);let s=math.reshape(Array.from(l),[t,n]),r=math.reshape(Array.from(e),[t,n]),m=math.transpose(r),u=[];for(let e=0;e<t*n;e+=n){let t=a[e];u.push(t)}let h={z:m,type:"contour",contours:{coloring:"heatmap",showlabels:!1},colorbar:{title:"Solution"},x:u,y:s[0],name:"Solution Field"};Plotly.newPlot(i,[h],p,{responsive:!0})}else{let e={x:a,y:l,z:m,type:"contour",contours:{coloring:"heatmap",showlabels:!1},colorbar:{title:"Solution"},name:"Solution Field"};Plotly.newPlot(i,[e],p,{responsive:!0})}}},exports.printVersion=async function(){o("Fetching latest FEAScript version information...");try{const e=await fetch("https://api.github.com/repos/FEAScript/FEAScript/commits/main"),t=await e.json(),n=new Date(t.commit.committer.date).toLocaleString();return o(`Latest FEAScript update: ${n}`),n}catch(e){return s("Failed to fetch version information: "+e),"Version information unavailable"}};
//# sourceMappingURL=feascript.cjs.js.map
