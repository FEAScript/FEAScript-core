{"version":3,"file":"feascript.esm.js","sources":["../src/methods/euclideanNormScript.js","../src/utilities/loggingScript.js","../src/methods/linearSystemSolverScript.js","../src/methods/jacobiSolverScript.js","../src/methods/newtonRaphsonScript.js","../src/mesh/basisFunctionsScript.js","../src/mesh/meshGenerationScript.js","../src/methods/numericalIntegrationScript.js","../src/mesh/meshUtilsScript.js","../src/solvers/genericBoundaryConditionsScript.js","../src/solvers/frontPropagationScript.js","../src/solvers/thermalBoundaryConditionsScript.js","../src/methods/frontalSolverScript.js","../src/solvers/solidHeatTransferScript.js","../src/FEAScript.js","../src/readers/gmshReaderScript.js","../src/visualization/plotSolutionScript.js","../src/vendor/comlink.mjs","../src/workers/workerScript.js","../src/index.js"],"sourcesContent":["//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n/**\n * Function to calculate the Euclidean norm of a vector\n * @param {array} vector - The input vector\n * @returns {number} The Euclidean norm of the vector\n */\nexport function euclideanNorm(vector) {\n  let norm = 0;\n  for (let i = 0; i < vector.length; i++) {\n    norm += vector[i] * vector[i];\n  }\n  norm = Math.sqrt(norm);\n  return norm;\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n// Global logging level\nlet currentLogLevel = \"basic\";\n\n/**\n * Function to set the logging system level\n * @param {string} level - Logging level (basic, debug)\n */\nexport function logSystem(level) {\n  if (level !== \"basic\" && level !== \"debug\") {\n    console.log(\n      \"%c[WARN] Invalid log level: \" + level + \". Using basic instead.\",\n      \"color: #FFC107; font-weight: bold;\"\n    ); // Yellow for warnings\n    currentLogLevel = \"basic\";\n  } else {\n    currentLogLevel = level;\n    basicLog(`Log level set to: ${level}`);\n  }\n}\n\n/**\n * Function to log debug messages - only logs if level is 'debug'\n * @param {string} message - Message to log\n */\nexport function debugLog(message) {\n  if (currentLogLevel === \"debug\") {\n    console.log(\"%c[DEBUG] \" + message, \"color: #2196F3; font-weight: bold;\"); // Blue color for debug\n  }\n}\n\n/**\n * Function to log basic information - always logs\n * @param {string} message - Message to log\n */\nexport function basicLog(message) {\n  console.log(\"%c[INFO] \" + message, \"color: #4CAF50; font-weight: bold;\"); // Green color for basic info\n}\n\n/**\n * Function to log error messages\n * @param {string} message - Message to log\n */\nexport function errorLog(message) {\n  console.log(\"%c[ERROR] \" + message, \"color: #F44336; font-weight: bold;\"); // Red color for errors\n}\n\n/**\n * Function to handle version information and fetch the latest update date and release from GitHub\n */\nexport async function printVersion() {\n  basicLog(\"Fetching latest FEAScript version information...\");\n  try {\n    const commitResponse = await fetch(\"https://api.github.com/repos/FEAScript/FEAScript/commits/main\");\n    const commitData = await commitResponse.json();\n    const latestCommitDate = new Date(commitData.commit.committer.date).toLocaleString();\n    basicLog(`Latest FEAScript update: ${latestCommitDate}`);\n    return latestCommitDate;\n  } catch (error) {\n    errorLog(\"Failed to fetch version information: \" + error);\n    return \"Version information unavailable\";\n  }\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n// Internal imports\nimport { jacobiSolver } from \"./jacobiSolverScript.js\";\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Function to solve a system of linear equations using different solver methods\n * @param {string} solverMethod - The solver method to use (\"lusolve\" or \"jacobi\")\n * @param {Array} jacobianMatrix - The coefficient matrix\n * @param {Array} residualVector - The right-hand side vector\n * @param {object} [options] - Additional options for the solver\n * @param {number} [options.maxIterations=1000] - Maximum iterations for iterative methods\n * @param {number} [options.tolerance=1e-6] - Convergence tolerance for iterative methods\n * @returns {object} An object containing:\n *  - solutionVector: The solution vector\n *  - converged: Boolean indicating whether the method converged (for iterative methods)\n *  - iterations: Number of iterations performed (for iterative methods)\n */\nexport function solveLinearSystem(solverMethod, jacobianMatrix, residualVector, options = {}) {\n  const { maxIterations = 1000, tolerance = 1e-6 } = options;\n\n  let solutionVector = [];\n  let converged = true;\n  let iterations = 0;\n\n  // Solve the linear system based on the specified solver method\n  basicLog(`Solving system using ${solverMethod}...`);\n  console.time(\"systemSolving\");\n\n  if (solverMethod === \"lusolve\") {\n    // Use LU decomposition method\n    const jacobianMatrixSparse = math.sparse(jacobianMatrix);\n    const luFactorization = math.slu(jacobianMatrixSparse, 1, 1); // order=1, threshold=1 for pivoting\n    let solutionMatrix = math.lusolve(luFactorization, residualVector);\n    solutionVector = math.squeeze(solutionMatrix).valueOf();\n    //solutionVector = math.lusolve(jacobianMatrix, residualVector); // In the case of a dense matrix\n  } else if (solverMethod === \"jacobi\") {\n    // Use Jacobi method\n    const initialGuess = new Array(residualVector.length).fill(0);\n    const jacobiSolverResult = jacobiSolver(jacobianMatrix, residualVector, initialGuess, {\n      maxIterations,\n      tolerance,\n    });\n\n    // Log convergence information\n    if (jacobiSolverResult.converged) {\n      debugLog(`Jacobi method converged in ${jacobiSolverResult.iterations} iterations`);\n    } else {\n      debugLog(`Jacobi method did not converge after ${jacobiSolverResult.iterations} iterations`);\n    }\n\n    solutionVector = jacobiSolverResult.solutionVector;\n    converged = jacobiSolverResult.converged;\n    iterations = jacobiSolverResult.iterations;\n  } else {\n    errorLog(`Unknown solver method: ${solverMethod}`);\n  }\n\n  console.timeEnd(\"systemSolving\");\n  basicLog(\"System solved successfully\");\n\n  return { solutionVector, converged, iterations };\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n/**\n * Function to solve a system of linear equations using the Jacobi iterative method\n * @param {array} jacobianMatrix - The coefficient matrix (must be square)\n * @param {array} residualVector - The right-hand side vector\n * @param {array} initialGuess - Initial guess for solution vector\n * @param {object} [options] - Options for the solver\n * @param {number} [options.maxIterations=1000] - Maximum number of iterations\n * @param {number} [options.tolerance=1e-6] - Convergence tolerance\n * @returns {object} An object containing:\n *  - solutionVector: The solution vector\n *  - iterations: The number of iterations performed\n *  - converged: Boolean indicating whether the method converged\n */\nexport function jacobiSolver(jacobianMatrix, residualVector, initialGuess, options = {}) {\n  const { maxIterations = 1000, tolerance = 1e-6 } = options;\n  const n = jacobianMatrix.length; // Size of the square matrix\n  let x = [...initialGuess]; // Current solution (starts with initial guess)\n  let xNew = new Array(n); // Next iteration's solution\n\n  for (let iteration = 0; iteration < maxIterations; iteration++) {\n    // Perform one iteration\n    for (let i = 0; i < n; i++) {\n      let sum = 0;\n      // Calculate sum of jacobianMatrix[i][j] * x[j] for j â‰  i\n      for (let j = 0; j < n; j++) {\n        if (j !== i) {\n          sum += jacobianMatrix[i][j] * x[j];\n        }\n      }\n      // Update xNew[i] using the Jacobi formula\n      xNew[i] = (residualVector[i] - sum) / jacobianMatrix[i][i];\n    }\n\n    // Check convergence\n    let maxDiff = 0;\n    for (let i = 0; i < n; i++) {\n      maxDiff = Math.max(maxDiff, Math.abs(xNew[i] - x[i]));\n    }\n\n    // Update x for next iteration\n    x = [...xNew];\n\n    // Successfully converged if maxDiff is less than tolerance\n    if (maxDiff < tolerance) {\n      return {\n        solutionVector: x,\n        iterations: iteration + 1,\n        converged: true,\n      };\n    }\n  }\n\n  // maxIterations were reached without convergence\n  return {\n    solutionVector: x,\n    iterations: maxIterations,\n    converged: false,\n  };\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n// Internal imports\nimport { euclideanNorm } from \"../methods/euclideanNormScript.js\";\nimport { solveLinearSystem } from \"./linearSystemSolverScript.js\";\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Function to solve a system of non-linear equations using the Newton-Raphson method\n * @param {number} [maxIterations=100] - Maximum number of iterations\n * @param {number} [tolerance=1e-4] - Convergence tolerance\n * @returns {object} An object containing:\n *  - solutionVector: The solution vector\n *  - iterations: The number of iterations performed\n *  - converged: Boolean indicating whether the method converged\n */\n\nexport function newtonRaphson(assembleMat, context, maxIterations = 100, tolerance = 1e-4) {\n  let errorNorm = 0;\n  let converged = false;\n  let iterations = 0;\n  let deltaX = [];\n  let solutionVector = [];\n  let jacobianMatrix = [];\n  let residualVector = [];\n\n  // Calculate system size from meshData instead of meshConfig\n  let totalNodes = context.meshData.nodesXCoordinates.length;\n\n  // Initialize arrays with proper size\n  for (let i = 0; i < totalNodes; i++) {\n    deltaX[i] = 0;\n    solutionVector[i] = 0;\n  }\n\n  // Initialize solution from context if available\n  if (context.initialSolution && context.initialSolution.length === totalNodes) {\n    solutionVector = [...context.initialSolution];\n  }\n\n  while (iterations < maxIterations && !converged) {\n    // Update solution\n    for (let i = 0; i < solutionVector.length; i++) {\n      solutionVector[i] = Number(solutionVector[i]) + Number(deltaX[i]);\n    }\n\n    // Compute Jacobian and residual matrices\n    ({ jacobianMatrix, residualVector } = assembleMat(\n      context.meshData,\n      context.boundaryConditions,\n      solutionVector, // The solution vector is required in the case of a non-linear equation\n      context.eikonalActivationFlag // Currently used only in the front propagation solver (TODO refactor in case of a solver not needing it)\n    ));\n\n    // Solve the linear system based on the specified solver method\n    const linearSystemResult = solveLinearSystem(context.solverMethod, jacobianMatrix, residualVector);\n    deltaX = linearSystemResult.solutionVector;\n\n    // Check convergence\n    errorNorm = euclideanNorm(deltaX);\n\n    // Norm for each iteration\n    basicLog(`Newton-Raphson iteration ${iterations + 1}: Error norm = ${errorNorm.toExponential(4)}`);\n\n    if (errorNorm <= tolerance) {\n      converged = true;\n    } else if (errorNorm > 1e2) {\n      errorLog(`Solution not converged. Error norm: ${errorNorm}`);\n      break;\n    }\n\n    iterations++;\n  }\n\n  return {\n    solutionVector,\n    converged,\n    iterations,\n    jacobianMatrix,\n    residualVector,\n  };\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n// Internal imports\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Class to handle basis functions and their derivatives based on element configuration\n */\nexport class BasisFunctions {\n  /**\n   * Constructor to initialize the BasisFunctions class\n   * @param {string} meshDimension - The dimension of the mesh\n   * @param {string} elementOrder - The order of elements\n   */\n  constructor({ meshDimension, elementOrder }) {\n    this.meshDimension = meshDimension;\n    this.elementOrder = elementOrder;\n  }\n\n  /**\n   * Function to calculate basis functions and their derivatives based on the dimension and order\n   * @param {number} ksi - Natural coordinate (for both 1D and 2D)\n   * @param {number} [eta] - Second natural coordinate (only for 2D elements)\n   * @returns {object} An object containing:\n   *  - basisFunction: Array of evaluated basis functions\n   *  - basisFunctionDerivKsi: Array of derivatives of basis functions with respect to ksi\n   *  - basisFunctionDerivEta: Array of derivatives of basis functions with respect to eta (only for 2D elements)\n   */\n  getBasisFunctions(ksi, eta = null) {\n    let basisFunction = [];\n    let basisFunctionDerivKsi = [];\n    let basisFunctionDerivEta = [];\n\n    if (this.meshDimension === \"1D\") {\n      if (this.elementOrder === \"linear\") {\n        // Linear basis functions for 1D elements\n        basisFunction[0] = 1 - ksi;\n        basisFunction[1] = ksi;\n\n        // Derivatives of basis functions with respect to ksi\n        basisFunctionDerivKsi[0] = -1;\n        basisFunctionDerivKsi[1] = 1;\n      } else if (this.elementOrder === \"quadratic\") {\n        // Quadratic basis functions for 1D elements\n        basisFunction[0] = 1 - 3 * ksi + 2 * ksi ** 2;\n        basisFunction[1] = 4 * ksi - 4 * ksi ** 2;\n        basisFunction[2] = -ksi + 2 * ksi ** 2;\n\n        // Derivatives of basis functions with respect to ksi\n        basisFunctionDerivKsi[0] = -3 + 4 * ksi;\n        basisFunctionDerivKsi[1] = 4 - 8 * ksi;\n        basisFunctionDerivKsi[2] = -1 + 4 * ksi;\n      }\n    } else if (this.meshDimension === \"2D\") {\n      if (eta === null) {\n        errorLog(\"Eta coordinate is required for 2D elements\");\n        return;\n      }\n\n      if (this.elementOrder === \"linear\") {\n        // Linear basis functions for 2D elements\n        function l1(c) {\n          return 1 - c;\n        }\n        function l2(c) {\n          return c;\n        }\n        function dl1() {\n          return -1;\n        }\n        function dl2() {\n          return 1;\n        }\n\n        // Evaluate basis functions at (ksi, eta)\n        basisFunction[0] = l1(ksi) * l1(eta);\n        basisFunction[1] = l1(ksi) * l2(eta);\n        basisFunction[2] = l2(ksi) * l1(eta);\n        basisFunction[3] = l2(ksi) * l2(eta);\n\n        // Derivatives with respect to ksi\n        basisFunctionDerivKsi[0] = dl1() * l1(eta);\n        basisFunctionDerivKsi[1] = dl1() * l2(eta);\n        basisFunctionDerivKsi[2] = dl2() * l1(eta);\n        basisFunctionDerivKsi[3] = dl2() * l2(eta);\n\n        // Derivatives with respect to eta\n        basisFunctionDerivEta[0] = l1(ksi) * dl1();\n        basisFunctionDerivEta[1] = l1(ksi) * dl2();\n        basisFunctionDerivEta[2] = l2(ksi) * dl1();\n        basisFunctionDerivEta[3] = l2(ksi) * dl2();\n      } else if (this.elementOrder === \"quadratic\") {\n        // Quadratic basis functions for 2D elements\n        function l1(c) {\n          return 2 * c ** 2 - 3 * c + 1;\n        }\n        function l2(c) {\n          return -4 * c ** 2 + 4 * c;\n        }\n        function l3(c) {\n          return 2 * c ** 2 - c;\n        }\n        function dl1(c) {\n          return 4 * c - 3;\n        }\n        function dl2(c) {\n          return -8 * c + 4;\n        }\n        function dl3(c) {\n          return 4 * c - 1;\n        }\n\n        // Evaluate basis functions at (ksi, eta)\n        basisFunction[0] = l1(ksi) * l1(eta);\n        basisFunction[1] = l1(ksi) * l2(eta);\n        basisFunction[2] = l1(ksi) * l3(eta);\n        basisFunction[3] = l2(ksi) * l1(eta);\n        basisFunction[4] = l2(ksi) * l2(eta);\n        basisFunction[5] = l2(ksi) * l3(eta);\n        basisFunction[6] = l3(ksi) * l1(eta);\n        basisFunction[7] = l3(ksi) * l2(eta);\n        basisFunction[8] = l3(ksi) * l3(eta);\n\n        // Derivatives with respect to ksi\n        basisFunctionDerivKsi[0] = dl1(ksi) * l1(eta);\n        basisFunctionDerivKsi[1] = dl1(ksi) * l2(eta);\n        basisFunctionDerivKsi[2] = dl1(ksi) * l3(eta);\n        basisFunctionDerivKsi[3] = dl2(ksi) * l1(eta);\n        basisFunctionDerivKsi[4] = dl2(ksi) * l2(eta);\n        basisFunctionDerivKsi[5] = dl2(ksi) * l3(eta);\n        basisFunctionDerivKsi[6] = dl3(ksi) * l1(eta);\n        basisFunctionDerivKsi[7] = dl3(ksi) * l2(eta);\n        basisFunctionDerivKsi[8] = dl3(ksi) * l3(eta);\n\n        // Derivatives with respect to eta\n        basisFunctionDerivEta[0] = l1(ksi) * dl1(eta);\n        basisFunctionDerivEta[1] = l1(ksi) * dl2(eta);\n        basisFunctionDerivEta[2] = l1(ksi) * dl3(eta);\n        basisFunctionDerivEta[3] = l2(ksi) * dl1(eta);\n        basisFunctionDerivEta[4] = l2(ksi) * dl2(eta);\n        basisFunctionDerivEta[5] = l2(ksi) * dl3(eta);\n        basisFunctionDerivEta[6] = l3(ksi) * dl1(eta);\n        basisFunctionDerivEta[7] = l3(ksi) * dl2(eta);\n        basisFunctionDerivEta[8] = l3(ksi) * dl3(eta);\n      }\n    }\n\n    return { basisFunction, basisFunctionDerivKsi, basisFunctionDerivEta };\n  }\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n// Internal imports\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Basic structure for the mesh\n */\nexport class Mesh {\n  /**\n   * Constructor to initialize the Mesh class\n   * @param {object} config - Configuration object for the mesh\n   * @param {number} [config.numElementsX] - Number of elements along the x-axis (required for geometry-based mesh)\n   * @param {number} [config.maxX] - Maximum x-coordinate of the mesh (required for geometry-based mesh)\n   * @param {number} [config.numElementsY=1] - Number of elements along the y-axis (for 1D meshes)\n   * @param {number} [config.maxY=0] - Maximum y-coordinate of the mesh (for 1D meshes)\n   * @param {string} [config.meshDimension='2D'] - The dimension of the mesh, either 1D or 2D\n   * @param {string} [config.elementOrder='linear'] - The order of elements, either 'linear' or 'quadratic'\n   * @param {object} [config.parsedMesh=null] - Optional pre-parsed mesh data\n   */\n  constructor({\n    numElementsX = null,\n    maxX = null,\n    numElementsY = null,\n    maxY = null,\n    meshDimension = null,\n    elementOrder = \"linear\",\n    parsedMesh = null,\n  }) {\n    this.numElementsX = numElementsX;\n    this.numElementsY = numElementsY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n    this.meshDimension = meshDimension;\n    this.elementOrder = elementOrder;\n    this.parsedMesh = parsedMesh;\n\n    this.boundaryElementsProcessed = false;\n\n    if (this.parsedMesh) {\n      basicLog(\"Using pre-parsed mesh from gmshReader data for mesh generation.\");\n      this.parseMeshFromGmsh();\n    }\n  }\n\n  /**\n   * Method to parse the mesh from the GMSH format to the FEAScript format\n   */\n  parseMeshFromGmsh() {\n    if (!this.parsedMesh.nodalNumbering) {\n      errorLog(\"No valid nodal numbering found in the parsed mesh.\");\n    }\n\n    if (\n      typeof this.parsedMesh.nodalNumbering === \"object\" &&\n      !Array.isArray(this.parsedMesh.nodalNumbering)\n    ) {\n      // Store the nodal numbering structure before converting\n      const quadElements = this.parsedMesh.nodalNumbering.quadElements || [];\n      const triangleElements = this.parsedMesh.nodalNumbering.triangleElements || [];\n\n      debugLog(\n        \"Initial parsed mesh nodal numbering from GMSH format: \" +\n          JSON.stringify(this.parsedMesh.nodalNumbering)\n      );\n\n      // Check if it has quadElements or triangleElements structure from gmshReader\n      if (this.parsedMesh.elementTypes[3] || this.parsedMesh.elementTypes[10]) {\n        // Map nodal numbering from GMSH format to FEAScript format for quad elements\n        const mappedNodalNumbering = [];\n\n        for (let elemIdx = 0; elemIdx < quadElements.length; elemIdx++) {\n          const gmshNodes = quadElements[elemIdx];\n          const feaScriptNodes = new Array(gmshNodes.length);\n\n          // Check for element type based on number of nodes\n          if (gmshNodes.length === 4) {\n            // Simple mapping for linear quad elements (4 nodes)\n            // GMSH:         FEAScript:\n            // 3 --- 2       1 --- 3\n            // |     |  -->  |     |\n            // 0 --- 1       0 --- 2\n\n            feaScriptNodes[0] = gmshNodes[0]; // 0 -> 0\n            feaScriptNodes[1] = gmshNodes[3]; // 3 -> 1\n            feaScriptNodes[2] = gmshNodes[1]; // 1 -> 2\n            feaScriptNodes[3] = gmshNodes[2]; // 2 -> 3\n          } else if (gmshNodes.length === 9) {\n            // Mapping for quadratic quad elements (9 nodes)\n            // GMSH:         FEAScript:\n            // 3--6--2       2--5--8\n            // |     |       |     |\n            // 7  8  5  -->  1  4  7\n            // |     |       |     |\n            // 0--4--1       0--3--6\n\n            feaScriptNodes[0] = gmshNodes[0]; // 0 -> 0\n            feaScriptNodes[1] = gmshNodes[7]; // 7 -> 1\n            feaScriptNodes[2] = gmshNodes[3]; // 3 -> 2\n            feaScriptNodes[3] = gmshNodes[4]; // 4 -> 3\n            feaScriptNodes[4] = gmshNodes[8]; // 8 -> 4\n            feaScriptNodes[5] = gmshNodes[6]; // 6 -> 5\n            feaScriptNodes[6] = gmshNodes[1]; // 1 -> 6\n            feaScriptNodes[7] = gmshNodes[5]; // 5 -> 7\n            feaScriptNodes[8] = gmshNodes[2]; // 2 -> 8\n          }\n\n          mappedNodalNumbering.push(feaScriptNodes);\n        }\n\n        this.parsedMesh.nodalNumbering = mappedNodalNumbering;\n      } else if (this.parsedMesh.elementTypes[2]) {\n        errorLog(\"Element type is neither triangle nor quad; mapping for this type is not implemented yet.\");\n      }\n\n      debugLog(\n        \"Nodal numbering after mapping from GMSH to FEAScript format: \" +\n          JSON.stringify(this.parsedMesh.nodalNumbering)\n      );\n\n      // Process boundary elements if they exist and if physical property mapping exists\n      if (this.parsedMesh.physicalPropMap && this.parsedMesh.boundaryElements) {\n        // Check if boundary elements need to be processed\n        if (\n          Array.isArray(this.parsedMesh.boundaryElements) &&\n          this.parsedMesh.boundaryElements.length > 0 &&\n          this.parsedMesh.boundaryElements[0] === undefined\n        ) {\n          // Create a new array without the empty first element\n          const fixedBoundaryElements = [];\n          for (let i = 1; i < this.parsedMesh.boundaryElements.length; i++) {\n            if (this.parsedMesh.boundaryElements[i]) {\n              fixedBoundaryElements.push(this.parsedMesh.boundaryElements[i]);\n            }\n          }\n          this.parsedMesh.boundaryElements = fixedBoundaryElements;\n        }\n\n        // If boundary node pairs exist but boundary elements haven't been processed\n        if (this.parsedMesh.boundaryNodePairs && !this.parsedMesh.boundaryElementsProcessed) {\n          // Reset boundary elements array\n          this.parsedMesh.boundaryElements = [];\n\n          // Process each physical property from the Gmsh file\n          this.parsedMesh.physicalPropMap.forEach((prop) => {\n            // Only process 1D physical entities (boundary lines)\n            if (prop.dimension === 1) {\n              // Get all node pairs for this boundary\n              const boundaryNodePairs = this.parsedMesh.boundaryNodePairs[prop.tag] || [];\n\n              if (boundaryNodePairs.length > 0) {\n                // Initialize array for this boundary tag\n                if (!this.parsedMesh.boundaryElements[prop.tag]) {\n                  this.parsedMesh.boundaryElements[prop.tag] = [];\n                }\n\n                // For each boundary line segment (defined by a pair of nodes)\n                boundaryNodePairs.forEach((nodesPair) => {\n                  const node1 = nodesPair[0]; // First node in the pair\n                  const node2 = nodesPair[1]; // Second node in the pair\n\n                  debugLog(\n                    `Processing boundary node pair: [${node1}, ${node2}] for boundary ${prop.tag} (${\n                      prop.name || \"unnamed\"\n                    })`\n                  );\n\n                  // Search through all elements to find which one contains both nodes\n                  let foundElement = false;\n\n                  // Loop through all elements in the mesh\n                  for (let elemIdx = 0; elemIdx < this.parsedMesh.nodalNumbering.length; elemIdx++) {\n                    const elemNodes = this.parsedMesh.nodalNumbering[elemIdx];\n\n                    // For linear quadrilateral linear elements (4 nodes)\n                    if (elemNodes.length === 4) {\n                      // Check if both boundary nodes are in this element\n                      if (elemNodes.includes(node1) && elemNodes.includes(node2)) {\n                        // Find which side of the element these nodes form\n                        let side;\n\n                        const node1Index = elemNodes.indexOf(node1);\n                        const node2Index = elemNodes.indexOf(node2);\n\n                        debugLog(\n                          `  Found element ${elemIdx} containing boundary nodes. Element nodes: [${elemNodes.join(\n                            \", \"\n                          )}]`\n                        );\n                        debugLog(\n                          `  Node ${node1} is at index ${node1Index}, Node ${node2} is at index ${node2Index} in the element`\n                        );\n\n                        // Based on FEAScript linear quadrilateral numbering:\n                        // 1 --- 3\n                        // |     |\n                        // 0 --- 2\n\n                        if (\n                          (node1Index === 0 && node2Index === 2) ||\n                          (node1Index === 2 && node2Index === 0)\n                        ) {\n                          side = 0; // Bottom side\n                          debugLog(`  These nodes form the BOTTOM side (${side}) of element ${elemIdx}`);\n                        } else if (\n                          (node1Index === 0 && node2Index === 1) ||\n                          (node1Index === 1 && node2Index === 0)\n                        ) {\n                          side = 1; // Left side\n                          debugLog(`  These nodes form the LEFT side (${side}) of element ${elemIdx}`);\n                        } else if (\n                          (node1Index === 1 && node2Index === 3) ||\n                          (node1Index === 3 && node2Index === 1)\n                        ) {\n                          side = 2; // Top side\n                          debugLog(`  These nodes form the TOP side (${side}) of element ${elemIdx}`);\n                        } else if (\n                          (node1Index === 2 && node2Index === 3) ||\n                          (node1Index === 3 && node2Index === 2)\n                        ) {\n                          side = 3; // Right side\n                          debugLog(`  These nodes form the RIGHT side (${side}) of element ${elemIdx}`);\n                        }\n\n                        // Add the element and side to the boundary elements array\n                        this.parsedMesh.boundaryElements[prop.tag].push([elemIdx, side]);\n                        debugLog(\n                          `  Added element-side pair [${elemIdx}, ${side}] to boundary tag ${prop.tag}`\n                        );\n                        foundElement = true;\n                        break;\n                      }\n                    } else if (elemNodes.length === 9) {\n                      // For quadratic quadrilateral elements (9 nodes)\n                      // Check if both boundary nodes are in this element\n                      if (elemNodes.includes(node1) && elemNodes.includes(node2)) {\n                        // Find which side of the element these nodes form\n                        let side;\n\n                        const node1Index = elemNodes.indexOf(node1);\n                        const node2Index = elemNodes.indexOf(node2);\n\n                        debugLog(\n                          `  Found element ${elemIdx} containing boundary nodes. Element nodes: [${elemNodes.join(\n                            \", \"\n                          )}]`\n                        );\n                        debugLog(\n                          `  Node ${node1} is at index ${node1Index}, Node ${node2} is at index ${node2Index} in the element`\n                        );\n\n                        // Based on FEAScript quadratic quadrilateral numbering:\n                        // 2--5--8\n                        // |     |\n                        // 1  4  7\n                        // |     |\n                        // 0--3--6\n\n                        // TODO: Transform into dictionaries for better readability\n                        if (\n                          (node1Index === 0 && node2Index === 6) ||\n                          (node1Index === 6 && node2Index === 0) ||\n                          (node1Index === 0 && node2Index === 3) ||\n                          (node1Index === 3 && node2Index === 0) ||\n                          (node1Index === 3 && node2Index === 6) ||\n                          (node1Index === 6 && node2Index === 3)\n                        ) {\n                          side = 0; // Bottom side (nodes 0, 3, 6)\n                          debugLog(`  These nodes form the BOTTOM side (${side}) of element ${elemIdx}`);\n                        } else if (\n                          (node1Index === 0 && node2Index === 2) ||\n                          (node1Index === 2 && node2Index === 0) ||\n                          (node1Index === 0 && node2Index === 1) ||\n                          (node1Index === 1 && node2Index === 0) ||\n                          (node1Index === 1 && node2Index === 2) ||\n                          (node1Index === 2 && node2Index === 1)\n                        ) {\n                          side = 1; // Left side (nodes 0, 1, 2)\n                          debugLog(`  These nodes form the LEFT side (${side}) of element ${elemIdx}`);\n                        } else if (\n                          (node1Index === 2 && node2Index === 8) ||\n                          (node1Index === 8 && node2Index === 2) ||\n                          (node1Index === 2 && node2Index === 5) ||\n                          (node1Index === 5 && node2Index === 2) ||\n                          (node1Index === 5 && node2Index === 8) ||\n                          (node1Index === 8 && node2Index === 5)\n                        ) {\n                          side = 2; // Top side (nodes 2, 5, 8)\n                          debugLog(`  These nodes form the TOP side (${side}) of element ${elemIdx}`);\n                        } else if (\n                          (node1Index === 6 && node2Index === 8) ||\n                          (node1Index === 8 && node2Index === 6) ||\n                          (node1Index === 6 && node2Index === 7) ||\n                          (node1Index === 7 && node2Index === 6) ||\n                          (node1Index === 7 && node2Index === 8) ||\n                          (node1Index === 8 && node2Index === 7)\n                        ) {\n                          side = 3; // Right side (nodes 6, 7, 8)\n                          debugLog(`  These nodes form the RIGHT side (${side}) of element ${elemIdx}`);\n                        }\n\n                        // Add the element and side to the boundary elements array\n                        this.parsedMesh.boundaryElements[prop.tag].push([elemIdx, side]);\n                        debugLog(\n                          `  Added element-side pair [${elemIdx}, ${side}] to boundary tag ${prop.tag}`\n                        );\n                        foundElement = true;\n                        break;\n                      }\n                    }\n                  }\n\n                  if (!foundElement) {\n                    errorLog(\n                      `Could not find element containing boundary nodes ${node1} and ${node2}. Boundary may be incomplete.`\n                    );\n                  }\n                });\n              }\n            }\n          });\n\n          // Mark as processed\n          this.boundaryElementsProcessed = true;\n\n          // Fix boundary elements array - remove undefined entries\n          if (\n            this.parsedMesh.boundaryElements.length > 0 &&\n            this.parsedMesh.boundaryElements[0] === undefined\n          ) {\n            const fixedBoundaryElements = [];\n            for (let i = 1; i < this.parsedMesh.boundaryElements.length; i++) {\n              if (this.parsedMesh.boundaryElements[i]) {\n                fixedBoundaryElements.push(this.parsedMesh.boundaryElements[i]);\n              }\n            }\n            this.parsedMesh.boundaryElements = fixedBoundaryElements;\n          }\n        }\n      }\n    }\n\n    return this.parsedMesh;\n  }\n}\n\nexport class Mesh1D extends Mesh {\n  /**\n   * Constructor to initialize the 1D mesh\n   * @param {object} config - Configuration object for the 1D mesh\n   * @param {number} [config.numElementsX] - Number of elements along the x-axis (required for geometry-based mesh)\n   * @param {number} [config.maxX] - Maximum x-coordinate of the mesh (required for geometry-based mesh)\n   * @param {string} [config.elementOrder='linear'] - The order of elements, either 'linear' or 'quadratic'\n   * @param {object} [config.parsedMesh=null] - Optional pre-parsed mesh data\n   */\n  constructor({ numElementsX = null, maxX = null, elementOrder = \"linear\", parsedMesh = null }) {\n    super({\n      numElementsX,\n      maxX,\n      numElementsY: 1,\n      maxY: 0,\n      meshDimension: \"1D\",\n      elementOrder,\n      parsedMesh,\n    });\n\n    if (this.numElementsX === null || this.maxX === null) {\n      errorLog(\"numElementsX and maxX are required parameters when generating a 1D mesh from geometry\");\n    }\n  }\n\n  generateMesh() {\n    let nodesXCoordinates = [];\n    let nodesYCoordinates = [];\n    const xStart = 0;\n    let totalNodesX, deltaX;\n\n    if (this.elementOrder === \"linear\") {\n      totalNodesX = this.numElementsX + 1;\n      deltaX = (this.maxX - xStart) / this.numElementsX;\n\n      nodesXCoordinates[0] = xStart;\n      for (let nodeIndex = 1; nodeIndex < totalNodesX; nodeIndex++) {\n        nodesXCoordinates[nodeIndex] = nodesXCoordinates[nodeIndex - 1] + deltaX;\n      }\n    } else if (this.elementOrder === \"quadratic\") {\n      totalNodesX = 2 * this.numElementsX + 1;\n      deltaX = (this.maxX - xStart) / this.numElementsX;\n\n      nodesXCoordinates[0] = xStart;\n      for (let nodeIndex = 1; nodeIndex < totalNodesX; nodeIndex++) {\n        nodesXCoordinates[nodeIndex] = nodesXCoordinates[nodeIndex - 1] + deltaX / 2;\n      }\n    }\n    // Generate nodal numbering (NOP) array\n    const nodalNumbering = this.generate1DNodalNumbering(this.numElementsX, totalNodesX, this.elementOrder);\n    // Find boundary elements\n    const boundaryElements = this.findBoundaryElements();\n\n    debugLog(\"Generated node X coordinates: \" + JSON.stringify(nodesXCoordinates));\n\n    // Return x coordinates of nodes, total nodes, NOP array, and boundary elements\n    return {\n      nodesXCoordinates,\n      totalNodesX,\n      nodalNumbering,\n      boundaryElements,\n    };\n  }\n\n  /**\n   * Function to generate the nodal numbering (NOP) array for a structured mesh\n   * This array represents the connectivity between elements and their corresponding nodes\n   * @param {number} numElementsX - Number of elements along the x-axis\n   * @param {number} totalNodesX - Total number of nodes along the x-axis\n   * @param {string} elementOrder - The order of elements, either 'linear' or 'quadratic'\n   * @returns {array} NOP - A two-dimensional array which represents the element-to-node connectivity for the entire mesh\n   */\n  generate1DNodalNumbering(numElementsX, totalNodesX, elementOrder) {\n    // TODO: The totalNodesX is not used in the original function. Verify if\n    // there is a multiple calculation on the totalNodes.\n\n    let elementIndex = 0;\n    let nop = [];\n\n    if (elementOrder === \"linear\") {\n      /**\n       * Linear 1D elements with the following nodes representation:\n       *\n       *   1 --- 2\n       *\n       */\n      for (let elementIndex = 0; elementIndex < numElementsX; elementIndex++) {\n        nop[elementIndex] = [];\n        for (let nodeIndex = 1; nodeIndex <= 2; nodeIndex++) {\n          nop[elementIndex][nodeIndex - 1] = elementIndex + nodeIndex;\n        }\n      }\n    } else if (elementOrder === \"quadratic\") {\n      /**\n       * Quadratic 1D elements with the following nodes representation:\n       *\n       *   1--2--3\n       *\n       */\n      let columnCounter = 0;\n      for (let elementIndex = 0; elementIndex < numElementsX; elementIndex++) {\n        nop[elementIndex] = [];\n        for (let nodeIndex = 1; nodeIndex <= 3; nodeIndex++) {\n          nop[elementIndex][nodeIndex - 1] = elementIndex + nodeIndex + columnCounter;\n        }\n        columnCounter += 1;\n      }\n    }\n\n    return nop;\n  }\n\n  /**\n   * Function to find the elements that belong to each boundary of a domain\n   * @returns {array} An array containing arrays of elements and their adjacent boundary side for each boundary\n   * Each element in the array is of the form [elementIndex, side], where 'side' indicates which side\n   * of the reference element is in contact with the physical boundary:\n   *\n   * For 1D domains (line segments):\n   * 0 - Left node of reference element (maps to physical left endpoint)\n   * 1 - Right node of reference element (maps to physical right endpoint)\n   */\n  findBoundaryElements() {\n    const boundaryElements = [];\n    const maxSides = 2; // For 1D, we only have two sides (left and right)\n    for (let sideIndex = 0; sideIndex < maxSides; sideIndex++) {\n      boundaryElements.push([]);\n    }\n\n    // Left boundary (element 0, side 0)\n    boundaryElements[0].push([0, 0]);\n\n    // Right boundary (last element, side 1)\n    boundaryElements[1].push([this.numElementsX - 1, 1]);\n\n    debugLog(\"Identified boundary elements by side: \" + JSON.stringify(boundaryElements));\n    this.boundaryElementsProcessed = true;\n    return boundaryElements;\n  }\n}\n\nexport class Mesh2D extends Mesh {\n  /**\n   * Constructor to initialize the 2D mesh\n   * @param {object} config - Configuration object for the 2D mesh\n   * @param {number} [config.numElementsX] - Number of elements along the x-axis (required for geometry-based mesh)\n   * @param {number} [config.maxX] - Maximum x-coordinate of the mesh (required for geometry-based mesh)\n   * @param {number} [config.numElementsY] - Number of elements along the y-axis (required for geometry-based mesh)\n   * @param {number} [config.maxY] - Maximum y-coordinate of the mesh (required for geometry-based mesh)\n   * @param {string} [config.elementOrder='linear'] - The order of elements, either 'linear' or 'quadratic'\n   * @param {object} [config.parsedMesh=null] - Optional pre-parsed mesh data\n   */\n  constructor({\n    numElementsX = null,\n    maxX = null,\n    numElementsY = null,\n    maxY = null,\n    elementOrder = \"linear\",\n    parsedMesh = null,\n  }) {\n    super({\n      numElementsX,\n      maxX,\n      numElementsY,\n      maxY,\n      meshDimension: \"2D\",\n      elementOrder,\n      parsedMesh,\n    });\n\n    // Validate geometry parameters (when not using a parsed mesh)\n    if (\n      !parsedMesh &&\n      (this.numElementsX === null || this.maxX === null || this.numElementsY === null || this.maxY === null)\n    ) {\n      errorLog(\n        \"numElementsX, maxX, numElementsY, and maxY are required parameters when generating a 2D mesh from geometry\"\n      );\n    }\n  }\n\n  generateMesh() {\n    let nodesXCoordinates = [];\n    let nodesYCoordinates = [];\n    const xStart = 0;\n    const yStart = 0;\n    let totalNodesX, totalNodesY, deltaX, deltaY;\n\n    if (this.elementOrder === \"linear\") {\n      totalNodesX = this.numElementsX + 1;\n      totalNodesY = this.numElementsY + 1;\n      deltaX = (this.maxX - xStart) / this.numElementsX;\n      deltaY = (this.maxY - yStart) / this.numElementsY;\n\n      nodesXCoordinates[0] = xStart;\n      nodesYCoordinates[0] = yStart;\n      for (let nodeIndexY = 1; nodeIndexY < totalNodesY; nodeIndexY++) {\n        nodesXCoordinates[nodeIndexY] = nodesXCoordinates[0];\n        nodesYCoordinates[nodeIndexY] = nodesYCoordinates[0] + nodeIndexY * deltaY;\n      }\n      for (let nodeIndexX = 1; nodeIndexX < totalNodesX; nodeIndexX++) {\n        const nnode = nodeIndexX * totalNodesY;\n        nodesXCoordinates[nnode] = nodesXCoordinates[0] + nodeIndexX * deltaX;\n        nodesYCoordinates[nnode] = nodesYCoordinates[0];\n        for (let nodeIndexY = 1; nodeIndexY < totalNodesY; nodeIndexY++) {\n          nodesXCoordinates[nnode + nodeIndexY] = nodesXCoordinates[nnode];\n          nodesYCoordinates[nnode + nodeIndexY] = nodesYCoordinates[nnode] + nodeIndexY * deltaY;\n        }\n      }\n    } else if (this.elementOrder === \"quadratic\") {\n      totalNodesX = 2 * this.numElementsX + 1;\n      totalNodesY = 2 * this.numElementsY + 1;\n      deltaX = (this.maxX - xStart) / this.numElementsX;\n      deltaY = (this.maxY - yStart) / this.numElementsY;\n\n      nodesXCoordinates[0] = xStart;\n      nodesYCoordinates[0] = yStart;\n      for (let nodeIndexY = 1; nodeIndexY < totalNodesY; nodeIndexY++) {\n        nodesXCoordinates[nodeIndexY] = nodesXCoordinates[0];\n        nodesYCoordinates[nodeIndexY] = nodesYCoordinates[0] + (nodeIndexY * deltaY) / 2;\n      }\n      for (let nodeIndexX = 1; nodeIndexX < totalNodesX; nodeIndexX++) {\n        const nnode = nodeIndexX * totalNodesY;\n        nodesXCoordinates[nnode] = nodesXCoordinates[0] + (nodeIndexX * deltaX) / 2;\n        nodesYCoordinates[nnode] = nodesYCoordinates[0];\n        for (let nodeIndexY = 1; nodeIndexY < totalNodesY; nodeIndexY++) {\n          nodesXCoordinates[nnode + nodeIndexY] = nodesXCoordinates[nnode];\n          nodesYCoordinates[nnode + nodeIndexY] = nodesYCoordinates[nnode] + (nodeIndexY * deltaY) / 2;\n        }\n      }\n    }\n\n    // Generate nodal numbering (NOP) array\n    const nodalNumbering = this.generate2DNodalNumbering(\n      this.numElementsX,\n      this.numElementsY,\n      totalNodesY,\n      this.elementOrder\n    );\n\n    // Find boundary elements\n    const boundaryElements = this.findBoundaryElements();\n\n    debugLog(\"Generated node X coordinates: \" + JSON.stringify(nodesXCoordinates));\n    debugLog(\"Generated node Y coordinates: \" + JSON.stringify(nodesYCoordinates));\n\n    // Return statement\n    return {\n      nodesXCoordinates,\n      nodesYCoordinates,\n      totalNodesX,\n      totalNodesY,\n      nodalNumbering,\n      boundaryElements,\n    };\n  }\n\n  /**\n   * Function to generate the nodal numbering (NOP) array for a structured mesh\n   * This array represents the connectivity between elements and their corresponding nodes\n   * @param {number} numElementsX - Number of elements along the x-axis\n   * @param {number} [numElementsY] - Number of elements along the y-axis (optional for 1D)\n   * @param {number} totalNodesX - Total number of nodes along the x-axis\n   * @param {number} [totalNodesY] - Total number of nodes along the y-axis (optional for 1D)\n   * @param {string} elementOrder - The order of elements, either 'linear' or 'quadratic'\n   * @returns {array} NOP - A two-dimensional array which represents the element-to-node connectivity for the entire mesh\n   */\n  generate2DNodalNumbering(numElementsX, numElementsY, totalNodesY, elementOrder) {\n    let elementIndex = 0;\n    let nop = [];\n\n    if (elementOrder === \"linear\") {\n      /**\n       * Linear rectangular elements with the following nodes representation:\n       *\n       *   1 --- 3\n       *   |     |\n       *   0 --- 2\n       *\n       */\n      let rowCounter = 0;\n      let columnCounter = 2;\n      for (let elementIndex = 0; elementIndex < numElementsX * numElementsY; elementIndex++) {\n        rowCounter += 1;\n        nop[elementIndex] = [];\n        nop[elementIndex][0] = elementIndex + columnCounter - 1;\n        nop[elementIndex][1] = elementIndex + columnCounter;\n        nop[elementIndex][2] = elementIndex + columnCounter + numElementsY;\n        nop[elementIndex][3] = elementIndex + columnCounter + numElementsY + 1;\n        if (rowCounter === numElementsY) {\n          columnCounter += 1;\n          rowCounter = 0;\n        }\n      }\n    } else if (elementOrder === \"quadratic\") {\n      /**\n       * Quadratic rectangular elements with the following nodes representation:\n       *\n       *   2--5--8\n       *   |     |\n       *   1  4  7\n       *   |     |\n       *   0--3--6\n       *\n       */\n      for (let elementIndexX = 1; elementIndexX <= numElementsX; elementIndexX++) {\n        for (let elementIndexY = 1; elementIndexY <= numElementsY; elementIndexY++) {\n          nop[elementIndex] = [];\n          for (let nodeIndex1 = 1; nodeIndex1 <= 3; nodeIndex1++) {\n            let nodeIndex2 = 3 * nodeIndex1 - 2;\n            nop[elementIndex][nodeIndex2 - 1] =\n              totalNodesY * (2 * elementIndexX + nodeIndex1 - 3) + 2 * elementIndexY - 1;\n            nop[elementIndex][nodeIndex2] = nop[elementIndex][nodeIndex2 - 1] + 1;\n            nop[elementIndex][nodeIndex2 + 1] = nop[elementIndex][nodeIndex2 - 1] + 2;\n          }\n          elementIndex = elementIndex + 1;\n        }\n      }\n    }\n\n    return nop;\n  }\n\n  /**\n   * Function to find the elements that belong to each boundary of a domain\n   * @returns {array} An array containing arrays of elements and their adjacent boundary side for each boundary\n   * Each element in the array is of the form [elementIndex, side], where 'side' indicates which side\n   * of the reference element is in contact with the physical boundary:\n   *\n   * For 2D domains (rectangular):\n   * 0 - Bottom side of reference element (maps to physical bottom boundary)\n   * 1 - Left side of reference element (maps to physical left boundary)\n   * 2 - Top side of reference element (maps to physical top boundary)\n   * 3 - Right side of reference element (maps to physical right boundary)\n   */\n  findBoundaryElements() {\n    const boundaryElements = [];\n    const maxSides = 4; // For 2D, we have four sides (left, right, bottom, top)\n\n    for (let sideIndex = 0; sideIndex < maxSides; sideIndex++) {\n      boundaryElements.push([]);\n    }\n\n    // TODO: Why to loop through all elements? Is it not better to loop over only the\n    // elements that are on the boundary? eg: [0, this.numElementsX - 1] on x and\n    // [0, this.numElementsY - 1] on y\n    for (let elementIndexX = 0; elementIndexX < this.numElementsX; elementIndexX++) {\n      for (let elementIndexY = 0; elementIndexY < this.numElementsY; elementIndexY++) {\n        const elementIndex = elementIndexX * this.numElementsY + elementIndexY;\n\n        // Bottom boundary\n        if (elementIndexY === 0) {\n          boundaryElements[0].push([elementIndex, 0]);\n        }\n\n        // Left boundary\n        if (elementIndexX === 0) {\n          boundaryElements[1].push([elementIndex, 1]);\n        }\n\n        // Top boundary\n        if (elementIndexY === this.numElementsY - 1) {\n          boundaryElements[2].push([elementIndex, 2]);\n        }\n\n        // Right boundary\n        if (elementIndexX === this.numElementsX - 1) {\n          boundaryElements[3].push([elementIndex, 3]);\n        }\n      }\n    }\n\n    debugLog(\"Identified boundary elements by side: \" + JSON.stringify(boundaryElements));\n    this.boundaryElementsProcessed = true;\n    return boundaryElements;\n  }\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n/**\n * Class to handle numerical integration using Gauss quadrature\n */\nexport class NumericalIntegration {\n  /**\n   * Constructor to initialize the NumericalIntegration class\n   * @param {string} meshDimension - The dimension of the mesh\n   * @param {string} elementOrder - The order of elements\n   */\n  constructor({ meshDimension, elementOrder }) {\n    this.meshDimension = meshDimension;\n    this.elementOrder = elementOrder;\n  }\n\n  /**\n   * Function to return Gauss points and weights based on element configuration\n   * @returns {object} An object containing:\n   *  - gaussPoints: Array of Gauss points\n   *  - gaussWeights: Array of Gauss weights\n   */\n  getGaussPointsAndWeights() {\n    let gaussPoints = []; // Gauss points\n    let gaussWeights = []; // Gauss weights\n\n    if (this.elementOrder === \"linear\") {\n      // For linear elements, use 1-point Gauss quadrature\n      gaussPoints[0] = 0.5;\n      gaussWeights[0] = 1;\n    } else if (this.elementOrder === \"quadratic\") {\n      // For quadratic elements, use 3-point Gauss quadrature\n      gaussPoints[0] = (1 - Math.sqrt(3 / 5)) / 2;\n      gaussPoints[1] = 0.5;\n      gaussPoints[2] = (1 + Math.sqrt(3 / 5)) / 2;\n      gaussWeights[0] = 5 / 18;\n      gaussWeights[1] = 8 / 18;\n      gaussWeights[2] = 5 / 18;\n    }\n\n    return { gaussPoints, gaussWeights };\n  }\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\nimport { BasisFunctions } from \"./basisFunctionsScript.js\";\nimport { Mesh1D, Mesh2D } from \"./meshGenerationScript.js\";\nimport { NumericalIntegration } from \"../methods/numericalIntegrationScript.js\";\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Function to prepare the mesh for finite element analysis\n * @param {object} meshConfig - Object containing computational mesh details\n * @returns {object} An object containing all mesh-related data\n */\nexport function prepareMesh(meshConfig) {\n  const { meshDimension, numElementsX, numElementsY, maxX, maxY, elementOrder, parsedMesh } = meshConfig;\n\n  // Create a new instance of the Mesh class\n  let mesh;\n  if (meshDimension === \"1D\") {\n    mesh = new Mesh1D({ numElementsX, maxX, elementOrder, parsedMesh });\n  } else if (meshDimension === \"2D\") {\n    mesh = new Mesh2D({ numElementsX, maxX, numElementsY, maxY, elementOrder, parsedMesh });\n  } else {\n    errorLog(\"Mesh dimension must be either '1D' or '2D'.\");\n  }\n\n  // Use the parsed mesh in case it was already passed with Gmsh format\n  const nodesCoordinatesAndNumbering = mesh.boundaryElementsProcessed ? mesh.parsedMesh : mesh.generateMesh();\n\n  // Extract nodes coordinates and nodal numbering (NOP) from the mesh data\n  let nodesXCoordinates = nodesCoordinatesAndNumbering.nodesXCoordinates;\n  let nodesYCoordinates = nodesCoordinatesAndNumbering.nodesYCoordinates;\n  let totalNodesX = nodesCoordinatesAndNumbering.totalNodesX;\n  let totalNodesY = nodesCoordinatesAndNumbering.totalNodesY;\n  let nop = nodesCoordinatesAndNumbering.nodalNumbering;\n  let boundaryElements = nodesCoordinatesAndNumbering.boundaryElements;\n\n  // Check the mesh type\n  const isParsedMesh = parsedMesh !== undefined && parsedMesh !== null;\n\n  // Calculate totalElements and totalNodes based on mesh type\n  let totalElements, totalNodes;\n\n  if (isParsedMesh) {\n    totalElements = nop.length; // Number of elements is the length of the nodal numbering array\n    totalNodes = nodesXCoordinates.length; // Number of nodes is the length of the coordinates array\n    debugLog(`Using parsed mesh with ${totalElements} elements and ${totalNodes} nodes`);\n  } else {\n    // For structured mesh, calculate based on dimensions\n    totalElements = numElementsX * (meshDimension === \"2D\" ? numElementsY : 1);\n    totalNodes = totalNodesX * (meshDimension === \"2D\" ? totalNodesY : 1);\n    debugLog(`Using mesh generated from geometry with ${totalElements} elements and ${totalNodes} nodes`);\n  }\n\n  return {\n    nodesXCoordinates,\n    nodesYCoordinates,\n    totalNodesX,\n    totalNodesY,\n    nop,\n    boundaryElements,\n    totalElements,\n    totalNodes,\n    meshDimension,\n    elementOrder,\n  };\n}\n\n/**\n * Function to initialize the FEA matrices and numerical tools\n * @param {object} meshData - Object containing mesh data from prepareMesh()\n * @returns {object} An object containing initialized matrices and numerical tools\n */\nexport function initializeFEA(meshData) {\n  const { totalNodes, nop, meshDimension, elementOrder } = meshData;\n\n  // Initialize variables for matrix assembly\n  let residualVector = [];\n  let jacobianMatrix = [];\n  let localToGlobalMap = [];\n\n  // Initialize jacobianMatrix and residualVector arrays\n  for (let nodeIndex = 0; nodeIndex < totalNodes; nodeIndex++) {\n    residualVector[nodeIndex] = 0;\n    jacobianMatrix.push([]);\n    for (let colIndex = 0; colIndex < totalNodes; colIndex++) {\n      jacobianMatrix[nodeIndex][colIndex] = 0;\n    }\n  }\n\n  // Initialize the BasisFunctions class\n  const basisFunctions = new BasisFunctions({\n    meshDimension,\n    elementOrder,\n  });\n\n  // Initialize the NumericalIntegration class\n  const numericalIntegration = new NumericalIntegration({\n    meshDimension,\n    elementOrder,\n  });\n\n  // Calculate Gauss points and weights\n  let gaussPointsAndWeights = numericalIntegration.getGaussPointsAndWeights();\n  let gaussPoints = gaussPointsAndWeights.gaussPoints;\n  let gaussWeights = gaussPointsAndWeights.gaussWeights;\n\n  // Determine the number of nodes in the reference element based on the first element in the nop array\n  const numNodes = nop[0].length;\n\n  return {\n    residualVector,\n    jacobianMatrix,\n    localToGlobalMap,\n    basisFunctions,\n    gaussPoints,\n    gaussWeights,\n    numNodes,\n  };\n}\n\n/**\n * Function to perform isoparametric mapping for 1D elements\n * @param {object} params - Parameters for the mapping\n * @returns {object} An object containing the mapped data\n */\nexport function performIsoparametricMapping1D(params) {\n  const { basisFunction, basisFunctionDerivKsi, nodesXCoordinates, localToGlobalMap, numNodes } = params;\n\n  let xCoordinates = 0;\n  let ksiDerivX = 0;\n\n  // Isoparametric mapping\n  for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n    xCoordinates += nodesXCoordinates[localToGlobalMap[localNodeIndex]] * basisFunction[localNodeIndex];\n    ksiDerivX += nodesXCoordinates[localToGlobalMap[localNodeIndex]] * basisFunctionDerivKsi[localNodeIndex];\n  }\n  let detJacobian = ksiDerivX;\n\n  // Compute x-derivative of basis functions\n  let basisFunctionDerivX = [];\n  for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n    basisFunctionDerivX[localNodeIndex] = basisFunctionDerivKsi[localNodeIndex] / detJacobian;\n  }\n\n  return {\n    xCoordinates,\n    detJacobian,\n    basisFunctionDerivX,\n  };\n}\n\n/**\n * Function to perform isoparametric mapping for 2D elements\n * @param {object} params - Parameters for the mapping\n * @returns {object} An object containing the mapped data\n */\nexport function performIsoparametricMapping2D(params) {\n  const {\n    basisFunction,\n    basisFunctionDerivKsi,\n    basisFunctionDerivEta,\n    nodesXCoordinates,\n    nodesYCoordinates,\n    localToGlobalMap,\n    numNodes,\n  } = params;\n\n  let xCoordinates = 0;\n  let yCoordinates = 0;\n  let ksiDerivX = 0;\n  let etaDerivX = 0;\n  let ksiDerivY = 0;\n  let etaDerivY = 0;\n\n  // Isoparametric mapping\n  for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n    xCoordinates += nodesXCoordinates[localToGlobalMap[localNodeIndex]] * basisFunction[localNodeIndex];\n    yCoordinates += nodesYCoordinates[localToGlobalMap[localNodeIndex]] * basisFunction[localNodeIndex];\n    ksiDerivX += nodesXCoordinates[localToGlobalMap[localNodeIndex]] * basisFunctionDerivKsi[localNodeIndex];\n    etaDerivX += nodesXCoordinates[localToGlobalMap[localNodeIndex]] * basisFunctionDerivEta[localNodeIndex];\n    ksiDerivY += nodesYCoordinates[localToGlobalMap[localNodeIndex]] * basisFunctionDerivKsi[localNodeIndex];\n    etaDerivY += nodesYCoordinates[localToGlobalMap[localNodeIndex]] * basisFunctionDerivEta[localNodeIndex];\n  }\n  let detJacobian = ksiDerivX * etaDerivY - etaDerivX * ksiDerivY;\n\n  // Compute x-derivative and y-derivative of basis functions\n  let basisFunctionDerivX = [];\n  let basisFunctionDerivY = [];\n  for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n    // The x-derivative of the n basis function\n    basisFunctionDerivX[localNodeIndex] =\n      (etaDerivY * basisFunctionDerivKsi[localNodeIndex] -\n        ksiDerivY * basisFunctionDerivEta[localNodeIndex]) /\n      detJacobian;\n    // The y-derivative of the n basis function\n    basisFunctionDerivY[localNodeIndex] =\n      (ksiDerivX * basisFunctionDerivEta[localNodeIndex] -\n        etaDerivX * basisFunctionDerivKsi[localNodeIndex]) /\n      detJacobian;\n  }\n\n  return {\n    xCoordinates,\n    yCoordinates,\n    detJacobian,\n    basisFunctionDerivX,\n    basisFunctionDerivY,\n  };\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n// Internal imports\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n// This class is essentially the same with ThermalBoundaryConditions\n// Need to consolidate them in the future\n\n/**\n * Class to handle generic boundary conditions application\n */\nexport class GenericBoundaryConditions {\n  /**\n   * Constructor to initialize the GenericBoundaryConditions class\n   * @param {object} boundaryConditions - Object containing boundary conditions for the finite element analysis\n   * @param {array} boundaryElements - Array containing elements that belong to each boundary\n   * @param {array} nop - Nodal numbering (NOP) array representing the connectivity between elements and nodes\n   * @param {string} meshDimension - The dimension of the mesh (e.g., \"2D\")\n   * @param {string} elementOrder - The order of elements (e.g., \"linear\", \"quadratic\")\n   */\n  constructor(boundaryConditions, boundaryElements, nop, meshDimension, elementOrder) {\n    this.boundaryConditions = boundaryConditions;\n    this.boundaryElements = boundaryElements;\n    this.nop = nop;\n    this.meshDimension = meshDimension;\n    this.elementOrder = elementOrder;\n  }\n\n  /**\n   * Function to impose constant value boundary conditions (Dirichlet type)\n   * @param {array} residualVector - The residual vector to be modified\n   * @param {array} jacobianMatrix - The Jacobian matrix to be modified\n   */\n  imposeConstantValueBoundaryConditions(residualVector, jacobianMatrix) {\n    basicLog(\"Applying constant value boundary conditions\");\n    if (this.meshDimension === \"1D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        if (this.boundaryConditions[boundaryKey][0] === \"constantValue\") {\n          const value = this.boundaryConditions[boundaryKey][1];\n          debugLog(`Boundary ${boundaryKey}: Applying constant value of ${value} (Dirichlet condition)`);\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            if (this.elementOrder === \"linear\") {\n              const boundarySides = {\n                0: [0], // Node at the left side of the reference element\n                1: [1], // Node at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant value to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                // Set the residual vector to the constantValue\n                residualVector[globalNodeIndex] = value;\n                // Set the Jacobian matrix row to zero\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\n                }\n                // Set the diagonal entry of the Jacobian matrix to one\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\n              });\n            } else if (this.elementOrder === \"quadratic\") {\n              const boundarySides = {\n                0: [0], // Node at the left side of the reference element\n                2: [2], // Node at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant value to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                // Set the residual vector to the constantValue\n                residualVector[globalNodeIndex] = value;\n                // Set the Jacobian matrix row to zero\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\n                }\n                // Set the diagonal entry of the Jacobian matrix to one\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\n              });\n            }\n          });\n        }\n      });\n    } else if (this.meshDimension === \"2D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        if (this.boundaryConditions[boundaryKey][0] === \"constantValue\") {\n          const value = this.boundaryConditions[boundaryKey][1];\n          debugLog(`Boundary ${boundaryKey}: Applying constant value of ${value} (Dirichlet condition)`);\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            if (this.elementOrder === \"linear\") {\n              const boundarySides = {\n                0: [0, 2], // Nodes at the bottom side of the reference element\n                1: [0, 1], // Nodes at the left side of the reference element\n                2: [1, 3], // Nodes at the top side of the reference element\n                3: [2, 3], // Nodes at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant value to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                // Set the residual vector to the constantValue\n                residualVector[globalNodeIndex] = value;\n                // Set the Jacobian matrix row to zero\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\n                }\n                // Set the diagonal entry of the Jacobian matrix to one\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\n              });\n            } else if (this.elementOrder === \"quadratic\") {\n              const boundarySides = {\n                0: [0, 3, 6], // Nodes at the bottom side of the reference element\n                1: [0, 1, 2], // Nodes at the left side of the reference element\n                2: [2, 5, 8], // Nodes at the top side of the reference element\n                3: [6, 7, 8], // Nodes at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant value to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                // Set the residual vector to the constantValue\n                residualVector[globalNodeIndex] = value;\n                // Set the Jacobian matrix row to zero\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\n                }\n                // Set the diagonal entry of the Jacobian matrix to one\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\n              });\n            }\n          });\n        }\n      });\n    }\n  }\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n// Internal imports\nimport { GenericBoundaryConditions } from \"./genericBoundaryConditionsScript.js\";\nimport {\n  initializeFEA,\n  performIsoparametricMapping1D,\n  performIsoparametricMapping2D,\n} from \"../mesh/meshUtilsScript.js\";\nimport { basicLog, debugLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Function to assemble the Jacobian matrix and residuals vector for the front propagation model\n * @param {object} meshData - Object containing prepared mesh data\n * @param {object} boundaryConditions - Object containing boundary conditions for the finite element analysis\n * @param {array} solutionVector - The solution vector for non-linear equations\n * @param {number} eikonalActivationFlag - Activation parameter for the eikonal equation\n * @returns {object}  An object containing:\n *  - jacobianMatrix: The assembled Jacobian matrix\n *  - residualVector: The assembled residual vector\n */\nexport function assembleFrontPropagationMat(\n  meshData,\n  boundaryConditions,\n  solutionVector,\n  eikonalActivationFlag\n) {\n  basicLog(\"Starting front propagation matrix assembly...\");\n\n  // Calculate eikonal viscous term\n  const baseEikonalViscousTerm = 1e-2; // Base viscous term that remains when eikonal equation is fully activated\n  let eikonalViscousTerm = 1 - eikonalActivationFlag + baseEikonalViscousTerm; // Viscous term for the front propagation (eikonal) equation\n  basicLog(`eikonalViscousTerm: ${eikonalViscousTerm}`);\n  basicLog(`eikonalActivationFlag: ${eikonalActivationFlag}`);\n\n  // Extract mesh data\n  const {\n    nodesXCoordinates,\n    nodesYCoordinates,\n    nop,\n    boundaryElements,\n    totalElements,\n    meshDimension,\n    elementOrder,\n  } = meshData;\n\n  // Initialize FEA components\n  const FEAData = initializeFEA(meshData);\n  const {\n    residualVector,\n    jacobianMatrix,\n    localToGlobalMap,\n    basisFunctions,\n    gaussPoints,\n    gaussWeights,\n    numNodes,\n  } = FEAData;\n\n  // Matrix assembly\n  for (let elementIndex = 0; elementIndex < totalElements; elementIndex++) {\n    // Map local element nodes to global mesh nodes\n    for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n      // Subtract 1 from nop in order to start numbering from 0\n      localToGlobalMap[localNodeIndex] = nop[elementIndex][localNodeIndex] - 1;\n    }\n\n    // Loop over Gauss points\n    for (let gaussPointIndex1 = 0; gaussPointIndex1 < gaussPoints.length; gaussPointIndex1++) {\n      // 1D front propagation (eikonal) equation\n      if (meshDimension === \"1D\") {\n        // Get basis functions for the current Gauss point\n        let basisFunctionsAndDerivatives = basisFunctions.getBasisFunctions(gaussPoints[gaussPointIndex1]);\n\n        // Perform isoparametric mapping\n        const mappingResult = performIsoparametricMapping1D({\n          basisFunction: basisFunctionsAndDerivatives.basisFunction,\n          basisFunctionDerivKsi: basisFunctionsAndDerivatives.basisFunctionDerivKsi,\n          nodesXCoordinates,\n          localToGlobalMap,\n          numNodes,\n        });\n\n        // Extract mapping results\n        const { detJacobian, basisFunctionDerivX } = mappingResult;\n        const basisFunction = basisFunctionsAndDerivatives.basisFunction;\n\n        // Calculate solution derivative\n        let solutionDerivX = 0;\n        for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n          solutionDerivX +=\n            solutionVector[localToGlobalMap[localNodeIndex]] * basisFunctionDerivX[localNodeIndex];\n        }\n\n        // Computation of Galerkin's residuals and Jacobian matrix\n        for (let localNodeIndex1 = 0; localNodeIndex1 < numNodes; localNodeIndex1++) {\n          let localToGlobalMap1 = localToGlobalMap[localNodeIndex1];\n          // residualVector\n          // To perform residualVector calculation here\n\n          for (let localNodeIndex2 = 0; localNodeIndex2 < numNodes; localNodeIndex2++) {\n            let localToGlobalMap2 = localToGlobalMap[localNodeIndex2];\n            // jacobianMatrix\n            // To perform jacobianMatrix calculation here\n          }\n        }\n      }\n      // 2D front propagation (eikonal) equation\n      else if (meshDimension === \"2D\") {\n        for (let gaussPointIndex2 = 0; gaussPointIndex2 < gaussPoints.length; gaussPointIndex2++) {\n          // Get basis functions for the current Gauss point\n          let basisFunctionsAndDerivatives = basisFunctions.getBasisFunctions(\n            gaussPoints[gaussPointIndex1],\n            gaussPoints[gaussPointIndex2]\n          );\n\n          // Perform isoparametric mapping\n          const mappingResult = performIsoparametricMapping2D({\n            basisFunction: basisFunctionsAndDerivatives.basisFunction,\n            basisFunctionDerivKsi: basisFunctionsAndDerivatives.basisFunctionDerivKsi,\n            basisFunctionDerivEta: basisFunctionsAndDerivatives.basisFunctionDerivEta,\n            nodesXCoordinates,\n            nodesYCoordinates,\n            localToGlobalMap,\n            numNodes,\n          });\n\n          // Extract mapping results\n          const { detJacobian, basisFunctionDerivX, basisFunctionDerivY } = mappingResult;\n          const basisFunction = basisFunctionsAndDerivatives.basisFunction;\n\n          // Calculate solution derivatives\n          let solutionDerivX = 0;\n          let solutionDerivY = 0;\n          for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n            solutionDerivX +=\n              solutionVector[localToGlobalMap[localNodeIndex]] * basisFunctionDerivX[localNodeIndex];\n            solutionDerivY +=\n              solutionVector[localToGlobalMap[localNodeIndex]] * basisFunctionDerivY[localNodeIndex];\n          }\n\n          // Computation of Galerkin's residuals and Jacobian matrix\n          for (let localNodeIndex1 = 0; localNodeIndex1 < numNodes; localNodeIndex1++) {\n            let localToGlobalMap1 = localToGlobalMap[localNodeIndex1];\n\n            // residualVector: Viscous term contribution (to stabilize the solution)\n            residualVector[localToGlobalMap1] +=\n              eikonalViscousTerm *\n                gaussWeights[gaussPointIndex1] *\n                gaussWeights[gaussPointIndex2] *\n                detJacobian *\n                basisFunctionDerivX[localNodeIndex1] *\n                solutionDerivX +\n              eikonalViscousTerm *\n                gaussWeights[gaussPointIndex1] *\n                gaussWeights[gaussPointIndex2] *\n                detJacobian *\n                basisFunctionDerivY[localNodeIndex1] *\n                solutionDerivY;\n\n            // residualVector: Eikonal equation contribution\n            if (eikonalActivationFlag !== 0) {\n              residualVector[localToGlobalMap1] +=\n                eikonalActivationFlag *\n                (gaussWeights[gaussPointIndex1] *\n                  gaussWeights[gaussPointIndex2] *\n                  detJacobian *\n                  basisFunction[localNodeIndex1] *\n                  Math.sqrt(solutionDerivX ** 2 + solutionDerivY ** 2) -\n                  gaussWeights[gaussPointIndex1] *\n                    gaussWeights[gaussPointIndex2] *\n                    detJacobian *\n                    basisFunction[localNodeIndex1]);\n            }\n\n            for (let localNodeIndex2 = 0; localNodeIndex2 < numNodes; localNodeIndex2++) {\n              let localToGlobalMap2 = localToGlobalMap[localNodeIndex2];\n\n              // jacobianMatrix: Viscous term contribution\n              jacobianMatrix[localToGlobalMap1][localToGlobalMap2] +=\n                -eikonalViscousTerm *\n                gaussWeights[gaussPointIndex1] *\n                gaussWeights[gaussPointIndex2] *\n                detJacobian *\n                (basisFunctionDerivX[localNodeIndex1] * basisFunctionDerivX[localNodeIndex2] +\n                  basisFunctionDerivY[localNodeIndex1] * basisFunctionDerivY[localNodeIndex2]);\n\n              // jacobianMatrix: Eikonal equation contribution\n              if (eikonalActivationFlag !== 0) {\n                jacobianMatrix[localToGlobalMap1][localToGlobalMap2] +=\n                  eikonalActivationFlag *\n                    (-(\n                      detJacobian *\n                      solutionDerivX *\n                      basisFunction[localNodeIndex1] *\n                      gaussWeights[gaussPointIndex1] *\n                      gaussWeights[gaussPointIndex2]\n                    ) /\n                      Math.sqrt(solutionDerivX ** 2 + solutionDerivY ** 2 + 1e-8)) *\n                    basisFunctionDerivX[localNodeIndex2] -\n                  ((detJacobian *\n                    solutionDerivY *\n                    basisFunction[localNodeIndex1] *\n                    gaussWeights[gaussPointIndex1] *\n                    gaussWeights[gaussPointIndex2]) /\n                    Math.sqrt(solutionDerivX ** 2 + solutionDerivY ** 2 + 1e-8)) *\n                    basisFunctionDerivY[localNodeIndex2];\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Apply boundary conditions\n  basicLog(\"Applying generic boundary conditions...\");\n  const genericBoundaryConditions = new GenericBoundaryConditions(\n    boundaryConditions,\n    boundaryElements,\n    nop,\n    meshDimension,\n    elementOrder\n  );\n\n  // Impose ConstantValue boundary conditions\n  genericBoundaryConditions.imposeConstantValueBoundaryConditions(residualVector, jacobianMatrix);\n  basicLog(\"Constant value boundary conditions applied\");\n\n  // Print all residuals in debug mode\n  debugLog(\"Residuals at each node:\");\n  for (let i = 0; i < residualVector.length; i++) {\n    debugLog(`Node ${i}: ${residualVector[i].toExponential(6)}`);\n  }\n\n  basicLog(\"Front propagation matrix assembly completed\");\n\n  return {\n    jacobianMatrix,\n    residualVector,\n  };\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n// Internal imports\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Class to handle thermal boundary conditions application\n */\nexport class ThermalBoundaryConditions {\n  /**\n   * Constructor to initialize the ThermalBoundaryConditions class\n   * @param {object} boundaryConditions - Object containing boundary conditions for the finite element analysis\n   * @param {array} boundaryElements - Array containing elements that belong to each boundary\n   * @param {array} nop - Nodal numbering (NOP) array representing the connectivity between elements and nodes\n   * @param {string} meshDimension - The dimension of the mesh (e.g., \"2D\")\n   * @param {string} elementOrder - The order of elements (e.g., \"linear\", \"quadratic\")\n   */\n  constructor(boundaryConditions, boundaryElements, nop, meshDimension, elementOrder) {\n    this.boundaryConditions = boundaryConditions;\n    this.boundaryElements = boundaryElements;\n    this.nop = nop;\n    this.meshDimension = meshDimension;\n    this.elementOrder = elementOrder;\n  }\n\n  /**\n   * Function to impose constant temperature boundary conditions (Dirichlet type)\n   * @param {array} residualVector - The residual vector to be modified\n   * @param {array} jacobianMatrix - The Jacobian matrix to be modified\n   */\n  imposeConstantTempBoundaryConditions(residualVector, jacobianMatrix) {\n    basicLog(\"Applying constant temperature boundary conditions\");\n    if (this.meshDimension === \"1D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        if (this.boundaryConditions[boundaryKey][0] === \"constantTemp\") {\n          const tempValue = this.boundaryConditions[boundaryKey][1];\n          debugLog(\n            `Boundary ${boundaryKey}: Applying constant temperature of ${tempValue} K (Dirichlet condition)`\n          );\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            if (this.elementOrder === \"linear\") {\n              const boundarySides = {\n                0: [0], // Node at the left side of the reference element\n                1: [1], // Node at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant temperature to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                // Set the residual vector to the ConstantTemp value\n                residualVector[globalNodeIndex] = tempValue;\n                // Set the Jacobian matrix row to zero\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\n                }\n                // Set the diagonal entry of the Jacobian matrix to one\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\n              });\n            } else if (this.elementOrder === \"quadratic\") {\n              const boundarySides = {\n                0: [0], // Node at the left side of the reference element\n                2: [2], // Node at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant temperature to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                // Set the residual vector to the ConstantTemp value\n                residualVector[globalNodeIndex] = tempValue;\n                // Set the Jacobian matrix row to zero\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\n                }\n                // Set the diagonal entry of the Jacobian matrix to one\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\n              });\n            }\n          });\n        }\n      });\n    } else if (this.meshDimension === \"2D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        if (this.boundaryConditions[boundaryKey][0] === \"constantTemp\") {\n          const tempValue = this.boundaryConditions[boundaryKey][1];\n          debugLog(\n            `Boundary ${boundaryKey}: Applying constant temperature of ${tempValue} K (Dirichlet condition)`\n          );\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            if (this.elementOrder === \"linear\") {\n              const boundarySides = {\n                0: [0, 2], // Nodes at the bottom side of the reference element\n                1: [0, 1], // Nodes at the left side of the reference element\n                2: [1, 3], // Nodes at the top side of the reference element\n                3: [2, 3], // Nodes at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant temperature to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                // Set the residual vector to the ConstantTemp value\n                residualVector[globalNodeIndex] = tempValue;\n                // Set the Jacobian matrix row to zero\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\n                }\n                // Set the diagonal entry of the Jacobian matrix to one\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\n              });\n            } else if (this.elementOrder === \"quadratic\") {\n              const boundarySides = {\n                0: [0, 3, 6], // Nodes at the bottom side of the reference element\n                1: [0, 1, 2], // Nodes at the left side of the reference element\n                2: [2, 5, 8], // Nodes at the top side of the reference element\n                3: [6, 7, 8], // Nodes at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant temperature to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                // Set the residual vector to the ConstantTemp value\n                residualVector[globalNodeIndex] = tempValue;\n                // Set the Jacobian matrix row to zero\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\n                }\n                // Set the diagonal entry of the Jacobian matrix to one\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\n              });\n            }\n          });\n        }\n      });\n    }\n  }\n\n  /**\n   * Function to impose convection boundary conditions (Robin type)\n   * @param {array} residualVector - The residual vector to be modified\n   * @param {array} jacobianMatrix - The Jacobian matrix to be modified\n   * @param {array} gaussPoints - Array of Gauss points for numerical integration\n   * @param {array} gaussWeights - Array of Gauss weights for numerical integration\n   * @param {array} nodesXCoordinates - Array of x-coordinates of nodes\n   * @param {array} nodesYCoordinates - Array of y-coordinates of nodes\n   * @param {object} basisFunctions - Object containing basis functions and their derivatives\n   */\n  imposeConvectionBoundaryConditions(\n    residualVector,\n    jacobianMatrix,\n    gaussPoints,\n    gaussWeights,\n    nodesXCoordinates,\n    nodesYCoordinates,\n    basisFunctions\n  ) {\n    basicLog(\"Applying convection boundary conditions\");\n    // Extract convection parameters from boundary conditions\n    let convectionHeatTranfCoeff = [];\n    let convectionExtTemp = [];\n    Object.keys(this.boundaryConditions).forEach((key) => {\n      const boundaryCondition = this.boundaryConditions[key];\n      if (boundaryCondition[0] === \"convection\") {\n        convectionHeatTranfCoeff[key] = boundaryCondition[1];\n        convectionExtTemp[key] = boundaryCondition[2];\n      }\n    });\n\n    if (this.meshDimension === \"1D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        if (this.boundaryConditions[boundaryKey][0] === \"convection\") {\n          const convectionCoeff = convectionHeatTranfCoeff[boundaryKey];\n          const extTemp = convectionExtTemp[boundaryKey];\n          debugLog(\n            `Boundary ${boundaryKey}: Applying convection with heat transfer coefficient h=${convectionCoeff} W/(mÂ²Â·K) and external temperature Tâˆž=${extTemp} K`\n          );\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            let nodeIndex;\n            if (this.elementOrder === \"linear\") {\n              if (side === 0) {\n                // Node at the left side of the reference element\n                nodeIndex = 0;\n              } else {\n                // Node at the right side of the reference element\n                nodeIndex = 1;\n              }\n            } else if (this.elementOrder === \"quadratic\") {\n              if (side === 0) {\n                // Node at the left side of the reference element\n                nodeIndex = 0;\n              } else {\n                // Node at the right side of the reference element\n                nodeIndex = 2;\n              }\n            }\n\n            const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n            debugLog(\n              `  - Applied convection boundary condition to node ${globalNodeIndex + 1} (element ${\n                elementIndex + 1\n              }, local node ${nodeIndex + 1})`\n            );\n            residualVector[globalNodeIndex] += -convectionCoeff * extTemp;\n            jacobianMatrix[globalNodeIndex][globalNodeIndex] += convectionCoeff;\n          });\n        }\n      });\n    } else if (this.meshDimension === \"2D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        if (this.boundaryConditions[boundaryKey][0] === \"convection\") {\n          const convectionCoeff = convectionHeatTranfCoeff[boundaryKey];\n          const extTemp = convectionExtTemp[boundaryKey];\n          debugLog(\n            `Boundary ${boundaryKey}: Applying convection with heat transfer coefficient h=${convectionCoeff} W/(mÂ²Â·K) and external temperature Tâˆž=${extTemp} K`\n          );\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            if (this.elementOrder === \"linear\") {\n              let gaussPoint1, gaussPoint2, firstNodeIndex, lastNodeIndex, nodeIncrement;\n              if (side === 0) {\n                // Nodes at the bottom side of the reference element\n                gaussPoint1 = gaussPoints[0];\n                gaussPoint2 = 0;\n                firstNodeIndex = 0;\n                lastNodeIndex = 3;\n                nodeIncrement = 2;\n              } else if (side === 1) {\n                // Nodes at the left side of the reference element\n                gaussPoint1 = 0;\n                gaussPoint2 = gaussPoints[0];\n                firstNodeIndex = 0;\n                lastNodeIndex = 2;\n                nodeIncrement = 1;\n              } else if (side === 2) {\n                // Nodes at the top side of the reference element\n                gaussPoint1 = gaussPoints[0];\n                gaussPoint2 = 1;\n                firstNodeIndex = 1;\n                lastNodeIndex = 4;\n                nodeIncrement = 2;\n              } else if (side === 3) {\n                // Nodes at the right side of the reference element\n                gaussPoint1 = 1;\n                gaussPoint2 = gaussPoints[0];\n                firstNodeIndex = 2;\n                lastNodeIndex = 4;\n                nodeIncrement = 1;\n              }\n\n              let basisFunctionsAndDerivatives = basisFunctions.getBasisFunctions(gaussPoint1, gaussPoint2);\n              let basisFunction = basisFunctionsAndDerivatives.basisFunction;\n              let basisFunctionDerivKsi = basisFunctionsAndDerivatives.basisFunctionDerivKsi;\n              let basisFunctionDerivEta = basisFunctionsAndDerivatives.basisFunctionDerivEta;\n\n              let ksiDerivX = 0;\n              let ksiDerivY = 0;\n              let etaDerivX = 0;\n              let etaDerivY = 0;\n              const numNodes = this.nop[elementIndex].length;\n              for (let nodeIndex = 0; nodeIndex < numNodes; nodeIndex++) {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n\n                // For boundaries along Ksi (horizontal), use Ksi derivatives\n                if (side === 0 || side === 2) {\n                  ksiDerivX += nodesXCoordinates[globalNodeIndex] * basisFunctionDerivKsi[nodeIndex];\n                  ksiDerivY += nodesYCoordinates[globalNodeIndex] * basisFunctionDerivKsi[nodeIndex];\n                }\n                // For boundaries along Eta (vertical), use Eta derivatives\n                else if (side === 1 || side === 3) {\n                  etaDerivX += nodesXCoordinates[globalNodeIndex] * basisFunctionDerivEta[nodeIndex];\n                  etaDerivY += nodesYCoordinates[globalNodeIndex] * basisFunctionDerivEta[nodeIndex];\n                }\n              }\n\n              // Compute the length of tangent vector\n              let tangentVectorLength;\n              if (side === 0 || side === 2) {\n                tangentVectorLength = Math.sqrt(ksiDerivX ** 2 + ksiDerivY ** 2);\n              } else {\n                tangentVectorLength = Math.sqrt(etaDerivX ** 2 + etaDerivY ** 2);\n              }\n\n              for (\n                let localNodeIndex = firstNodeIndex;\n                localNodeIndex < lastNodeIndex;\n                localNodeIndex += nodeIncrement\n              ) {\n                let globalNodeIndex = this.nop[elementIndex][localNodeIndex] - 1;\n                debugLog(\n                  `  - Applied convection boundary condition to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${localNodeIndex + 1})`\n                );\n\n                // Apply boundary condition with proper Jacobian for all sides\n                residualVector[globalNodeIndex] +=\n                  -gaussWeights[0] *\n                  tangentVectorLength *\n                  basisFunction[localNodeIndex] *\n                  convectionCoeff *\n                  extTemp;\n\n                for (\n                  let localNodeIndex2 = firstNodeIndex;\n                  localNodeIndex2 < lastNodeIndex;\n                  localNodeIndex2 += nodeIncrement\n                ) {\n                  let globalNodeIndex2 = this.nop[elementIndex][localNodeIndex2] - 1;\n                  jacobianMatrix[globalNodeIndex][globalNodeIndex2] +=\n                    -gaussWeights[0] *\n                    tangentVectorLength *\n                    basisFunction[localNodeIndex] *\n                    basisFunction[localNodeIndex2] *\n                    convectionCoeff;\n                }\n              }\n            } else if (this.elementOrder === \"quadratic\") {\n              for (let gaussPointIndex = 0; gaussPointIndex < 3; gaussPointIndex++) {\n                let gaussPoint1, gaussPoint2, firstNodeIndex, lastNodeIndex, nodeIncrement;\n                if (side === 0) {\n                  // Nodes at the bottom side of the reference element\n                  gaussPoint1 = gaussPoints[gaussPointIndex];\n                  gaussPoint2 = 0;\n                  firstNodeIndex = 0;\n                  lastNodeIndex = 7;\n                  nodeIncrement = 3;\n                } else if (side === 1) {\n                  // Nodes at the left side of the reference element\n                  gaussPoint1 = 0;\n                  gaussPoint2 = gaussPoints[gaussPointIndex];\n                  firstNodeIndex = 0;\n                  lastNodeIndex = 3;\n                  nodeIncrement = 1;\n                } else if (side === 2) {\n                  // Nodes at the top side of the reference element\n                  gaussPoint1 = gaussPoints[gaussPointIndex];\n                  gaussPoint2 = 1;\n                  firstNodeIndex = 2;\n                  lastNodeIndex = 9;\n                  nodeIncrement = 3;\n                } else if (side === 3) {\n                  // Nodes at the right side of the reference element\n                  gaussPoint1 = 1;\n                  gaussPoint2 = gaussPoints[gaussPointIndex];\n                  firstNodeIndex = 6;\n                  lastNodeIndex = 9;\n                  nodeIncrement = 1;\n                }\n                let basisFunctionsAndDerivatives = basisFunctions.getBasisFunctions(gaussPoint1, gaussPoint2);\n                let basisFunction = basisFunctionsAndDerivatives.basisFunction;\n                let basisFunctionDerivKsi = basisFunctionsAndDerivatives.basisFunctionDerivKsi;\n                let basisFunctionDerivEta = basisFunctionsAndDerivatives.basisFunctionDerivEta;\n\n                let ksiDerivX = 0;\n                let ksiDerivY = 0;\n                let etaDerivX = 0;\n                let etaDerivY = 0;\n                const numNodes = this.nop[elementIndex].length;\n                for (let nodeIndex = 0; nodeIndex < numNodes; nodeIndex++) {\n                  const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n\n                  // For boundaries along Ksi (horizontal), use Ksi derivatives\n                  if (side === 0 || side === 2) {\n                    ksiDerivX += nodesXCoordinates[globalNodeIndex] * basisFunctionDerivKsi[nodeIndex];\n                    ksiDerivY += nodesYCoordinates[globalNodeIndex] * basisFunctionDerivKsi[nodeIndex];\n                  }\n                  // For boundaries along Eta (vertical), use Eta derivatives\n                  else if (side === 1 || side === 3) {\n                    etaDerivX += nodesXCoordinates[globalNodeIndex] * basisFunctionDerivEta[nodeIndex];\n                    etaDerivY += nodesYCoordinates[globalNodeIndex] * basisFunctionDerivEta[nodeIndex];\n                  }\n                }\n\n                // Compute the length of tangent vector\n                let tangentVectorLength;\n                if (side === 0 || side === 2) {\n                  tangentVectorLength = Math.sqrt(ksiDerivX ** 2 + ksiDerivY ** 2);\n                } else {\n                  tangentVectorLength = Math.sqrt(etaDerivX ** 2 + etaDerivY ** 2);\n                }\n\n                for (\n                  let localNodeIndex = firstNodeIndex;\n                  localNodeIndex < lastNodeIndex;\n                  localNodeIndex += nodeIncrement\n                ) {\n                  let globalNodeIndex = this.nop[elementIndex][localNodeIndex] - 1;\n                  debugLog(\n                    `  - Applied convection boundary condition to node ${globalNodeIndex + 1} (element ${\n                      elementIndex + 1\n                    }, local node ${localNodeIndex + 1})`\n                  );\n\n                  // Apply boundary condition with proper Jacobian for all sides\n                  residualVector[globalNodeIndex] +=\n                    -gaussWeights[gaussPointIndex] *\n                    tangentVectorLength *\n                    basisFunction[localNodeIndex] *\n                    convectionCoeff *\n                    extTemp;\n\n                  for (\n                    let localNodeIndex2 = firstNodeIndex;\n                    localNodeIndex2 < lastNodeIndex;\n                    localNodeIndex2 += nodeIncrement\n                  ) {\n                    let globalNodeIndex2 = this.nop[elementIndex][localNodeIndex2] - 1;\n                    jacobianMatrix[globalNodeIndex][globalNodeIndex2] +=\n                      -gaussWeights[gaussPointIndex] *\n                      tangentVectorLength *\n                      basisFunction[localNodeIndex] *\n                      basisFunction[localNodeIndex2] *\n                      convectionCoeff;\n                  }\n                }\n              }\n            }\n          });\n        }\n      });\n    }\n  }\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n// Internal imports\nimport { BasisFunctions } from \"../mesh/basisFunctionsScript.js\";\nimport { assembleSolidHeatTransferFront } from \"../solvers/solidHeatTransferScript.js\";\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n// Add an exported wrapper to obtain results for plotting\nexport function runFrontalSolver(meshConfig, boundaryConditions) {\n  main(meshConfig, boundaryConditions);\n  return {\n    solutionVector: block1.u.slice(0, block1.np),\n    nodesCoordinates: {\n      nodesXCoordinates: block1.xpt.slice(0, block1.np),\n      nodesYCoordinates: block1.ypt.slice(0, block1.np),\n    },\n  };\n}\n\n// Constants\nconst nemax = 1600;\nconst nnmax = 6724;\nconst nmax = 2000;\n\n// Common block equivalents as objects\nconst block1 = {\n  nex: 0,\n  ney: 0,\n  nnx: 0,\n  nny: 0,\n  ne: 0,\n  np: 0,\n  xorigin: 0,\n  yorigin: 0,\n  xlast: 0,\n  ylast: 0,\n  deltax: 0,\n  deltay: 0,\n  nop: Array(nemax)\n    .fill()\n    .map(() => Array(9).fill(0)),\n  xpt: Array(nnmax).fill(0),\n  ypt: Array(nnmax).fill(0),\n  ncod: Array(nnmax).fill(0),\n  bc: Array(nnmax).fill(0),\n  r1: Array(nnmax).fill(0),\n  u: Array(nnmax).fill(0),\n  ntop: Array(nemax).fill(0),\n  nlat: Array(nemax).fill(0),\n};\n\nconst gauss = {\n  w: [0.27777777777778, 0.444444444444, 0.27777777777778],\n  gp: [0.1127016654, 0.5, 0.8872983346],\n};\n\nconst fro1 = {\n  iwr1: 0,\n  npt: 0,\n  ntra: 0,\n  nbn: Array(nemax).fill(0),\n  det: 1,\n  sk: Array(nmax * nmax).fill(0),\n  ice1: 0,\n};\n\nconst fabf1 = {\n  estifm: Array(9)\n    .fill()\n    .map(() => Array(9).fill(0)),\n  nell: 0,\n};\n\nconst fb1 = {\n  ecv: Array(2000000).fill(0),\n  lhed: Array(nmax).fill(0),\n  qq: Array(nmax).fill(0),\n  ecpiv: Array(2000000).fill(0),\n};\n\n// Instantiate shared basis functions handler (biquadratic 2D)\nconst basisFunctionsLib = new BasisFunctions({ meshDimension: \"2D\", elementOrder: \"quadratic\" });\n\n// Main program logic\nfunction main(meshConfig, boundaryConditions) {\n  // console.log(\"2-D problem. Biquadratic basis functions\\n\");\n\n  xydiscr(meshConfig);\n  nodnumb();\n  xycoord();\n  // console.log(`nex=${block1.nex}  ney=${block1.ney}  ne=${block1.ne}  np=${block1.np}\\n`);\n\n  // Initialize all nodes with no boundary condition\n  for (let i = 0; i < block1.np; i++) {\n    block1.ncod[i] = 0;\n    block1.bc[i] = 0;\n  }\n\n  // Apply boundary conditions based on the boundaryConditions parameter\n  Object.keys(boundaryConditions).forEach((boundaryKey) => {\n    const condition = boundaryConditions[boundaryKey];\n\n    // Handle constantTemp (Dirichlet) boundary conditions\n    if (condition[0] === \"constantTemp\") {\n      const tempValue = boundaryConditions[boundaryKey][1];\n\n      // Apply boundary condition to the appropriate nodes based on boundary key\n      switch (boundaryKey) {\n        case \"0\": // Bottom boundary (y = yorigin)\n          for (let col = 0; col < block1.nnx; col++) {\n            const nodeIndex = col * block1.nny;\n            block1.ncod[nodeIndex] = 1;\n            block1.bc[nodeIndex] = tempValue;\n          }\n          break;\n\n        case \"1\": // Right boundary (x = xlast)\n          for (let j = 0; j < block1.nny; j++) {\n            block1.ncod[j] = 1;\n            block1.bc[j] = tempValue;\n          }\n          break;\n\n        case \"2\": // Top boundary (y = ylast)\n          for (let col = 0; col < block1.nnx; col++) {\n            const nodeIndex = col * block1.nny + (block1.nny - 1);\n            block1.ncod[nodeIndex] = 1;\n            block1.bc[nodeIndex] = tempValue;\n          }\n          break;\n\n        case \"3\": // Left boundary (x = xorigin)\n          for (let j = 0; j < block1.nny; j++) {\n            const nodeIndex = (block1.nnx - 1) * block1.nny + j;\n            block1.ncod[nodeIndex] = 1;\n            block1.bc[nodeIndex] = tempValue;\n          }\n          break;\n      }\n    }\n    // Other boundary condition types can be handled later if needed\n  });\n\n  // Prepare natural boundary conditions\n  for (let i = 0; i < block1.ne; i++) {\n    block1.ntop[i] = 0;\n    block1.nlat[i] = 0;\n  }\n\n  // for (let i = block1.ney - 1; i < block1.ne; i += block1.ney) {\n  //   block1.ntop[i] = 1;\n  // }\n\n  // for (let i = block1.ne - block1.ney; i < block1.ne; i++) {\n  //   block1.nlat[i] = 1;\n  // }\n\n  // Initialization\n  for (let i = 0; i < block1.np; i++) {\n    block1.r1[i] = 0;\n  }\n\n  fro1.npt = block1.np;\n  fro1.iwr1 = 0;\n  fro1.ntra = 1;\n  fro1.det = 1;\n\n  for (let i = 0; i < block1.ne; i++) {\n    fro1.nbn[i] = 9;\n  }\n\n  front();\n\n  // Copy solution\n  for (let i = 0; i < block1.np; i++) {\n    block1.u[i] = fro1.sk[i];\n  }\n\n  // Output results to console\n  for (let i = 0; i < block1.np; i++) {\n    debugLog(\n      `${block1.xpt[i].toExponential(5)}  ${block1.ypt[i].toExponential(5)}  ${block1.u[i].toExponential(5)}`\n    );\n  }\n}\n\n// Discretization\nfunction xydiscr(meshConfig) {\n  // Extract values from meshConfig\n  const { meshDimension, numElementsX, numElementsY, maxX, maxY, elementOrder, parsedMesh } = meshConfig;\n\n  block1.nex = numElementsX;\n  block1.ney = numElementsY;\n  block1.xorigin = 0;\n  block1.yorigin = 0;\n  block1.xlast = maxX;\n  block1.ylast = maxY;\n  block1.deltax = (block1.xlast - block1.xorigin) / block1.nex;\n  block1.deltay = (block1.ylast - block1.yorigin) / block1.ney;\n}\n\n// Nodal numbering\nfunction nodnumb() {\n  block1.ne = block1.nex * block1.ney;\n  block1.nnx = 2 * block1.nex + 1;\n  block1.nny = 2 * block1.ney + 1;\n  block1.np = block1.nnx * block1.nny;\n\n  let nel = 0;\n  for (let i = 1; i <= block1.nex; i++) {\n    for (let j = 1; j <= block1.ney; j++) {\n      nel++;\n      for (let k = 1; k <= 3; k++) {\n        let l = 3 * k - 2;\n        block1.nop[nel - 1][l - 1] = block1.nny * (2 * i + k - 3) + 2 * j - 1;\n        block1.nop[nel - 1][l] = block1.nop[nel - 1][l - 1] + 1;\n        block1.nop[nel - 1][l + 1] = block1.nop[nel - 1][l - 1] + 2;\n      }\n    }\n  }\n}\n\n// Coordinate setup\nfunction xycoord() {\n  block1.xpt[0] = block1.xorigin;\n  block1.ypt[0] = block1.yorigin;\n\n  for (let i = 1; i <= block1.nnx; i++) {\n    let nnode = (i - 1) * block1.nny;\n    block1.xpt[nnode] = block1.xpt[0] + ((i - 1) * block1.deltax) / 2;\n    block1.ypt[nnode] = block1.ypt[0];\n\n    for (let j = 2; j <= block1.nny; j++) {\n      block1.xpt[nnode + j - 1] = block1.xpt[nnode];\n      block1.ypt[nnode + j - 1] = block1.ypt[nnode] + ((j - 1) * block1.deltay) / 2;\n    }\n  }\n}\n\n// Element stiffness matrix and residuals (delegated to external assembly function)\nfunction abfind() {\n  const elementIndex = fabf1.nell - 1;\n\n  const { estifm, localLoad, ngl } = assembleSolidHeatTransferFront({\n    elementIndex,\n    nop: block1.nop,\n    xCoordinates: block1.xpt,\n    yCoordinates: block1.ypt,\n    basisFunctions: basisFunctionsLib,\n    gaussPoints: gauss.gp,\n    gaussWeights: gauss.w,\n    ntopFlag: block1.ntop[elementIndex] === 1,\n    nlatFlag: block1.nlat[elementIndex] === 1,\n  });\n\n  // Copy element matrix\n  for (let i = 0; i < 9; i++) {\n    for (let j = 0; j < 9; j++) {\n      fabf1.estifm[i][j] = estifm[i][j];\n    }\n  }\n\n  // Accumulate local load into global RHS\n  for (let a = 0; a < 9; a++) {\n    const g = ngl[a] - 1;\n    block1.r1[g] += localLoad[a];\n  }\n}\n\n// Frontal solver\nfunction front() {\n  let ldest = Array(9).fill(0);\n  let kdest = Array(9).fill(0);\n  let khed = Array(nmax).fill(0);\n  let kpiv = Array(nmax).fill(0);\n  let lpiv = Array(nmax).fill(0);\n  let jmod = Array(nmax).fill(0);\n  let pvkol = Array(nmax).fill(0);\n  let eq = Array(nmax)\n    .fill()\n    .map(() => Array(nmax).fill(0));\n  let nrs = Array(nnmax).fill(0);\n  let ncs = Array(nnmax).fill(0);\n  let check = Array(nnmax).fill(0);\n  let lco; // Declare lco once at function scope\n\n  let ice = 1;\n  fro1.iwr1++;\n  let ipiv = 1;\n  let nsum = 1;\n  fabf1.nell = 0;\n\n  for (let i = 0; i < fro1.npt; i++) {\n    nrs[i] = 0;\n    ncs[i] = 0;\n  }\n\n  if (fro1.ntra !== 0) {\n    // Prefront: find last appearance of each node\n    for (let i = 0; i < fro1.npt; i++) {\n      check[i] = 0;\n    }\n\n    for (let i = 0; i < block1.ne; i++) {\n      let nep = block1.ne - i - 1;\n      for (let j = 0; j < fro1.nbn[nep]; j++) {\n        let k = block1.nop[nep][j];\n        if (check[k - 1] === 0) {\n          check[k - 1] = 1;\n          block1.nop[nep][j] = -block1.nop[nep][j];\n        }\n      }\n    }\n  }\n\n  fro1.ntra = 0;\n  let lcol = 0;\n  let krow = 0;\n\n  for (let i = 0; i < nmax; i++) {\n    for (let j = 0; j < nmax; j++) {\n      eq[j][i] = 0;\n    }\n  }\n\n  while (true) {\n    fabf1.nell++;\n    abfind();\n\n    let n = fabf1.nell;\n    let nend = fro1.nbn[n - 1];\n    let lend = fro1.nbn[n - 1];\n\n    for (let lk = 0; lk < lend; lk++) {\n      let nodk = block1.nop[n - 1][lk];\n      let ll;\n\n      if (lcol === 0) {\n        lcol++;\n        ldest[lk] = lcol;\n        fb1.lhed[lcol - 1] = nodk;\n      } else {\n        for (ll = 0; ll < lcol; ll++) {\n          if (Math.abs(nodk) === Math.abs(fb1.lhed[ll])) break;\n        }\n\n        if (ll === lcol) {\n          lcol++;\n          ldest[lk] = lcol;\n          fb1.lhed[lcol - 1] = nodk;\n        } else {\n          ldest[lk] = ll + 1;\n          fb1.lhed[ll] = nodk;\n        }\n      }\n\n      let kk;\n      if (krow === 0) {\n        krow++;\n        kdest[lk] = krow;\n        khed[krow - 1] = nodk;\n      } else {\n        for (kk = 0; kk < krow; kk++) {\n          if (Math.abs(nodk) === Math.abs(khed[kk])) break;\n        }\n\n        if (kk === krow) {\n          krow++;\n          kdest[lk] = krow;\n          khed[krow - 1] = nodk;\n        } else {\n          kdest[lk] = kk + 1;\n          khed[kk] = nodk;\n        }\n      }\n    }\n\n    if (krow > nmax || lcol > nmax) {\n      errorLog(\"Error: nmax-nsum not large enough\");\n      return;\n    }\n\n    for (let l = 0; l < lend; l++) {\n      let ll = ldest[l];\n      for (let k = 0; k < nend; k++) {\n        let kk = kdest[k];\n        eq[kk - 1][ll - 1] += fabf1.estifm[k][l];\n      }\n    }\n\n    let lc = 0;\n    for (let l = 0; l < lcol; l++) {\n      if (fb1.lhed[l] < 0) {\n        lpiv[lc] = l + 1;\n        lc++;\n      }\n    }\n\n    let ir = 0;\n    let kr = 0;\n    for (let k = 0; k < krow; k++) {\n      let kt = khed[k];\n      if (kt < 0) {\n        kpiv[kr] = k + 1;\n        kr++;\n        let kro = Math.abs(kt);\n        if (block1.ncod[kro - 1] === 1) {\n          jmod[ir] = k + 1;\n          ir++;\n          block1.ncod[kro - 1] = 2;\n          block1.r1[kro - 1] = block1.bc[kro - 1];\n        }\n      }\n    }\n\n    if (ir > 0) {\n      for (let irr = 0; irr < ir; irr++) {\n        let k = jmod[irr] - 1;\n        let kh = Math.abs(khed[k]);\n        for (let l = 0; l < lcol; l++) {\n          eq[k][l] = 0;\n          let lh = Math.abs(fb1.lhed[l]);\n          if (lh === kh) eq[k][l] = 1;\n        }\n      }\n    }\n\n    if (lc > nsum || fabf1.nell < block1.ne) {\n      if (lc === 0) {\n        errorLog(\"Error: no more rows fully summed\");\n        return;\n      }\n\n      let kpivro = kpiv[0];\n      let lpivco = lpiv[0];\n      let pivot = eq[kpivro - 1][lpivco - 1];\n\n      if (Math.abs(pivot) < 1e-4) {\n        pivot = 0;\n        for (let l = 0; l < lc; l++) {\n          let lpivc = lpiv[l];\n          for (let k = 0; k < kr; k++) {\n            let kpivr = kpiv[k];\n            let piva = eq[kpivr - 1][lpivc - 1];\n            if (Math.abs(piva) > Math.abs(pivot)) {\n              pivot = piva;\n              lpivco = lpivc;\n              kpivro = kpivr;\n            }\n          }\n        }\n      }\n\n      let kro = Math.abs(khed[kpivro - 1]);\n      lco = Math.abs(fb1.lhed[lpivco - 1]); // Assign, don't declare\n      let nhlp = kro + lco + nrs[kro - 1] + ncs[lco - 1];\n      fro1.det = (fro1.det * pivot * (-1) ** nhlp) / Math.abs(pivot);\n\n      for (let iperm = 0; iperm < fro1.npt; iperm++) {\n        if (iperm >= kro) nrs[iperm]--;\n        if (iperm >= lco) ncs[iperm]--;\n      }\n\n      if (Math.abs(pivot) < 1e-10) {\n        errorLog(\n          `Warning: matrix singular or ill-conditioned, nell=${fabf1.nell}, kro=${kro}, lco=${lco}, pivot=${pivot}`\n        );\n      }\n\n      if (pivot === 0) return;\n\n      for (let l = 0; l < lcol; l++) {\n        fb1.qq[l] = eq[kpivro - 1][l] / pivot;\n      }\n\n      let rhs = block1.r1[kro - 1] / pivot;\n      block1.r1[kro - 1] = rhs;\n      pvkol[kpivro - 1] = pivot;\n\n      if (kpivro > 1) {\n        for (let k = 0; k < kpivro - 1; k++) {\n          let krw = Math.abs(khed[k]);\n          let fac = eq[k][lpivco - 1];\n          pvkol[k] = fac;\n          if (lpivco > 1 && fac !== 0) {\n            for (let l = 0; l < lpivco - 1; l++) {\n              eq[k][l] -= fac * fb1.qq[l];\n            }\n          }\n          if (lpivco < lcol) {\n            for (let l = lpivco; l < lcol; l++) {\n              eq[k][l - 1] = eq[k][l] - fac * fb1.qq[l];\n            }\n          }\n          block1.r1[krw - 1] -= fac * rhs;\n        }\n      }\n\n      if (kpivro < krow) {\n        for (let k = kpivro; k < krow; k++) {\n          let krw = Math.abs(khed[k]);\n          let fac = eq[k][lpivco - 1];\n          pvkol[k] = fac;\n          if (lpivco > 1) {\n            for (let l = 0; l < lpivco - 1; l++) {\n              eq[k - 1][l] = eq[k][l] - fac * fb1.qq[l];\n            }\n          }\n          if (lpivco < lcol) {\n            for (let l = lpivco; l < lcol; l++) {\n              eq[k - 1][l - 1] = eq[k][l] - fac * fb1.qq[l];\n            }\n          }\n          block1.r1[krw - 1] -= fac * rhs;\n        }\n      }\n\n      for (let i = 0; i < krow; i++) {\n        fb1.ecpiv[ipiv + i - 1] = pvkol[i];\n      }\n      ipiv += krow;\n\n      for (let i = 0; i < krow; i++) {\n        fb1.ecpiv[ipiv + i - 1] = khed[i];\n      }\n      ipiv += krow;\n\n      fb1.ecpiv[ipiv - 1] = kpivro;\n      ipiv++;\n\n      for (let i = 0; i < lcol; i++) {\n        fb1.ecv[ice - 1 + i] = fb1.qq[i];\n      }\n      ice += lcol;\n\n      for (let i = 0; i < lcol; i++) {\n        fb1.ecv[ice - 1 + i] = fb1.lhed[i];\n      }\n      ice += lcol;\n\n      fb1.ecv[ice - 1] = kro;\n      fb1.ecv[ice] = lcol;\n      fb1.ecv[ice + 1] = lpivco;\n      fb1.ecv[ice + 2] = pivot;\n      ice += 4;\n\n      for (let k = 0; k < krow; k++) {\n        eq[k][lcol - 1] = 0;\n      }\n\n      for (let l = 0; l < lcol; l++) {\n        eq[krow - 1][l] = 0;\n      }\n\n      lcol--;\n      if (lpivco < lcol + 1) {\n        for (let l = lpivco - 1; l < lcol; l++) {\n          fb1.lhed[l] = fb1.lhed[l + 1];\n        }\n      }\n\n      krow--;\n      if (kpivro < krow + 1) {\n        for (let k = kpivro - 1; k < krow; k++) {\n          khed[k] = khed[k + 1];\n        }\n      }\n\n      if (krow > 1 || fabf1.nell < block1.ne) continue;\n\n      lco = Math.abs(fb1.lhed[0]); // Assign, don't declare\n      kpivro = 1;\n      pivot = eq[0][0];\n      kro = Math.abs(khed[0]);\n      lpivco = 1;\n      nhlp = kro + lco + nrs[kro - 1] + ncs[lco - 1];\n      fro1.det = (fro1.det * pivot * (-1) ** nhlp) / Math.abs(pivot);\n\n      fb1.qq[0] = 1;\n      if (Math.abs(pivot) < 1e-10) {\n        errorLog(\n          `Warning: matrix singular or ill-conditioned, nell=${fabf1.nell}, kro=${kro}, lco=${lco}, pivot=${pivot}`\n        );\n      }\n\n      if (pivot === 0) return;\n\n      block1.r1[kro - 1] = block1.r1[kro - 1] / pivot;\n      fb1.ecv[ice - 1] = fb1.qq[0];\n      ice++;\n      fb1.ecv[ice - 1] = fb1.lhed[0];\n      ice++;\n      fb1.ecv[ice - 1] = kro;\n      fb1.ecv[ice] = lcol;\n      fb1.ecv[ice + 1] = lpivco;\n      fb1.ecv[ice + 2] = pivot;\n      ice += 4;\n\n      fb1.ecpiv[ipiv - 1] = pvkol[0];\n      ipiv++;\n      fb1.ecpiv[ipiv - 1] = khed[0];\n      ipiv++;\n      fb1.ecpiv[ipiv - 1] = kpivro;\n      ipiv++;\n\n      fro1.ice1 = ice;\n      if (fro1.iwr1 === 1) debugLog(`total ecs transfer in matrix reduction=${ice}`);\n\n      bacsub(ice);\n      break;\n    }\n  }\n}\n\n// Back substitution\nfunction bacsub(ice) {\n  for (let i = 0; i < fro1.npt; i++) {\n    fro1.sk[i] = block1.bc[i];\n  }\n\n  for (let iv = 1; iv <= fro1.npt; iv++) {\n    ice -= 4;\n    let kro = fb1.ecv[ice - 1];\n    let lcol = fb1.ecv[ice];\n    let lpivco = fb1.ecv[ice + 1];\n    let pivot = fb1.ecv[ice + 2];\n\n    if (iv === 1) {\n      ice--;\n      fb1.lhed[0] = fb1.ecv[ice - 1];\n      ice--;\n      fb1.qq[0] = fb1.ecv[ice - 1];\n    } else {\n      ice -= lcol;\n      for (let iii = 0; iii < lcol; iii++) {\n        fb1.lhed[iii] = fb1.ecv[ice - 1 + iii];\n      }\n      ice -= lcol;\n      for (let iii = 0; iii < lcol; iii++) {\n        fb1.qq[iii] = fb1.ecv[ice - 1 + iii];\n      }\n    }\n\n    let lco = Math.abs(fb1.lhed[lpivco - 1]);\n    if (block1.ncod[lco - 1] > 0) continue;\n\n    let gash = 0;\n    fb1.qq[lpivco - 1] = 0;\n    for (let l = 0; l < lcol; l++) {\n      gash -= fb1.qq[l] * fro1.sk[Math.abs(fb1.lhed[l]) - 1];\n    }\n\n    fro1.sk[lco - 1] = gash + block1.r1[kro - 1];\n\n    block1.ncod[lco - 1] = 1;\n  }\n\n  if (fro1.iwr1 === 1) debugLog(`value of ice after backsubstitution=${ice}`);\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n// Internal imports\nimport {\n  initializeFEA,\n  performIsoparametricMapping1D,\n  performIsoparametricMapping2D,\n} from \"../mesh/meshUtilsScript.js\";\nimport { ThermalBoundaryConditions } from \"./thermalBoundaryConditionsScript.js\";\nimport { basicLog, debugLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Function to assemble the Jacobian matrix and residuals vector for the solid heat transfer model\n * @param {object} meshData - Object containing prepared mesh data\n * @param {object} boundaryConditions - Object containing boundary conditions for the finite element analysis\n * @returns {object} An object containing:\n *  - jacobianMatrix: The assembled Jacobian matrix\n *  - residualVector: The assembled residual vector\n */\nexport function assembleSolidHeatTransferMat(meshData, boundaryConditions) {\n  basicLog(\"Starting solid heat transfer matrix assembly...\");\n\n  // Extract mesh data\n  const {\n    nodesXCoordinates,\n    nodesYCoordinates,\n    nop,\n    boundaryElements,\n    totalElements,\n    meshDimension,\n    elementOrder,\n  } = meshData;\n\n  // Initialize FEA components\n  const FEAData = initializeFEA(meshData);\n  const {\n    residualVector,\n    jacobianMatrix,\n    localToGlobalMap,\n    basisFunctions,\n    gaussPoints,\n    gaussWeights,\n    numNodes,\n  } = FEAData;\n\n  // Matrix assembly\n  for (let elementIndex = 0; elementIndex < totalElements; elementIndex++) {\n    // Map local element nodes to global mesh nodes\n    for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n      // Subtract 1 from nop in order to start numbering from 0\n      localToGlobalMap[localNodeIndex] = nop[elementIndex][localNodeIndex] - 1;\n    }\n\n    // Loop over Gauss points\n    for (let gaussPointIndex1 = 0; gaussPointIndex1 < gaussPoints.length; gaussPointIndex1++) {\n      // 1D solid heat transfer\n      if (meshDimension === \"1D\") {\n        // Get basis functions for the current Gauss point\n        let basisFunctionsAndDerivatives = basisFunctions.getBasisFunctions(gaussPoints[gaussPointIndex1]);\n\n        // Perform isoparametric mapping\n        const mappingResult = performIsoparametricMapping1D({\n          basisFunction: basisFunctionsAndDerivatives.basisFunction,\n          basisFunctionDerivKsi: basisFunctionsAndDerivatives.basisFunctionDerivKsi,\n          nodesXCoordinates,\n          localToGlobalMap,\n          numNodes,\n        });\n\n        // Extract mapping results\n        const { detJacobian, basisFunctionDerivX } = mappingResult;\n\n        // Computation of Galerkin's residuals and Jacobian matrix\n        for (let localNodeIndex1 = 0; localNodeIndex1 < numNodes; localNodeIndex1++) {\n          let localToGlobalMap1 = localToGlobalMap[localNodeIndex1];\n          // residualVector is zero for this case\n\n          for (let localNodeIndex2 = 0; localNodeIndex2 < numNodes; localNodeIndex2++) {\n            let localToGlobalMap2 = localToGlobalMap[localNodeIndex2];\n            jacobianMatrix[localToGlobalMap1][localToGlobalMap2] +=\n              -gaussWeights[gaussPointIndex1] *\n              detJacobian *\n              (basisFunctionDerivX[localNodeIndex1] * basisFunctionDerivX[localNodeIndex2]);\n          }\n        }\n      }\n      // 2D solid heat transfer\n      else if (meshDimension === \"2D\") {\n        for (let gaussPointIndex2 = 0; gaussPointIndex2 < gaussPoints.length; gaussPointIndex2++) {\n          // Get basis functions for the current Gauss point\n          let basisFunctionsAndDerivatives = basisFunctions.getBasisFunctions(\n            gaussPoints[gaussPointIndex1],\n            gaussPoints[gaussPointIndex2]\n          );\n\n          // Perform isoparametric mapping\n          const mappingResult = performIsoparametricMapping2D({\n            basisFunction: basisFunctionsAndDerivatives.basisFunction,\n            basisFunctionDerivKsi: basisFunctionsAndDerivatives.basisFunctionDerivKsi,\n            basisFunctionDerivEta: basisFunctionsAndDerivatives.basisFunctionDerivEta,\n            nodesXCoordinates,\n            nodesYCoordinates,\n            localToGlobalMap,\n            numNodes,\n          });\n\n          // Extract mapping results\n          const { detJacobian, basisFunctionDerivX, basisFunctionDerivY } = mappingResult;\n\n          // Computation of Galerkin's residuals and Jacobian matrix\n          for (let localNodeIndex1 = 0; localNodeIndex1 < numNodes; localNodeIndex1++) {\n            let localToGlobalMap1 = localToGlobalMap[localNodeIndex1];\n            // residualVector is zero for this case\n\n            for (let localNodeIndex2 = 0; localNodeIndex2 < numNodes; localNodeIndex2++) {\n              let localToGlobalMap2 = localToGlobalMap[localNodeIndex2];\n              jacobianMatrix[localToGlobalMap1][localToGlobalMap2] +=\n                -gaussWeights[gaussPointIndex1] *\n                gaussWeights[gaussPointIndex2] *\n                detJacobian *\n                (basisFunctionDerivX[localNodeIndex1] * basisFunctionDerivX[localNodeIndex2] +\n                  basisFunctionDerivY[localNodeIndex1] * basisFunctionDerivY[localNodeIndex2]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Apply boundary conditions\n  basicLog(\"Applying thermal boundary conditions...\");\n  const thermalBoundaryConditions = new ThermalBoundaryConditions(\n    boundaryConditions,\n    boundaryElements,\n    nop,\n    meshDimension,\n    elementOrder\n  );\n\n  // Impose Convection boundary conditions\n  thermalBoundaryConditions.imposeConvectionBoundaryConditions(\n    residualVector,\n    jacobianMatrix,\n    gaussPoints,\n    gaussWeights,\n    nodesXCoordinates,\n    nodesYCoordinates,\n    basisFunctions\n  );\n  basicLog(\"Convection boundary conditions applied\");\n\n  // Impose ConstantTemp boundary conditions\n  thermalBoundaryConditions.imposeConstantTempBoundaryConditions(residualVector, jacobianMatrix);\n  basicLog(\"Constant temperature boundary conditions applied\");\n\n  // Print all residuals in debug mode\n  debugLog(\"Residuals at each node:\");\n  for (let i = 0; i < residualVector.length; i++) {\n    debugLog(`Node ${i}: ${residualVector[i].toExponential(6)}`);\n  }\n\n  basicLog(\"Solid heat transfer matrix assembly completed\");\n\n  return {\n    jacobianMatrix,\n    residualVector,\n  };\n}\n\n/**\n * Function to assemble the local Jacobian matrix and residuals vector for the solid heat transfer model when using the frontal system solver\n */\nexport function assembleSolidHeatTransferFront({\n  elementIndex,\n  nop,\n  xCoordinates,\n  yCoordinates,\n  basisFunctions,\n  gaussPoints,\n  gaussWeights,\n  ntopFlag = false,\n  nlatFlag = false,\n  convectionTop = { active: false, coeff: 0, extTemp: 0 }, // NEW\n}) {\n  const numNodes = 9; // biquadratic 2D\n  const estifm = Array(numNodes)\n    .fill()\n    .map(() => Array(numNodes).fill(0));\n  const localLoad = Array(numNodes).fill(0);\n\n  // Global node numbers (1-based in nop)\n  const ngl = Array(numNodes);\n  for (let i = 0; i < numNodes; i++) ngl[i] = Math.abs(nop[elementIndex][i]);\n\n  // Volume (conductive) contribution\n  for (let j = 0; j < gaussPoints.length; j++) {\n    for (let k = 0; k < gaussPoints.length; k++) {\n      const { basisFunction, basisFunctionDerivKsi, basisFunctionDerivEta } =\n        basisFunctions.getBasisFunctions(gaussPoints[j], gaussPoints[k]);\n\n      const localToGlobalMap = ngl.map((g) => g - 1);\n\n      const { detJacobian, basisFunctionDerivX, basisFunctionDerivY } = performIsoparametricMapping2D({\n        basisFunction,\n        basisFunctionDerivKsi,\n        basisFunctionDerivEta,\n        nodesXCoordinates: xCoordinates,\n        nodesYCoordinates: yCoordinates,\n        localToGlobalMap,\n        numNodes,\n      });\n\n      for (let a = 0; a < numNodes; a++) {\n        for (let b = 0; b < numNodes; b++) {\n          estifm[a][b] -=\n            gaussWeights[j] *\n            gaussWeights[k] *\n            detJacobian *\n            (basisFunctionDerivX[a] * basisFunctionDerivX[b] +\n              basisFunctionDerivY[a] * basisFunctionDerivY[b]);\n        }\n      }\n    }\n  }\n\n  // Legacy natural boundary terms (top edge eta=1; right edge ksi=1) kept as in original frontal version\n  // Replace previous generic top-edge load term with explicit Robin (convection) if requested\n  if (ntopFlag && convectionTop.active) {\n    const h = convectionTop.coeff;\n    const Text = convectionTop.extTemp;\n    // Integrate along top edge (eta = 1); local top edge nodes: 2,5,8\n    for (let gp = 0; gp < gaussPoints.length; gp++) {\n      const ksi = gaussPoints[gp];\n      const { basisFunction, basisFunctionDerivKsi } = basisFunctions.getBasisFunctions(ksi, 1);\n\n      // Compute metric (edge length differential) |dx/dksi|\n      let dx_dksi = 0, dy_dksi = 0;\n      const topEdgeLocalNodes = [2, 5, 8];\n      for (let n = 0; n < 9; n++) {\n        const g = nop[elementIndex][n] - 1;\n        dx_dksi += xCoordinates[g] * basisFunctionDerivKsi[n];\n        dy_dksi += yCoordinates[g] * basisFunctionDerivKsi[n];\n      }\n      const ds_dksi = Math.sqrt(dx_dksi * dx_dksi + dy_dksi * dy_dksi);\n\n      // Assemble Robin contributions\n      for (const a of topEdgeLocalNodes) {\n        for (const b of topEdgeLocalNodes) {\n          estifm[a][b] -= gaussWeights[gp] * ds_dksi * h * basisFunction[a] * basisFunction[b];\n        }\n        localLoad[a] -= gaussWeights[gp] * ds_dksi * h * Text * basisFunction[a];\n      }\n    }\n  } else if (ntopFlag && !convectionTop.active) {\n    // If a zero-flux (symmetry) condition were applied on top, do nothing (natural BC)\n    // (Previous placeholder load term removed to avoid unintended flux)\n  }\n\n  // If needed, similar patterned handling could be added for right edge (nlatFlag) later.\n\n  return { estifm, localLoad, ngl };\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n// Internal imports\nimport { newtonRaphson } from \"./methods/newtonRaphsonScript.js\";\nimport { solveLinearSystem } from \"./methods/linearSystemSolverScript.js\";\nimport { prepareMesh } from \"./mesh/meshUtilsScript.js\";\nimport { assembleFrontPropagationMat } from \"./solvers/frontPropagationScript.js\";\nimport { assembleSolidHeatTransferMat } from \"./solvers/solidHeatTransferScript.js\";\nimport { runFrontalSolver } from \"./methods/frontalSolverScript.js\";\nimport { basicLog, debugLog, errorLog } from \"./utilities/loggingScript.js\";\n\n/**\n * Class to implement finite element analysis in JavaScript\n * @param {string} solverConfig - Parameter specifying the type of solver\n * @param {object} meshConfig - Object containing computational mesh details\n * @param {object} boundaryConditions - Object containing boundary conditions for the finite element analysis\n * @returns {object} An object containing the solution vector and additional mesh information\n */\nexport class FEAScriptModel {\n  constructor() {\n    this.solverConfig = null;\n    this.meshConfig = {};\n    this.boundaryConditions = {};\n    this.solverMethod = \"lusolve\"; // Default solver method\n    basicLog(\"FEAScriptModel instance created\");\n  }\n\n  setSolverConfig(solverConfig) {\n    this.solverConfig = solverConfig;\n    debugLog(`Solver config set to: ${solverConfig}`);\n  }\n\n  setMeshConfig(meshConfig) {\n    this.meshConfig = meshConfig;\n    debugLog(`Mesh config set with dimensions: ${meshConfig.meshDimension}`);\n  }\n\n  addBoundaryCondition(boundaryKey, condition) {\n    this.boundaryConditions[boundaryKey] = condition;\n    debugLog(`Boundary condition added for boundary: ${boundaryKey}, type: ${condition[0]}`);\n  }\n\n  setSolverMethod(solverMethod) {\n    this.solverMethod = solverMethod;\n    debugLog(`Solver method set to: ${solverMethod}`);\n  }\n\n  solve() {\n    if (!this.solverConfig || !this.meshConfig || !this.boundaryConditions) {\n      const error = \"Solver config, mesh config, and boundary conditions must be set before solving.\";\n      console.error(error);\n      throw new Error(error);\n    }\n\n    let jacobianMatrix = [];\n    let residualVector = [];\n    let solutionVector = [];\n    let initialSolution = [];\n\n    // Prepare the mesh\n    basicLog(\"Preparing mesh...\");\n    const meshData = prepareMesh(this.meshConfig);\n    basicLog(\"Mesh preparation completed\");\n\n    // Extract node coordinates from meshData\n    const nodesCoordinates = {\n      nodesXCoordinates: meshData.nodesXCoordinates,\n      nodesYCoordinates: meshData.nodesYCoordinates,\n    };\n\n    // Select and execute the appropriate solver based on solverConfig\n    basicLog(\"Beginning solving process...\");\n    console.time(\"totalSolvingTime\");\n    if (this.solverConfig === \"solidHeatTransferScript\") {\n      basicLog(`Using solver: ${this.solverConfig}`);\n\n      // Check if using frontal solver\n      if (this.solverMethod === \"frontal\") {\n        basicLog(`Using frontal solver method`);\n        // Call frontal solver\n        const frontalResult = runFrontalSolver(this.meshConfig, this.boundaryConditions);\n        solutionVector = frontalResult.solutionVector;\n      } else {\n        // Use regular linear solver methods\n        ({ jacobianMatrix, residualVector } = assembleSolidHeatTransferMat(\n          meshData,\n          this.boundaryConditions\n        ));\n        const linearSystemResult = solveLinearSystem(this.solverMethod, jacobianMatrix, residualVector);\n        solutionVector = linearSystemResult.solutionVector;\n      }\n    } else if (this.solverConfig === \"frontPropagationScript\") {\n      basicLog(`Using solver: ${this.solverConfig}`);\n\n      // Initialize eikonalActivationFlag\n      let eikonalActivationFlag = 0;\n      const eikonalExteralIterations = 5; // Number of incremental steps for the eikonal equation\n\n      // Create context object with all necessary properties\n      const context = {\n        meshData: meshData,\n        boundaryConditions: this.boundaryConditions,\n        eikonalActivationFlag: eikonalActivationFlag,\n        solverMethod: this.solverMethod,\n        initialSolution,\n      };\n\n      while (eikonalActivationFlag <= 1) {\n        // Update the context object with current eikonalActivationFlag\n        context.eikonalActivationFlag = eikonalActivationFlag;\n\n        // Pass the previous solution as initial guess\n        if (solutionVector.length > 0) {\n          context.initialSolution = [...solutionVector];\n        }\n\n        // Solve the assembled non-linear system\n        const newtonRaphsonResult = newtonRaphson(assembleFrontPropagationMat, context, 100, 1e-4);\n\n        // Extract results\n        jacobianMatrix = newtonRaphsonResult.jacobianMatrix;\n        residualVector = newtonRaphsonResult.residualVector;\n        solutionVector = newtonRaphsonResult.solutionVector;\n\n        // Increment for next iteration\n        eikonalActivationFlag += 1 / eikonalExteralIterations;\n      }\n    }\n    console.timeEnd(\"totalSolvingTime\");\n    basicLog(\"Solving process completed\");\n\n    return { solutionVector, nodesCoordinates };\n  }\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n// Internal imports\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Function to import mesh data from Gmsh format containing quadrilateral and triangular elements\n * @param {File} file - The Gmsh file to be parsed (.msh version 4.1)\n * @returns {object} The parsed mesh data including node coordinates, element connectivity, and boundary conditions\n */\nconst importGmshQuadTri = async (file) => {\n  let result = {\n    nodesXCoordinates: [],\n    nodesYCoordinates: [],\n    nodalNumbering: {\n      quadElements: [],\n      triangleElements: [],\n    },\n    boundaryElements: [],\n    boundaryConditions: [],\n    boundaryNodePairs: {}, // Store boundary node pairs for processing in meshGenerationScript\n    gmshV: 0,\n    ascii: false,\n    fltBytes: \"8\",\n    totalNodesX: 0,\n    totalNodesY: 0,\n    physicalPropMap: [],\n    elementTypes: {},\n  };\n\n  let content = await file.text();\n  let lines = content\n    .split(\"\\n\")\n    .map((line) => line.trim())\n    .filter((line) => line !== \"\" && line !== \" \");\n\n  let section = \"\";\n  let lineIndex = 0;\n\n  let nodeEntityBlocks = 0;\n  let totalNodes = 0;\n  let nodeBlocksProcessed = 0;\n  let currentNodeBlock = { numNodes: 0 };\n  let nodeTagsCollected = 0;\n  let nodeTags = [];\n  let nodeCoordinatesCollected = 0;\n\n  let elementEntityBlocks = 0;\n  let totalElements = 0;\n  let elementBlocksProcessed = 0;\n  let currentElementBlock = {\n    dim: 0,\n    tag: 0,\n    elementType: 0,\n    numElements: 0,\n  };\n  let elementsProcessedInBlock = 0;\n\n  let boundaryElementsByTag = {};\n\n  while (lineIndex < lines.length) {\n    const line = lines[lineIndex];\n\n    if (line === \"$MeshFormat\") {\n      section = \"meshFormat\";\n      lineIndex++;\n      continue;\n    } else if (line === \"$EndMeshFormat\") {\n      section = \"\";\n      lineIndex++;\n      continue;\n    } else if (line === \"$PhysicalNames\") {\n      section = \"physicalNames\";\n      lineIndex++;\n      continue;\n    } else if (line === \"$EndPhysicalNames\") {\n      section = \"\";\n      lineIndex++;\n      continue;\n    } else if (line === \"$Entities\") {\n      section = \"entities\";\n      lineIndex++;\n      continue;\n    } else if (line === \"$EndEntities\") {\n      section = \"\";\n      lineIndex++;\n      continue;\n    } else if (line === \"$Nodes\") {\n      section = \"nodes\";\n      lineIndex++;\n      continue;\n    } else if (line === \"$EndNodes\") {\n      section = \"\";\n      lineIndex++;\n      continue;\n    } else if (line === \"$Elements\") {\n      section = \"elements\";\n      lineIndex++;\n      continue;\n    } else if (line === \"$EndElements\") {\n      section = \"\";\n      lineIndex++;\n      continue;\n    }\n\n    const parts = line.split(/\\s+/).filter((part) => part !== \"\");\n\n    if (section === \"meshFormat\") {\n      result.gmshV = parseFloat(parts[0]);\n      result.ascii = parts[1] === \"0\";\n      result.fltBytes = parts[2];\n    } else if (section === \"physicalNames\") {\n      if (parts.length >= 3) {\n        if (!/^\\d+$/.test(parts[0])) {\n          lineIndex++;\n          continue;\n        }\n\n        const dimension = parseInt(parts[0], 10);\n        const tag = parseInt(parts[1], 10);\n        let name = parts.slice(2).join(\" \");\n        name = name.replace(/^\"|\"$/g, \"\");\n\n        result.physicalPropMap.push({\n          tag,\n          dimension,\n          name,\n        });\n      }\n    } else if (section === \"nodes\") {\n      if (nodeEntityBlocks === 0) {\n        nodeEntityBlocks = parseInt(parts[0], 10);\n        totalNodes = parseInt(parts[1], 10);\n        result.nodesXCoordinates = new Array(totalNodes).fill(0);\n        result.nodesYCoordinates = new Array(totalNodes).fill(0);\n        lineIndex++;\n        continue;\n      }\n\n      if (nodeBlocksProcessed < nodeEntityBlocks && currentNodeBlock.numNodes === 0) {\n        currentNodeBlock = {\n          dim: parseInt(parts[0], 10),\n          tag: parseInt(parts[1], 10),\n          parametric: parseInt(parts[2], 10),\n          numNodes: parseInt(parts[3], 10),\n        };\n\n        nodeTags = [];\n        nodeTagsCollected = 0;\n        nodeCoordinatesCollected = 0;\n\n        lineIndex++;\n        continue;\n      }\n\n      if (nodeTagsCollected < currentNodeBlock.numNodes) {\n        for (let i = 0; i < parts.length && nodeTagsCollected < currentNodeBlock.numNodes; i++) {\n          nodeTags.push(parseInt(parts[i], 10));\n          nodeTagsCollected++;\n        }\n\n        if (nodeTagsCollected < currentNodeBlock.numNodes) {\n          lineIndex++;\n          continue;\n        }\n\n        lineIndex++;\n        continue;\n      }\n\n      if (nodeCoordinatesCollected < currentNodeBlock.numNodes) {\n        const nodeTag = nodeTags[nodeCoordinatesCollected] - 1;\n        const x = parseFloat(parts[0]);\n        const y = parseFloat(parts[1]);\n\n        result.nodesXCoordinates[nodeTag] = x;\n        result.nodesYCoordinates[nodeTag] = y;\n        result.totalNodesX++;\n        result.totalNodesY++;\n\n        nodeCoordinatesCollected++;\n\n        if (nodeCoordinatesCollected === currentNodeBlock.numNodes) {\n          nodeBlocksProcessed++;\n          currentNodeBlock = { numNodes: 0 };\n        }\n      }\n    } else if (section === \"elements\") {\n      if (elementEntityBlocks === 0) {\n        elementEntityBlocks = parseInt(parts[0], 10);\n        totalElements = parseInt(parts[1], 10);\n        lineIndex++;\n        continue;\n      }\n\n      if (elementBlocksProcessed < elementEntityBlocks && currentElementBlock.numElements === 0) {\n        currentElementBlock = {\n          dim: parseInt(parts[0], 10),\n          tag: parseInt(parts[1], 10),\n          elementType: parseInt(parts[2], 10),\n          numElements: parseInt(parts[3], 10),\n        };\n\n        result.elementTypes[currentElementBlock.elementType] =\n          (result.elementTypes[currentElementBlock.elementType] || 0) + currentElementBlock.numElements;\n\n        elementsProcessedInBlock = 0;\n        lineIndex++;\n        continue;\n      }\n\n      if (elementsProcessedInBlock < currentElementBlock.numElements) {\n        const elementTag = parseInt(parts[0], 10);\n        const nodeIndices = parts.slice(1).map((idx) => parseInt(idx, 10));\n\n        if (currentElementBlock.elementType === 1 || currentElementBlock.elementType === 8) {\n          const physicalTag = currentElementBlock.tag;\n\n          if (!boundaryElementsByTag[physicalTag]) {\n            boundaryElementsByTag[physicalTag] = [];\n          }\n\n          boundaryElementsByTag[physicalTag].push(nodeIndices);\n\n          // Store boundary node pairs for later processing in meshGenerationScript\n          if (!result.boundaryNodePairs[physicalTag]) {\n            result.boundaryNodePairs[physicalTag] = [];\n          }\n          result.boundaryNodePairs[physicalTag].push(nodeIndices);\n        } else if (currentElementBlock.elementType === 2) {\n          // Linear triangle elements (3 nodes)\n          result.nodalNumbering.triangleElements.push(nodeIndices);\n        } else if (currentElementBlock.elementType === 3) {\n          // Linear quadrilateral elements (4 nodes)\n          result.nodalNumbering.quadElements.push(nodeIndices);\n        } else if (currentElementBlock.elementType === 10) {\n          // Quadratic quadrilateral elements (9 nodes)\n          result.nodalNumbering.quadElements.push(nodeIndices);\n        }\n\n        elementsProcessedInBlock++;\n\n        if (elementsProcessedInBlock === currentElementBlock.numElements) {\n          elementBlocksProcessed++;\n          currentElementBlock = { numElements: 0 };\n        }\n      }\n    }\n\n    lineIndex++;\n  }\n\n  // Store boundary conditions information\n  result.physicalPropMap.forEach((prop) => {\n    if (prop.dimension === 1) {\n      const boundaryNodes = boundaryElementsByTag[prop.tag] || [];\n\n      if (boundaryNodes.length > 0) {\n        result.boundaryConditions.push({\n          name: prop.name,\n          tag: prop.tag,\n          nodes: boundaryNodes,\n        });\n      }\n    }\n  });\n\n  debugLog(\n    `Parsed boundary node pairs by physical tag: ${JSON.stringify(\n      result.boundaryNodePairs\n    )}. These pairs will be used to identify boundary elements in the mesh.`\n  );\n\n  return result;\n};\n\nexport { importGmshQuadTri };\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n/**\n * Function to create plots of the solution vector\n * @param {*} solutionVector - The computed solution vector\n * @param {*} nodesCoordinates - Object containing x and y coordinates for the nodes\n * @param {string} solverConfig - Parameter specifying the type of solver\n * @param {string} meshDimension - The dimension of the solution\n * @param {string} plotType - The type of plot\n * @param {string} plotDivId - The id of the div where the plot will be rendered\n * @param {string} [meshType=\"structured\"] - Type of mesh: \"structured\" or \"unstructured\"\n */\nexport function plotSolution(\n  solutionVector,\n  nodesCoordinates,\n  solverConfig,\n  meshDimension,\n  plotType,\n  plotDivId,\n  meshType = \"structured\"\n) {\n  const { nodesXCoordinates, nodesYCoordinates } = nodesCoordinates;\n\n  if (meshDimension === \"1D\" && plotType === \"line\") {\n    // Check if solutionVector is a nested array\n    let yData;\n    if (solutionVector.length > 0 && Array.isArray(solutionVector[0])) {\n      yData = solutionVector.map((arr) => arr[0]);\n    } else {\n      yData = solutionVector;\n    }\n    let xData = Array.from(nodesXCoordinates);\n\n    let lineData = {\n      x: xData,\n      y: yData,\n      mode: \"lines\",\n      type: \"scatter\",\n      line: { color: \"rgb(219, 64, 82)\", width: 2 },\n      name: \"Solution\",\n    };\n\n    let maxWindowWidth = Math.min(window.innerWidth, 700);\n    let maxPlotWidth = Math.max(...xData);\n    let zoomFactor = maxWindowWidth / maxPlotWidth;\n    let plotWidth = Math.max(zoomFactor * maxPlotWidth, 400);\n    let plotHeight = 350;\n\n    let layout = {\n      title: `line plot - ${solverConfig}`,\n      width: plotWidth,\n      height: plotHeight,\n      xaxis: { title: \"x\" },\n      yaxis: { title: \"Solution\" },\n      margin: { l: 70, r: 40, t: 50, b: 50 },\n    };\n\n    Plotly.newPlot(plotDivId, [lineData], layout, { responsive: true });\n  } else if (meshDimension === \"2D\" && plotType === \"contour\") {\n    // Use the user-provided mesh type\n    const isStructured = meshType === \"structured\";\n    \n    // For auto-detection (if needed)\n    const uniqueXCoords = new Set(nodesXCoordinates).size;\n    const uniqueYCoords = new Set(nodesYCoordinates).size;\n    \n    // Extract scalar values from solution vector\n    let zValues;\n    if (Array.isArray(solutionVector[0])) {\n      zValues = solutionVector.map(val => val[0]);\n    } else {\n      zValues = solutionVector;\n    }\n    \n    // Common sizing parameters for both plot types\n    let maxWindowWidth = Math.min(window.innerWidth, 700);\n    let maxX = Math.max(...nodesXCoordinates);\n    let maxY = Math.max(...nodesYCoordinates);\n    let aspectRatio = maxY / maxX;\n    let plotWidth = Math.min(maxWindowWidth, 600);\n    let plotHeight = plotWidth * aspectRatio * 0.8; // Slightly reduce height for better appearance\n    \n    // Common layout properties\n    let layout = {\n      title: `${plotType} plot - ${solverConfig}`,\n      width: plotWidth,\n      height: plotHeight,\n      xaxis: { title: \"x\" },\n      yaxis: { title: \"y\" },\n      margin: { l: 50, r: 50, t: 50, b: 50 },\n      hovermode: 'closest'\n    };\n    \n    if (isStructured) {\n      // Calculate the number of nodes along the x-axis and y-axis\n      const numNodesX = uniqueXCoords;\n      const numNodesY = uniqueYCoords;\n\n      // Reshape the nodesXCoordinates and nodesYCoordinates arrays to match the grid dimensions\n      let reshapedXCoordinates = math.reshape(Array.from(nodesXCoordinates), [numNodesX, numNodesY]);\n      let reshapedYCoordinates = math.reshape(Array.from(nodesYCoordinates), [numNodesX, numNodesY]);\n\n      // Reshape the solution array to match the grid dimensions\n      let reshapedSolution = math.reshape(Array.from(solutionVector), [numNodesX, numNodesY]);\n\n      // Transpose the reshapedSolution array to get column-wise data\n      let transposedSolution = math.transpose(reshapedSolution);\n\n      // Create an array for x-coordinates used in the contour plot\n      let reshapedXForPlot = [];\n      for (let i = 0; i < numNodesX * numNodesY; i += numNodesY) {\n        let xValue = nodesXCoordinates[i];\n        reshapedXForPlot.push(xValue);\n      }\n\n      // Create the data structure for the contour plot\n      let contourData = {\n        z: transposedSolution,\n        type: \"contour\",\n        contours: {\n          coloring: \"heatmap\",\n          showlabels: false\n        },\n        //colorscale: 'Viridis',\n        colorbar: {\n          title: 'Solution'\n        },\n        x: reshapedXForPlot,\n        y: reshapedYCoordinates[0],\n        name: 'Solution Field'\n      };\n\n      // Create the plot using Plotly\n      Plotly.newPlot(plotDivId, [contourData], layout, { responsive: true });\n    } else {\n      // Create an interpolated contour plot for the unstructured mesh\n      let contourData = {\n        x: nodesXCoordinates,\n        y: nodesYCoordinates,\n        z: zValues,\n        type: 'contour',\n        contours: {\n          coloring: 'heatmap',\n          showlabels: false\n        },\n        //colorscale: 'Viridis',\n        colorbar: {\n          title: 'Solution'\n        },\n        name: 'Solution Field'\n      };\n      \n      // Create the plot using only the contour fill\n      Plotly.newPlot(plotDivId, [contourData], layout, { responsive: true });\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    [\"proxy\", proxyTransferHandler],\n    [\"throw\", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case \"GET\" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction wrap(ep, target) {\n    const pendingListeners = new Map();\n    ep.addEventListener(\"message\", function handleMessage(ev) {\n        const { data } = ev;\n        if (!data || !data.id) {\n            return;\n        }\n        const resolver = pendingListeners.get(data.id);\n        if (!resolver) {\n            return;\n        }\n        try {\n            resolver(data);\n        }\n        finally {\n            pendingListeners.delete(data.id);\n        }\n    });\n    return createProxy(ep, pendingListeners, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, new Map(), {\n        type: \"RELEASE\" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, pendingListeners, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    pendingListeners.clear();\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, pendingListeners, {\n                    type: \"GET\" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, pendingListeners, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously Â¯\\_(ãƒ„)_/Â¯\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"SET\" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, pendingListeners, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didnâ€™t happen.\n            if (last === \"bind\") {\n                return createProxy(ep, pendingListeners, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"APPLY\" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case \"HANDLER\" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, pendingListeners, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        pendingListeners.set(id, resolve);\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join(\"-\");\n}\n\nexport { createEndpoint, expose, finalizer, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n// External imports\nimport * as Comlink from \"../vendor/comlink.mjs\";\n\n// Internal imports\nimport { basicLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Class to facilitate communication with web workers for FEAScript operations\n */\nexport class FEAScriptWorker {\n  /**\n   * Constructor to initialize the FEAScriptWorker class\n   * Sets up the worker and initializes the workerWrapper.\n   */\n  constructor() {\n    this.worker = null;\n    this.feaWorker = null;\n    this.isReady = false;\n\n    this._initWorker();\n  }\n\n  /**\n   * Function to initialize the web worker and wrap it using Comlink.\n   * @private\n   * @throws Will throw an error if the worker fails to initialize.\n   */\n  async _initWorker() {\n    try {\n      this.worker = new Worker(new URL(\"./wrapperScript.js\", import.meta.url), {\n        type: \"module\",\n      });\n\n      this.worker.onerror = (event) => {\n        console.error(\"FEAScriptWorker: Worker error:\", event);\n      };\n      const workerWrapper = Comlink.wrap(this.worker);\n\n      this.feaWorker = await new workerWrapper();\n\n      this.isReady = true;\n    } catch (error) {\n      console.error(\"Failed to initialize worker\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Function to ensure that the worker is ready before performing any operations.\n   * @private\n   * @returns {Promise<void>} Resolves when the worker is ready.\n   * @throws Will throw an error if the worker is not ready within the timeout period.\n   */\n  async _ensureReady() {\n    if (this.isReady) return Promise.resolve();\n\n    return new Promise((resolve, reject) => {\n      let attempts = 0;\n      const maxAttempts = 50; // 5 seconds max\n\n      const checkReady = () => {\n        attempts++;\n        if (this.isReady) {\n          resolve();\n        } else if (attempts >= maxAttempts) {\n          reject(new Error(\"Timeout waiting for worker to be ready\"));\n        } else {\n          setTimeout(checkReady, 1000);\n        }\n      };\n      checkReady();\n    });\n  }\n\n  /**\n   * Function to set the solver configuration in the worker.\n   * @param {string} solverConfig - The solver configuration to set.\n   * @returns {Promise<boolean>} Resolves when the configuration is set.\n   */\n  async setSolverConfig(solverConfig) {\n    await this._ensureReady();\n    basicLog(`FEAScriptWorker: Setting solver config to: ${solverConfig}`);\n    return this.feaWorker.setSolverConfig(solverConfig);\n  }\n\n  /**\n   * Sets the mesh configuration in the worker.\n   * @param {object} meshConfig - The mesh configuration to set.\n   * @returns {Promise<boolean>} Resolves when the configuration is set.\n   */\n  async setMeshConfig(meshConfig) {\n    await this._ensureReady();\n    basicLog(`FEAScriptWorker: Setting mesh config`);\n    return this.feaWorker.setMeshConfig(meshConfig);\n  }\n\n  /**\n   * Adds a boundary condition to the worker.\n   * @param {string} boundaryKey - The key identifying the boundary.\n   * @param {array} condition - The boundary condition to add.\n   * @returns {Promise<boolean>} Resolves when the boundary condition is added.\n   */\n  async addBoundaryCondition(boundaryKey, condition) {\n    await this._ensureReady();\n    basicLog(`FEAScriptWorker: Adding boundary condition for boundary: ${boundaryKey}`);\n    return this.feaWorker.addBoundaryCondition(boundaryKey, condition);\n  }\n\n  /**\n   * Sets the solver method in the worker.\n   * @param {string} solverMethod - The solver method to set.\n   * @returns {Promise<boolean>} Resolves when the solver method is set.\n   */\n  async setSolverMethod(solverMethod) {\n    await this._ensureReady();\n    basicLog(`FEAScriptWorker: Setting solver method to: ${solverMethod}`);\n    return this.feaWorker.setSolverMethod(solverMethod);\n  }\n\n  /**\n   * Requests the worker to solve the problem.\n   * @returns {Promise<object>} Resolves with the solution result.\n   */\n  async solve() {\n    await this._ensureReady();\n    basicLog(\"FEAScriptWorker: Requesting solution from worker...\");\n\n    const startTime = performance.now();\n    const result = await this.feaWorker.solve();\n    const endTime = performance.now();\n\n    basicLog(`FEAScriptWorker: Solution completed in ${((endTime - startTime) / 1000).toFixed(2)}s`);\n    return result;\n  }\n\n  /**\n   * Retrieves model information from the worker.\n   * @returns {Promise<object>} Resolves with the model information.\n   */\n  async getModelInfo() {\n    await this._ensureReady();\n    return this.feaWorker.getModelInfo();\n  }\n\n  /**\n   * Sends a ping request to the worker to check its availability.\n   * @returns {Promise<boolean>} Resolves if the worker responds.\n   */\n  async ping() {\n    await this._ensureReady();\n    return this.feaWorker.ping();\n  }\n\n  /**\n   * Terminates the worker and cleans up resources.\n   */\n  terminate() {\n    if (this.worker) {\n      this.worker.terminate();\n      this.worker = null;\n      this.feaWorker = null;\n      this.isReady = false;\n    }\n  }\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\nexport { FEAScriptModel } from \"./FEAScript.js\";\nexport { importGmshQuadTri } from \"./readers/gmshReaderScript.js\";\nexport { logSystem, printVersion } from \"./utilities/loggingScript.js\";\nexport { plotSolution } from \"./visualization/plotSolutionScript.js\";\nexport { FEAScriptWorker } from \"./workers/workerScript.js\";\nexport const VERSION = \"0.1.3\";"],"names":["euclideanNorm","vector","norm","i","length","Math","sqrt","currentLogLevel","logSystem","level","console","log","basicLog","debugLog","message","errorLog","async","printVersion","commitResponse","fetch","commitData","json","latestCommitDate","Date","commit","committer","date","toLocaleString","error","solveLinearSystem","solverMethod","jacobianMatrix","residualVector","options","maxIterations","tolerance","solutionVector","converged","iterations","time","jacobianMatrixSparse","math","sparse","luFactorization","slu","solutionMatrix","lusolve","squeeze","valueOf","jacobiSolverResult","initialGuess","n","x","xNew","Array","iteration","sum","j","maxDiff","max","abs","jacobiSolver","fill","timeEnd","newtonRaphson","assembleMat","context","errorNorm","deltaX","totalNodes","meshData","nodesXCoordinates","initialSolution","Number","boundaryConditions","eikonalActivationFlag","toExponential","BasisFunctions","constructor","meshDimension","elementOrder","this","getBasisFunctions","ksi","eta","basisFunction","basisFunctionDerivKsi","basisFunctionDerivEta","l1","c","l2","l3","dl1","dl2","dl3","Mesh","numElementsX","maxX","numElementsY","maxY","parsedMesh","boundaryElementsProcessed","parseMeshFromGmsh","nodalNumbering","isArray","quadElements","triangleElements","JSON","stringify","elementTypes","mappedNodalNumbering","elemIdx","gmshNodes","feaScriptNodes","push","physicalPropMap","boundaryElements","undefined","fixedBoundaryElements","boundaryNodePairs","forEach","prop","dimension","tag","nodesPair","node1","node2","name","foundElement","elemNodes","includes","side","node1Index","indexOf","node2Index","join","Mesh1D","super","generateMesh","totalNodesX","nodeIndex","generate1DNodalNumbering","findBoundaryElements","nop","elementIndex","columnCounter","sideIndex","Mesh2D","nodesYCoordinates","totalNodesY","deltaY","nodeIndexY","nodeIndexX","nnode","generate2DNodalNumbering","rowCounter","elementIndexX","elementIndexY","nodeIndex1","nodeIndex2","NumericalIntegration","getGaussPointsAndWeights","gaussPoints","gaussWeights","initializeFEA","colIndex","basisFunctions","gaussPointsAndWeights","localToGlobalMap","numNodes","performIsoparametricMapping1D","params","xCoordinates","ksiDerivX","localNodeIndex","detJacobian","basisFunctionDerivX","performIsoparametricMapping2D","yCoordinates","etaDerivX","ksiDerivY","etaDerivY","basisFunctionDerivY","GenericBoundaryConditions","imposeConstantValueBoundaryConditions","Object","keys","boundaryKey","value","globalNodeIndex","assembleFrontPropagationMat","eikonalViscousTerm","totalElements","FEAData","gaussPointIndex1","basisFunctionsAndDerivatives","mappingResult","solutionDerivX","localNodeIndex1","localNodeIndex2","gaussPointIndex2","solutionDerivY","localToGlobalMap1","localToGlobalMap2","ThermalBoundaryConditions","imposeConstantTempBoundaryConditions","tempValue","imposeConvectionBoundaryConditions","convectionHeatTranfCoeff","convectionExtTemp","key","boundaryCondition","convectionCoeff","extTemp","gaussPoint1","gaussPoint2","firstNodeIndex","lastNodeIndex","nodeIncrement","tangentVectorLength","globalNodeIndex2","gaussPointIndex","runFrontalSolver","meshConfig","block1","nex","ney","xorigin","yorigin","xlast","ylast","deltax","deltay","xydiscr","ne","nnx","nny","np","nel","k","l","nodnumb","xpt","ypt","xycoord","ncod","bc","col","ntop","nlat","r1","fro1","npt","iwr1","ntra","det","nbn","lco","ldest","kdest","khed","nmax","kpiv","lpiv","jmod","pvkol","eq","map","nrs","nnmax","ncs","check","ice","ipiv","nsum","fabf1","nell","nep","lcol","krow","abfind","nend","lend","lk","ll","kk","nodk","fb1","lhed","estifm","lc","ir","kr","kt","kro","irr","kh","kpivro","lpivco","pivot","lpivc","kpivr","piva","nhlp","iperm","qq","rhs","krw","fac","ecpiv","ecv","ice1","bacsub","front","u","sk","main","slice","nodesCoordinates","nemax","gauss","w","gp","basisFunctionsLib","localLoad","ngl","ntopFlag","nlatFlag","convectionTop","active","coeff","g","a","b","h","Text","dx_dksi","dy_dksi","topEdgeLocalNodes","ds_dksi","assembleSolidHeatTransferFront","iv","iii","gash","FEAScriptModel","solverConfig","setSolverConfig","setMeshConfig","addBoundaryCondition","condition","setSolverMethod","solve","Error","mesh","nodesCoordinatesAndNumbering","prepareMesh","thermalBoundaryConditions","assembleSolidHeatTransferMat","eikonalExteralIterations","newtonRaphsonResult","importGmshQuadTri","file","result","gmshV","ascii","fltBytes","lines","text","split","line","trim","filter","section","lineIndex","nodeEntityBlocks","nodeBlocksProcessed","currentNodeBlock","nodeTagsCollected","nodeTags","nodeCoordinatesCollected","elementEntityBlocks","elementBlocksProcessed","currentElementBlock","dim","elementType","numElements","elementsProcessedInBlock","boundaryElementsByTag","parts","part","parseFloat","test","parseInt","replace","parametric","nodeTag","y","nodeIndices","idx","physicalTag","boundaryNodes","nodes","plotSolution","plotType","plotDivId","meshType","yData","arr","xData","from","lineData","mode","type","color","width","maxWindowWidth","min","window","innerWidth","maxPlotWidth","zoomFactor","layout","title","height","xaxis","yaxis","margin","r","t","Plotly","newPlot","responsive","isStructured","uniqueXCoords","Set","size","uniqueYCoords","zValues","val","aspectRatio","plotWidth","hovermode","numNodesX","numNodesY","reshape","reshapedYCoordinates","reshapedSolution","transposedSolution","transpose","reshapedXForPlot","xValue","contourData","z","contours","coloring","showlabels","colorbar","proxyMarker","Symbol","createEndpoint","releaseProxy","finalizer","throwMarker","isObject","transferHandlers","Map","canHandle","serialize","obj","port1","port2","MessageChannel","expose","deserialize","port","start","wrap","serialized","isError","stack","assign","ep","globalThis","allowedOrigins","addEventListener","callback","ev","data","origin","allowedOrigin","RegExp","isAllowedOrigin","warn","id","path","argumentList","fromWireValue","returnValue","parent","reduce","rawValue","apply","proxy","transfers","transferCache","set","transfer","Promise","resolve","catch","then","wireValue","transferables","toWireValue","postMessage","removeEventListener","closeEndPoint","TypeError","endpoint","isMessagePort","close","target","pendingListeners","resolver","get","delete","createProxy","throwIfProxyReleased","isReleased","releaseEndpoint","requestResponseMessage","proxyCounter","WeakMap","proxyFinalizers","FinalizationRegistry","newCount","isProxyReleased","Proxy","_target","unregister","unregisterProxy","clear","p","toString","bind","_thisArg","rawArgumentList","last","processArguments","construct","register","registerProxy","processed","v","prototype","concat","handler","serializedValue","msg","floor","random","MAX_SAFE_INTEGER","FEAScriptWorker","worker","feaWorker","isReady","_initWorker","Worker","URL","url","onerror","event","workerWrapper","Comlink.wrap","_ensureReady","reject","attempts","checkReady","setTimeout","startTime","performance","now","toFixed","getModelInfo","ping","terminate","VERSION"],"mappings":"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"}