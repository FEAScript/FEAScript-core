{"version":3,"file":"feascript.esm.js","sources":["../src/methods/euclideanNormScript.js","../src/utilities/loggingScript.js","../src/vendor/comlink.mjs","../src/methods/linearSystemSolverScript.js","../src/methods/jacobiSolverScript.js","../src/mesh/basisFunctionsScript.js","../src/mesh/meshGenerationScript.js","../src/methods/numericalIntegrationScript.js","../src/mesh/meshUtilsScript.js","../src/models/thermalBoundaryConditionsScript.js","../src/models/heatConductionScript.js","../src/models/genericBoundaryConditionsScript.js","../src/models/frontPropagationScript.js","../src/methods/frontalSolverScript.js","../src/methods/newtonRaphsonScript.js","../src/FEAScript.js","../src/models/generalFormPDEScript.js","../src/readers/gmshReaderScript.js","../src/visualization/plotSolutionScript.js","../src/workers/workerScript.js","../src/index.js"],"sourcesContent":["/**\n * ════════════════════════════════════════════════════════════\n *  FEAScript Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.1.4 | https://feascript.com\n * ════════════════════════════════════════════════════════════\n */\n\n/**\n * Function to calculate the Euclidean norm of a vector\n * @param {array} vector - The input vector\n * @returns {number} The Euclidean norm of the vector\n */\nexport function euclideanNorm(vector) {\n  let norm = 0;\n  for (let i = 0; i < vector.length; i++) {\n    norm += vector[i] * vector[i];\n  }\n  norm = Math.sqrt(norm);\n  return norm;\n}\n","/**\n * ════════════════════════════════════════════════════════════\n *  FEAScript Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.1.4 | https://feascript.com\n * ════════════════════════════════════════════════════════════\n */\n\n// Global logging level\nlet currentLogLevel = \"basic\";\n\n/**\n * Function to set the logging system level\n * @param {string} level - Logging level (basic, debug)\n */\nexport function logSystem(level) {\n  if (level !== \"basic\" && level !== \"debug\") {\n    console.log(\n      \"%c[WARN] Invalid log level: \" + level + \". Using basic instead.\",\n      \"color: #FFC107; font-weight: bold;\"\n    ); // Yellow for warnings\n    currentLogLevel = \"basic\";\n  } else {\n    currentLogLevel = level;\n    basicLog(`Log level set to: ${level}`);\n  }\n}\n\n/**\n * Function to log debug messages - only logs if level is 'debug'\n * @param {string} message - Message to log\n */\nexport function debugLog(message) {\n  if (currentLogLevel === \"debug\") {\n    console.log(\"%c[DEBUG] \" + message, \"color: #2196F3; font-weight: bold;\");\n  }\n}\n\n/**\n * Function to log basic information - always logs\n * @param {string} message - Message to log\n */\nexport function basicLog(message) {\n  console.log(\"%c[INFO] \" + message, \"color: #4CAF50; font-weight: bold;\");\n}\n\n/**\n * Function to log error messages\n * @param {string} message - Message to log\n */\nexport function errorLog(message) {\n  console.log(\"%c[ERROR] \" + message, \"color: #F44336; font-weight: bold;\");\n}\n\n/**\n * Function to log warning messages\n * @param {string} message - Message to log\n */\nexport function warnLog(message) {\n  console.log(\"%c[WARN] \" + message, \"color: #FF9800; font-weight: bold;\");\n}\n\n/**\n * Function to handle version information and fetch the latest update date and release from GitHub\n */\nexport async function printVersionInformation() {\n  basicLog(\"Fetching latest FEAScript version information...\");\n  try {\n    const commitResponse = await fetch(\"https://api.github.com/repos/FEAScript/FEAScript/commits/main\");\n    const commitData = await commitResponse.json();\n    const latestCommitDate = new Date(commitData.commit.committer.date).toLocaleString();\n    basicLog(`Latest FEAScript update: ${latestCommitDate}`);\n    return latestCommitDate;\n  } catch (error) {\n    errorLog(\"Failed to fetch version information: \" + error);\n    return \"Version information unavailable\";\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    [\"proxy\", proxyTransferHandler],\n    [\"throw\", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case \"GET\" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction wrap(ep, target) {\n    const pendingListeners = new Map();\n    ep.addEventListener(\"message\", function handleMessage(ev) {\n        const { data } = ev;\n        if (!data || !data.id) {\n            return;\n        }\n        const resolver = pendingListeners.get(data.id);\n        if (!resolver) {\n            return;\n        }\n        try {\n            resolver(data);\n        }\n        finally {\n            pendingListeners.delete(data.id);\n        }\n    });\n    return createProxy(ep, pendingListeners, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, new Map(), {\n        type: \"RELEASE\" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, pendingListeners, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    pendingListeners.clear();\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, pendingListeners, {\n                    type: \"GET\" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, pendingListeners, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"SET\" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, pendingListeners, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didn’t happen.\n            if (last === \"bind\") {\n                return createProxy(ep, pendingListeners, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"APPLY\" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case \"HANDLER\" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, pendingListeners, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        pendingListeners.set(id, resolve);\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join(\"-\");\n}\n\nexport { createEndpoint, expose, finalizer, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n","/**\n * ════════════════════════════════════════════════════════════\n *  FEAScript Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.1.4 | https://feascript.com\n * ════════════════════════════════════════════════════════════\n */\n\n// Internal imports\nimport { jacobiSolver } from \"./jacobiSolverScript.js\";\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\nimport * as Comlink from \"../vendor/comlink.mjs\";\n\n/**\n * Function to solve a system of linear equations using different solver methods\n * @param {string} solverMethod - The solver method to use (\"lusolve\" or \"jacobi\")\n * @param {Array} jacobianMatrix - The coefficient matrix\n * @param {Array} residualVector - The right-hand side vector\n * @param {object} [options] - Optional parameters for the solver, such as `maxIterations` and `tolerance`\n * @returns {object} An object containing:\n *  - solutionVector: The solution vector\n *  - converged: Boolean indicating whether the method converged (for iterative methods)\n *  - iterations: Number of iterations performed (for iterative methods)\n */\nexport function solveLinearSystem(solverMethod, jacobianMatrix, residualVector, options = {}) {\n\n  // Extract options\n  const { maxIterations = 10000, tolerance = 1e-4 } = options;\n\n  let solutionVector = [];\n  let converged = true;\n  let iterations = 0;\n\n  // Solve the linear system based on the specified solver method\n  basicLog(`Solving system using ${solverMethod}...`);\n  console.time(\"systemSolving\");\n\n  if (solverMethod === \"lusolve\") {\n    // Use LU decomposition method\n    const jacobianMatrixSparse = math.sparse(jacobianMatrix);\n    const luFactorization = math.slu(jacobianMatrixSparse, 1, 1); // order=1, threshold=1 for pivoting\n    let solutionMatrix = math.lusolve(luFactorization, residualVector);\n    solutionVector = math.squeeze(solutionMatrix).valueOf();\n    //solutionVector = math.lusolve(jacobianMatrix, residualVector); // In the case of a dense matrix\n  } else if (solverMethod === \"jacobi\") {\n    // Use Jacobi method\n    const initialGuess = new Array(residualVector.length).fill(0);\n    const jacobiSolverResult = jacobiSolver(jacobianMatrix, residualVector, initialGuess, {\n      maxIterations,\n      tolerance,\n    });\n\n    // Log convergence information\n    if (jacobiSolverResult.converged) {\n      debugLog(`Jacobi method converged in ${jacobiSolverResult.iterations} iterations`);\n    } else {\n      errorLog(`Jacobi method did not converge after ${jacobiSolverResult.iterations} iterations`);\n    }\n\n    solutionVector = jacobiSolverResult.solutionVector;\n    converged = jacobiSolverResult.converged;\n    iterations = jacobiSolverResult.iterations;\n  } else {\n    errorLog(`Unknown solver method: ${solverMethod}`);\n  }\n\n  console.timeEnd(\"systemSolving\");\n  basicLog(\"System solved successfully\");\n\n  return { solutionVector, converged, iterations };\n}\n\n// Helper to lazily create a default WebGPU compute engine (Comlink + worker)\nasync function createDefaultComputeEngine() {\n  const worker = new Worker(new URL(\"../workers/webgpuWorkerScript.js\", import.meta.url), {\n    type: \"module\",\n  });\n  const computeEngine = Comlink.wrap(worker);\n  await computeEngine.initialize();\n  return { computeEngine, worker };\n}\n\n/**\n * Function to solve asynchronously a system of linear equations using different solver methods\n * @param {string} solverMethod - The solver method to use (e.g., \"jacobi-gpu\")\n * @param {array} jacobianMatrix - The coefficient matrix\n * @param {array} residualVector - The right-hand side vector\n * @param {object} [options] - Optional parameters for the solver, such as `maxIterations` and `tolerance`\n * @returns {Promise<object>} A promise that resolves to an object containing:\n *  - solutionVector: The solution vector\n *  - converged: Boolean indicating whether the method converged (for iterative methods)\n *  - iterations: Number of iterations performed (for iterative methods)\n */\nexport async function solveLinearSystemAsync(solverMethod, jacobianMatrix, residualVector, options = {}) {\n  \n  // Extract options\n  const { maxIterations = 10000, tolerance = 1e-4 } = options;\n\n  basicLog(`Solving system using ${solverMethod}...`);\n  console.time(\"systemSolving\");\n\n  // Normalize inputs\n  const A = Array.isArray(jacobianMatrix) ? jacobianMatrix : jacobianMatrix?.toArray?.() ?? jacobianMatrix;\n  const b = Array.isArray(residualVector) ? residualVector : residualVector?.toArray?.() ?? residualVector;\n\n  let created = null;\n  let computeEngine = null;\n\n  let solutionVector = [];\n  let converged = true;\n  let iterations;\n\n  if (solverMethod === \"jacobi-gpu\") {\n    // Spin up a worker-backed compute engine\n    created = await createDefaultComputeEngine();\n    computeEngine = created.computeEngine;\n\n    const x0 = new Array(b.length).fill(0);\n    let result;\n\n    result = await computeEngine.webgpuJacobiSolver(A, b, x0, { maxIterations, tolerance });\n    solutionVector = result.solutionVector;\n    converged = result.converged;\n    iterations = result.iterations;\n\n    // Log convergence information\n    if (converged) {\n      debugLog(`Jacobi method converged in ${iterations} iterations`);\n    } else {\n      errorLog(`Jacobi method did not converge after ${iterations} iterations`);\n    }\n  } else {\n    errorLog(`Unknown solver method: ${solverMethod}`);\n  }\n\n  console.timeEnd(\"systemSolving\");\n  basicLog(`System solved successfully (${solverMethod})`);\n\n  if (created) {\n    await computeEngine?.destroy?.().catch(() => { });\n    created.worker.terminate();\n  }\n\n  return { solutionVector, converged, iterations };\n}\n","/**\n * ════════════════════════════════════════════════════════════\n *  FEAScript Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.1.4 | https://feascript.com\n * ════════════════════════════════════════════════════════════\n */\n\n/**\n * Function to solve a system of linear equations using the Jacobi iterative method (CPU synchronous version)\n * @param {array} A - The system matrix\n * @param {array} b - The right-hand side vector\n * @param {array} x0 - Initial guess for solution vector\n * @param {object} [options] - Optional parameters for the solver, such as `maxIterations` and `tolerance`\n * @returns {object} An object containing:\n *  - solutionVector: The solution vector\n *  - iterations: The number of iterations performed\n *  - converged: Boolean indicating whether the method converged\n */\nexport function jacobiSolver(A, b, x0, options = {}) {\n  // Extract options\n  const { maxIterations, tolerance } = options;\n\n  const n = A.length;\n  let x = [...x0];\n  let xNew = new Array(n);\n\n  // Jacobi update: xNew[i] = (b[i] - sum(A[i][j] * x[j] for j != i)) / A[i][i]\n  for (let iter = 0; iter < maxIterations; iter++) {\n    for (let i = 0; i < n; i++) {\n      let sum = 0;\n      for (let j = 0; j < n; j++) {\n        if (i !== j) {\n          sum += A[i][j] * x[j];\n        }\n      }\n      xNew[i] = (b[i] - sum) / A[i][i];\n    }\n\n    // Check convergence based on maximum difference in solution vector\n    let maxDiff = 0;\n    for (let i = 0; i < n; i++) {\n      maxDiff = Math.max(maxDiff, Math.abs(xNew[i] - x[i]));\n    }\n\n    // Copy new solution for the next iteration\n    x = [...xNew];\n\n    if (maxDiff < tolerance) {\n      return { solutionVector: x, iterations: iter + 1, converged: true };\n    }\n  }\n\n  return { solutionVector: x, iterations: maxIterations, converged: false };\n}\n","/**\n * ════════════════════════════════════════════════════════════\n *  FEAScript Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.1.4 | https://feascript.com\n * ════════════════════════════════════════════════════════════\n */\n\n// Internal imports\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Class to handle basis functions and their derivatives based on element configuration\n */\nexport class BasisFunctions {\n  /**\n   * Constructor to initialize the BasisFunctions class\n   * @param {string} meshDimension - The dimension of the mesh\n   * @param {string} elementOrder - The order of elements\n   */\n  constructor({ meshDimension, elementOrder }) {\n    this.meshDimension = meshDimension;\n    this.elementOrder = elementOrder;\n  }\n\n  /**\n   * Function to calculate basis functions and their derivatives based on the dimension and order\n   * @param {number} ksi - Natural coordinate (for both 1D and 2D)\n   * @param {number} [eta] - Second natural coordinate (only for 2D elements)\n   * @returns {object} An object containing:\n   *  - basisFunction: Array of evaluated basis functions\n   *  - basisFunctionDerivKsi: Array of derivatives of basis functions with respect to ksi\n   *  - basisFunctionDerivEta: Array of derivatives of basis functions with respect to eta (only for 2D elements)\n   */\n  getBasisFunctions(ksi, eta = null) {\n    let basisFunction = [];\n    let basisFunctionDerivKsi = [];\n    let basisFunctionDerivEta = [];\n\n    if (this.meshDimension === \"1D\") {\n      if (this.elementOrder === \"linear\") {\n        // Linear basis functions for 1D elements\n        basisFunction[0] = 1 - ksi;\n        basisFunction[1] = ksi;\n\n        // Derivatives of basis functions with respect to ksi\n        basisFunctionDerivKsi[0] = -1;\n        basisFunctionDerivKsi[1] = 1;\n      } else if (this.elementOrder === \"quadratic\") {\n        // Quadratic basis functions for 1D elements\n        basisFunction[0] = 1 - 3 * ksi + 2 * ksi ** 2;\n        basisFunction[1] = 4 * ksi - 4 * ksi ** 2;\n        basisFunction[2] = -ksi + 2 * ksi ** 2;\n\n        // Derivatives of basis functions with respect to ksi\n        basisFunctionDerivKsi[0] = -3 + 4 * ksi;\n        basisFunctionDerivKsi[1] = 4 - 8 * ksi;\n        basisFunctionDerivKsi[2] = -1 + 4 * ksi;\n      }\n    } else if (this.meshDimension === \"2D\") {\n      if (eta === null) {\n        errorLog(\"Eta coordinate is required for 2D elements\");\n        return;\n      }\n\n      if (this.elementOrder === \"linear\") {\n        // Linear basis functions for 2D elements\n        function l1(c) {\n          return 1 - c;\n        }\n        function l2(c) {\n          return c;\n        }\n        function dl1() {\n          return -1;\n        }\n        function dl2() {\n          return 1;\n        }\n\n        // Evaluate basis functions at (ksi, eta)\n        basisFunction[0] = l1(ksi) * l1(eta);\n        basisFunction[1] = l1(ksi) * l2(eta);\n        basisFunction[2] = l2(ksi) * l1(eta);\n        basisFunction[3] = l2(ksi) * l2(eta);\n\n        // Derivatives with respect to ksi\n        basisFunctionDerivKsi[0] = dl1() * l1(eta);\n        basisFunctionDerivKsi[1] = dl1() * l2(eta);\n        basisFunctionDerivKsi[2] = dl2() * l1(eta);\n        basisFunctionDerivKsi[3] = dl2() * l2(eta);\n\n        // Derivatives with respect to eta\n        basisFunctionDerivEta[0] = l1(ksi) * dl1();\n        basisFunctionDerivEta[1] = l1(ksi) * dl2();\n        basisFunctionDerivEta[2] = l2(ksi) * dl1();\n        basisFunctionDerivEta[3] = l2(ksi) * dl2();\n      } else if (this.elementOrder === \"quadratic\") {\n        // Quadratic basis functions for 2D elements\n        function l1(c) {\n          return 2 * c ** 2 - 3 * c + 1;\n        }\n        function l2(c) {\n          return -4 * c ** 2 + 4 * c;\n        }\n        function l3(c) {\n          return 2 * c ** 2 - c;\n        }\n        function dl1(c) {\n          return 4 * c - 3;\n        }\n        function dl2(c) {\n          return -8 * c + 4;\n        }\n        function dl3(c) {\n          return 4 * c - 1;\n        }\n\n        // Evaluate basis functions at (ksi, eta)\n        basisFunction[0] = l1(ksi) * l1(eta);\n        basisFunction[1] = l1(ksi) * l2(eta);\n        basisFunction[2] = l1(ksi) * l3(eta);\n        basisFunction[3] = l2(ksi) * l1(eta);\n        basisFunction[4] = l2(ksi) * l2(eta);\n        basisFunction[5] = l2(ksi) * l3(eta);\n        basisFunction[6] = l3(ksi) * l1(eta);\n        basisFunction[7] = l3(ksi) * l2(eta);\n        basisFunction[8] = l3(ksi) * l3(eta);\n\n        // Derivatives with respect to ksi\n        basisFunctionDerivKsi[0] = dl1(ksi) * l1(eta);\n        basisFunctionDerivKsi[1] = dl1(ksi) * l2(eta);\n        basisFunctionDerivKsi[2] = dl1(ksi) * l3(eta);\n        basisFunctionDerivKsi[3] = dl2(ksi) * l1(eta);\n        basisFunctionDerivKsi[4] = dl2(ksi) * l2(eta);\n        basisFunctionDerivKsi[5] = dl2(ksi) * l3(eta);\n        basisFunctionDerivKsi[6] = dl3(ksi) * l1(eta);\n        basisFunctionDerivKsi[7] = dl3(ksi) * l2(eta);\n        basisFunctionDerivKsi[8] = dl3(ksi) * l3(eta);\n\n        // Derivatives with respect to eta\n        basisFunctionDerivEta[0] = l1(ksi) * dl1(eta);\n        basisFunctionDerivEta[1] = l1(ksi) * dl2(eta);\n        basisFunctionDerivEta[2] = l1(ksi) * dl3(eta);\n        basisFunctionDerivEta[3] = l2(ksi) * dl1(eta);\n        basisFunctionDerivEta[4] = l2(ksi) * dl2(eta);\n        basisFunctionDerivEta[5] = l2(ksi) * dl3(eta);\n        basisFunctionDerivEta[6] = l3(ksi) * dl1(eta);\n        basisFunctionDerivEta[7] = l3(ksi) * dl2(eta);\n        basisFunctionDerivEta[8] = l3(ksi) * dl3(eta);\n      }\n    }\n\n    return { basisFunction, basisFunctionDerivKsi, basisFunctionDerivEta };\n  }\n}\n","/**\n * ════════════════════════════════════════════════════════════\n *  FEAScript Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.1.4 | https://feascript.com\n * ════════════════════════════════════════════════════════════\n */\n\n// Internal imports\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Basic structure for the mesh\n */\nexport class Mesh {\n  /**\n   * Constructor to initialize the Mesh class\n   * @param {object} config - Configuration object for the mesh\n   * @param {number} [config.numElementsX] - Number of elements along the x-axis (required for geometry-based mesh)\n   * @param {number} [config.maxX] - Maximum x-coordinate of the mesh (required for geometry-based mesh)\n   * @param {number} [config.numElementsY=1] - Number of elements along the y-axis (for 1D meshes)\n   * @param {number} [config.maxY=0] - Maximum y-coordinate of the mesh (for 1D meshes)\n   * @param {string} [config.meshDimension='2D'] - The dimension of the mesh, either 1D or 2D\n   * @param {string} [config.elementOrder='linear'] - The order of elements, either 'linear' or 'quadratic'\n   * @param {object} [config.parsedMesh=null] - Optional pre-parsed mesh data\n   */\n  constructor({\n    numElementsX = null,\n    maxX = null,\n    numElementsY = null,\n    maxY = null,\n    meshDimension = null,\n    elementOrder = \"linear\",\n    parsedMesh = null,\n  }) {\n    this.numElementsX = numElementsX;\n    this.numElementsY = numElementsY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n    this.meshDimension = meshDimension;\n    this.elementOrder = elementOrder;\n    this.parsedMesh = parsedMesh;\n\n    this.boundaryElementsProcessed = false;\n\n    if (this.parsedMesh) {\n      basicLog(\"Using pre-parsed mesh from gmshReader data for mesh generation.\");\n      this.parseMeshFromGmsh();\n    }\n  }\n\n  /**\n   * Method to parse the mesh from the GMSH format to the FEAScript format\n   */\n  parseMeshFromGmsh() {\n    if (!this.parsedMesh.nodalNumbering) {\n      errorLog(\"No valid nodal numbering found in the parsed mesh.\");\n    }\n\n    if (\n      typeof this.parsedMesh.nodalNumbering === \"object\" &&\n      !Array.isArray(this.parsedMesh.nodalNumbering)\n    ) {\n      // Store the nodal numbering structure before converting\n      const quadElements = this.parsedMesh.nodalNumbering.quadElements || [];\n      const triangleElements = this.parsedMesh.nodalNumbering.triangleElements || [];\n\n      debugLog(\n        \"Initial parsed mesh nodal numbering from GMSH format: \" +\n          JSON.stringify(this.parsedMesh.nodalNumbering)\n      );\n\n      // Check if it has quadElements or triangleElements structure from gmshReader\n      if (this.parsedMesh.elementTypes[3] || this.parsedMesh.elementTypes[10]) {\n        // Map nodal numbering from GMSH format to FEAScript format for quad elements\n        const mappedNodalNumbering = [];\n\n        for (let elemIdx = 0; elemIdx < quadElements.length; elemIdx++) {\n          const gmshNodes = quadElements[elemIdx];\n          const feaScriptNodes = new Array(gmshNodes.length);\n\n          // Check for element type based on number of nodes\n          if (gmshNodes.length === 4) {\n            // Simple mapping for linear quad elements (4 nodes)\n            // GMSH:         FEAScript:\n            // 3 --- 2       1 --- 3\n            // |     |  -->  |     |\n            // 0 --- 1       0 --- 2\n\n            feaScriptNodes[0] = gmshNodes[0]; // 0 -> 0\n            feaScriptNodes[1] = gmshNodes[3]; // 3 -> 1\n            feaScriptNodes[2] = gmshNodes[1]; // 1 -> 2\n            feaScriptNodes[3] = gmshNodes[2]; // 2 -> 3\n          } else if (gmshNodes.length === 9) {\n            // Mapping for quadratic quad elements (9 nodes)\n            // GMSH:         FEAScript:\n            // 3--6--2       2--5--8\n            // |     |       |     |\n            // 7  8  5  -->  1  4  7\n            // |     |       |     |\n            // 0--4--1       0--3--6\n\n            feaScriptNodes[0] = gmshNodes[0]; // 0 -> 0\n            feaScriptNodes[1] = gmshNodes[7]; // 7 -> 1\n            feaScriptNodes[2] = gmshNodes[3]; // 3 -> 2\n            feaScriptNodes[3] = gmshNodes[4]; // 4 -> 3\n            feaScriptNodes[4] = gmshNodes[8]; // 8 -> 4\n            feaScriptNodes[5] = gmshNodes[6]; // 6 -> 5\n            feaScriptNodes[6] = gmshNodes[1]; // 1 -> 6\n            feaScriptNodes[7] = gmshNodes[5]; // 5 -> 7\n            feaScriptNodes[8] = gmshNodes[2]; // 2 -> 8\n          }\n\n          mappedNodalNumbering.push(feaScriptNodes);\n        }\n\n        this.parsedMesh.nodalNumbering = mappedNodalNumbering;\n      } else if (this.parsedMesh.elementTypes[2]) {\n        errorLog(\"Element type is neither triangle nor quad; mapping for this type is not implemented yet.\");\n      }\n\n      debugLog(\n        \"Nodal numbering after mapping from GMSH to FEAScript format: \" +\n          JSON.stringify(this.parsedMesh.nodalNumbering)\n      );\n\n      // Process boundary elements if they exist and if physical property mapping exists\n      if (this.parsedMesh.physicalPropMap && this.parsedMesh.boundaryElements) {\n        // Check if boundary elements need to be processed\n        if (\n          Array.isArray(this.parsedMesh.boundaryElements) &&\n          this.parsedMesh.boundaryElements.length > 0 &&\n          this.parsedMesh.boundaryElements[0] === undefined\n        ) {\n          // Create a new array without the empty first element\n          const fixedBoundaryElements = [];\n          for (let i = 1; i < this.parsedMesh.boundaryElements.length; i++) {\n            if (this.parsedMesh.boundaryElements[i]) {\n              fixedBoundaryElements.push(this.parsedMesh.boundaryElements[i]);\n            }\n          }\n          this.parsedMesh.boundaryElements = fixedBoundaryElements;\n        }\n\n        // If boundary node pairs exist but boundary elements haven't been processed\n        if (this.parsedMesh.boundaryNodePairs && !this.parsedMesh.boundaryElementsProcessed) {\n          // Reset boundary elements array\n          this.parsedMesh.boundaryElements = [];\n\n          // Process each physical property from the Gmsh file\n          this.parsedMesh.physicalPropMap.forEach((prop) => {\n            // Only process 1D physical entities (boundary lines)\n            if (prop.dimension === 1) {\n              // Get all node pairs for this boundary\n              const boundaryNodePairs = this.parsedMesh.boundaryNodePairs[prop.tag] || [];\n\n              if (boundaryNodePairs.length > 0) {\n                // Initialize array for this boundary tag\n                if (!this.parsedMesh.boundaryElements[prop.tag]) {\n                  this.parsedMesh.boundaryElements[prop.tag] = [];\n                }\n\n                // For each boundary line segment (defined by a pair of nodes)\n                boundaryNodePairs.forEach((nodesPair) => {\n                  const node1 = nodesPair[0]; // First node in the pair\n                  const node2 = nodesPair[1]; // Second node in the pair\n\n                  debugLog(\n                    `Processing boundary node pair: [${node1}, ${node2}] for boundary ${prop.tag} (${\n                      prop.name || \"unnamed\"\n                    })`\n                  );\n\n                  // Search through all elements to find which one contains both nodes\n                  let foundElement = false;\n\n                  // Loop through all elements in the mesh\n                  for (let elemIdx = 0; elemIdx < this.parsedMesh.nodalNumbering.length; elemIdx++) {\n                    const elemNodes = this.parsedMesh.nodalNumbering[elemIdx];\n\n                    // For linear quadrilateral linear elements (4 nodes)\n                    if (elemNodes.length === 4) {\n                      // Check if both boundary nodes are in this element\n                      if (elemNodes.includes(node1) && elemNodes.includes(node2)) {\n                        // Find which side of the element these nodes form\n                        let side;\n\n                        const node1Index = elemNodes.indexOf(node1);\n                        const node2Index = elemNodes.indexOf(node2);\n\n                        debugLog(\n                          `  Found element ${elemIdx} containing boundary nodes. Element nodes: [${elemNodes.join(\n                            \", \"\n                          )}]`\n                        );\n                        debugLog(\n                          `  Node ${node1} is at index ${node1Index}, Node ${node2} is at index ${node2Index} in the element`\n                        );\n\n                        // Based on FEAScript linear quadrilateral numbering:\n                        // 1 --- 3\n                        // |     |\n                        // 0 --- 2\n\n                        if (\n                          (node1Index === 0 && node2Index === 2) ||\n                          (node1Index === 2 && node2Index === 0)\n                        ) {\n                          side = 0; // Bottom side\n                          debugLog(`  These nodes form the BOTTOM side (${side}) of element ${elemIdx}`);\n                        } else if (\n                          (node1Index === 0 && node2Index === 1) ||\n                          (node1Index === 1 && node2Index === 0)\n                        ) {\n                          side = 1; // Left side\n                          debugLog(`  These nodes form the LEFT side (${side}) of element ${elemIdx}`);\n                        } else if (\n                          (node1Index === 1 && node2Index === 3) ||\n                          (node1Index === 3 && node2Index === 1)\n                        ) {\n                          side = 2; // Top side\n                          debugLog(`  These nodes form the TOP side (${side}) of element ${elemIdx}`);\n                        } else if (\n                          (node1Index === 2 && node2Index === 3) ||\n                          (node1Index === 3 && node2Index === 2)\n                        ) {\n                          side = 3; // Right side\n                          debugLog(`  These nodes form the RIGHT side (${side}) of element ${elemIdx}`);\n                        }\n\n                        // Add the element and side to the boundary elements array\n                        this.parsedMesh.boundaryElements[prop.tag].push([elemIdx, side]);\n                        debugLog(\n                          `  Added element-side pair [${elemIdx}, ${side}] to boundary tag ${prop.tag}`\n                        );\n                        foundElement = true;\n                        break;\n                      }\n                    } else if (elemNodes.length === 9) {\n                      // For quadratic quadrilateral elements (9 nodes)\n                      // Check if both boundary nodes are in this element\n                      if (elemNodes.includes(node1) && elemNodes.includes(node2)) {\n                        // Find which side of the element these nodes form\n                        let side;\n\n                        const node1Index = elemNodes.indexOf(node1);\n                        const node2Index = elemNodes.indexOf(node2);\n\n                        debugLog(\n                          `  Found element ${elemIdx} containing boundary nodes. Element nodes: [${elemNodes.join(\n                            \", \"\n                          )}]`\n                        );\n                        debugLog(\n                          `  Node ${node1} is at index ${node1Index}, Node ${node2} is at index ${node2Index} in the element`\n                        );\n\n                        // Based on FEAScript quadratic quadrilateral numbering:\n                        // 2--5--8\n                        // |     |\n                        // 1  4  7\n                        // |     |\n                        // 0--3--6\n\n                        // TODO: Transform into dictionaries for better readability\n                        if (\n                          (node1Index === 0 && node2Index === 6) ||\n                          (node1Index === 6 && node2Index === 0) ||\n                          (node1Index === 0 && node2Index === 3) ||\n                          (node1Index === 3 && node2Index === 0) ||\n                          (node1Index === 3 && node2Index === 6) ||\n                          (node1Index === 6 && node2Index === 3)\n                        ) {\n                          side = 0; // Bottom side (nodes 0, 3, 6)\n                          debugLog(`  These nodes form the BOTTOM side (${side}) of element ${elemIdx}`);\n                        } else if (\n                          (node1Index === 0 && node2Index === 2) ||\n                          (node1Index === 2 && node2Index === 0) ||\n                          (node1Index === 0 && node2Index === 1) ||\n                          (node1Index === 1 && node2Index === 0) ||\n                          (node1Index === 1 && node2Index === 2) ||\n                          (node1Index === 2 && node2Index === 1)\n                        ) {\n                          side = 1; // Left side (nodes 0, 1, 2)\n                          debugLog(`  These nodes form the LEFT side (${side}) of element ${elemIdx}`);\n                        } else if (\n                          (node1Index === 2 && node2Index === 8) ||\n                          (node1Index === 8 && node2Index === 2) ||\n                          (node1Index === 2 && node2Index === 5) ||\n                          (node1Index === 5 && node2Index === 2) ||\n                          (node1Index === 5 && node2Index === 8) ||\n                          (node1Index === 8 && node2Index === 5)\n                        ) {\n                          side = 2; // Top side (nodes 2, 5, 8)\n                          debugLog(`  These nodes form the TOP side (${side}) of element ${elemIdx}`);\n                        } else if (\n                          (node1Index === 6 && node2Index === 8) ||\n                          (node1Index === 8 && node2Index === 6) ||\n                          (node1Index === 6 && node2Index === 7) ||\n                          (node1Index === 7 && node2Index === 6) ||\n                          (node1Index === 7 && node2Index === 8) ||\n                          (node1Index === 8 && node2Index === 7)\n                        ) {\n                          side = 3; // Right side (nodes 6, 7, 8)\n                          debugLog(`  These nodes form the RIGHT side (${side}) of element ${elemIdx}`);\n                        }\n\n                        // Add the element and side to the boundary elements array\n                        this.parsedMesh.boundaryElements[prop.tag].push([elemIdx, side]);\n                        debugLog(\n                          `  Added element-side pair [${elemIdx}, ${side}] to boundary tag ${prop.tag}`\n                        );\n                        foundElement = true;\n                        break;\n                      }\n                    }\n                  }\n\n                  if (!foundElement) {\n                    errorLog(\n                      `Could not find element containing boundary nodes ${node1} and ${node2}. Boundary may be incomplete.`\n                    );\n                  }\n                });\n              }\n            }\n          });\n\n          // Mark as processed\n          this.boundaryElementsProcessed = true;\n\n          // Fix boundary elements array - remove undefined entries\n          if (\n            this.parsedMesh.boundaryElements.length > 0 &&\n            this.parsedMesh.boundaryElements[0] === undefined\n          ) {\n            const fixedBoundaryElements = [];\n            for (let i = 1; i < this.parsedMesh.boundaryElements.length; i++) {\n              if (this.parsedMesh.boundaryElements[i]) {\n                fixedBoundaryElements.push(this.parsedMesh.boundaryElements[i]);\n              }\n            }\n            this.parsedMesh.boundaryElements = fixedBoundaryElements;\n          }\n        }\n      }\n    }\n\n    return this.parsedMesh;\n  }\n}\n\nexport class Mesh1D extends Mesh {\n  /**\n   * Constructor to initialize the 1D mesh\n   * @param {object} config - Configuration object for the 1D mesh\n   * @param {number} [config.numElementsX] - Number of elements along the x-axis (required for geometry-based mesh)\n   * @param {number} [config.maxX] - Maximum x-coordinate of the mesh (required for geometry-based mesh)\n   * @param {string} [config.elementOrder='linear'] - The order of elements, either 'linear' or 'quadratic'\n   * @param {object} [config.parsedMesh=null] - Optional pre-parsed mesh data\n   */\n  constructor({ numElementsX = null, maxX = null, elementOrder = \"linear\", parsedMesh = null }) {\n    super({\n      numElementsX,\n      maxX,\n      numElementsY: 1,\n      maxY: 0,\n      meshDimension: \"1D\",\n      elementOrder,\n      parsedMesh,\n    });\n\n    if (this.numElementsX === null || this.maxX === null) {\n      errorLog(\"numElementsX and maxX are required parameters when generating a 1D mesh from geometry\");\n    }\n  }\n\n  generateMesh() {\n    let nodesXCoordinates = [];\n    const xStart = 0;\n    let totalNodesX, deltaX;\n\n    if (this.elementOrder === \"linear\") {\n      totalNodesX = this.numElementsX + 1;\n      deltaX = (this.maxX - xStart) / this.numElementsX;\n\n      nodesXCoordinates[0] = xStart;\n      for (let nodeIndex = 1; nodeIndex < totalNodesX; nodeIndex++) {\n        nodesXCoordinates[nodeIndex] = nodesXCoordinates[nodeIndex - 1] + deltaX;\n      }\n    } else if (this.elementOrder === \"quadratic\") {\n      totalNodesX = 2 * this.numElementsX + 1;\n      deltaX = (this.maxX - xStart) / this.numElementsX;\n\n      nodesXCoordinates[0] = xStart;\n      for (let nodeIndex = 1; nodeIndex < totalNodesX; nodeIndex++) {\n        nodesXCoordinates[nodeIndex] = nodesXCoordinates[nodeIndex - 1] + deltaX / 2;\n      }\n    }\n    // Generate nodal numbering (NOP) array\n    const nodalNumbering = this.generate1DNodalNumbering(this.numElementsX, totalNodesX, this.elementOrder);\n    // Find boundary elements\n    const boundaryElements = this.findBoundaryElements();\n\n    debugLog(\"Generated node X coordinates: \" + JSON.stringify(nodesXCoordinates));\n\n    // Return x coordinates of nodes, total nodes, NOP array, and boundary elements\n    return {\n      nodesXCoordinates,\n      totalNodesX,\n      nodalNumbering,\n      boundaryElements,\n    };\n  }\n\n  /**\n   * Function to generate the nodal numbering (NOP) array for a structured mesh\n   * This array represents the connectivity between elements and their corresponding nodes\n   * @param {number} numElementsX - Number of elements along the x-axis\n   * @param {number} totalNodesX - Total number of nodes along the x-axis\n   * @param {string} elementOrder - The order of elements, either 'linear' or 'quadratic'\n   * @returns {array} NOP - A two-dimensional array which represents the element-to-node connectivity for the entire mesh\n   */\n  generate1DNodalNumbering(numElementsX, totalNodesX, elementOrder) {\n    // TODO: The totalNodesX is not used in the original function. Verify if\n    // there is a multiple calculation on the totalNodes.\n\n    let elementIndex = 0;\n    let nop = [];\n\n    if (elementOrder === \"linear\") {\n      /**\n       * Linear 1D elements with the following nodes representation:\n       *\n       *   1 --- 2\n       *\n       */\n      for (let elementIndex = 0; elementIndex < numElementsX; elementIndex++) {\n        nop[elementIndex] = [];\n        for (let nodeIndex = 1; nodeIndex <= 2; nodeIndex++) {\n          nop[elementIndex][nodeIndex - 1] = elementIndex + nodeIndex;\n        }\n      }\n    } else if (elementOrder === \"quadratic\") {\n      /**\n       * Quadratic 1D elements with the following nodes representation:\n       *\n       *   1--2--3\n       *\n       */\n      let columnCounter = 0;\n      for (let elementIndex = 0; elementIndex < numElementsX; elementIndex++) {\n        nop[elementIndex] = [];\n        for (let nodeIndex = 1; nodeIndex <= 3; nodeIndex++) {\n          nop[elementIndex][nodeIndex - 1] = elementIndex + nodeIndex + columnCounter;\n        }\n        columnCounter += 1;\n      }\n    }\n\n    return nop;\n  }\n\n  /**\n   * Function to find the elements that belong to each boundary of a domain\n   * @returns {array} An array containing arrays of elements and their adjacent boundary side for each boundary\n   * Each element in the array is of the form [elementIndex, side], where 'side' indicates which side\n   * of the reference element is in contact with the physical boundary:\n   *\n   * For 1D domains (line segments):\n   * 0 - Left node of reference element (maps to physical left endpoint)\n   * 1 - Right node of reference element (maps to physical right endpoint)\n   */\n  findBoundaryElements() {\n    const boundaryElements = [];\n    const maxSides = 2; // For 1D, we only have two sides (left and right)\n    for (let sideIndex = 0; sideIndex < maxSides; sideIndex++) {\n      boundaryElements.push([]);\n    }\n\n    // Left boundary (element 0, side 0)\n    boundaryElements[0].push([0, 0]);\n\n    // Right boundary (last element, side 1)\n    boundaryElements[1].push([this.numElementsX - 1, 1]);\n\n    debugLog(\"Identified boundary elements by side: \" + JSON.stringify(boundaryElements));\n    this.boundaryElementsProcessed = true;\n    return boundaryElements;\n  }\n}\n\nexport class Mesh2D extends Mesh {\n  /**\n   * Constructor to initialize the 2D mesh\n   * @param {object} config - Configuration object for the 2D mesh\n   * @param {number} [config.numElementsX] - Number of elements along the x-axis (required for geometry-based mesh)\n   * @param {number} [config.maxX] - Maximum x-coordinate of the mesh (required for geometry-based mesh)\n   * @param {number} [config.numElementsY] - Number of elements along the y-axis (required for geometry-based mesh)\n   * @param {number} [config.maxY] - Maximum y-coordinate of the mesh (required for geometry-based mesh)\n   * @param {string} [config.elementOrder='linear'] - The order of elements, either 'linear' or 'quadratic'\n   * @param {object} [config.parsedMesh=null] - Optional pre-parsed mesh data\n   */\n  constructor({\n    numElementsX = null,\n    maxX = null,\n    numElementsY = null,\n    maxY = null,\n    elementOrder = \"linear\",\n    parsedMesh = null,\n  }) {\n    super({\n      numElementsX,\n      maxX,\n      numElementsY,\n      maxY,\n      meshDimension: \"2D\",\n      elementOrder,\n      parsedMesh,\n    });\n\n    // Validate geometry parameters (when not using a parsed mesh)\n    if (\n      !parsedMesh &&\n      (this.numElementsX === null || this.maxX === null || this.numElementsY === null || this.maxY === null)\n    ) {\n      errorLog(\n        \"numElementsX, maxX, numElementsY, and maxY are required parameters when generating a 2D mesh from geometry\"\n      );\n    }\n  }\n\n  generateMesh() {\n    let nodesXCoordinates = [];\n    let nodesYCoordinates = [];\n    const xStart = 0;\n    const yStart = 0;\n    let totalNodesX, totalNodesY, deltaX, deltaY;\n\n    if (this.elementOrder === \"linear\") {\n      totalNodesX = this.numElementsX + 1;\n      totalNodesY = this.numElementsY + 1;\n      deltaX = (this.maxX - xStart) / this.numElementsX;\n      deltaY = (this.maxY - yStart) / this.numElementsY;\n\n      nodesXCoordinates[0] = xStart;\n      nodesYCoordinates[0] = yStart;\n      for (let nodeIndexY = 1; nodeIndexY < totalNodesY; nodeIndexY++) {\n        nodesXCoordinates[nodeIndexY] = nodesXCoordinates[0];\n        nodesYCoordinates[nodeIndexY] = nodesYCoordinates[0] + nodeIndexY * deltaY;\n      }\n      for (let nodeIndexX = 1; nodeIndexX < totalNodesX; nodeIndexX++) {\n        const nnode = nodeIndexX * totalNodesY;\n        nodesXCoordinates[nnode] = nodesXCoordinates[0] + nodeIndexX * deltaX;\n        nodesYCoordinates[nnode] = nodesYCoordinates[0];\n        for (let nodeIndexY = 1; nodeIndexY < totalNodesY; nodeIndexY++) {\n          nodesXCoordinates[nnode + nodeIndexY] = nodesXCoordinates[nnode];\n          nodesYCoordinates[nnode + nodeIndexY] = nodesYCoordinates[nnode] + nodeIndexY * deltaY;\n        }\n      }\n    } else if (this.elementOrder === \"quadratic\") {\n      totalNodesX = 2 * this.numElementsX + 1;\n      totalNodesY = 2 * this.numElementsY + 1;\n      deltaX = (this.maxX - xStart) / this.numElementsX;\n      deltaY = (this.maxY - yStart) / this.numElementsY;\n\n      nodesXCoordinates[0] = xStart;\n      nodesYCoordinates[0] = yStart;\n      for (let nodeIndexY = 1; nodeIndexY < totalNodesY; nodeIndexY++) {\n        nodesXCoordinates[nodeIndexY] = nodesXCoordinates[0];\n        nodesYCoordinates[nodeIndexY] = nodesYCoordinates[0] + (nodeIndexY * deltaY) / 2;\n      }\n      for (let nodeIndexX = 1; nodeIndexX < totalNodesX; nodeIndexX++) {\n        const nnode = nodeIndexX * totalNodesY;\n        nodesXCoordinates[nnode] = nodesXCoordinates[0] + (nodeIndexX * deltaX) / 2;\n        nodesYCoordinates[nnode] = nodesYCoordinates[0];\n        for (let nodeIndexY = 1; nodeIndexY < totalNodesY; nodeIndexY++) {\n          nodesXCoordinates[nnode + nodeIndexY] = nodesXCoordinates[nnode];\n          nodesYCoordinates[nnode + nodeIndexY] = nodesYCoordinates[nnode] + (nodeIndexY * deltaY) / 2;\n        }\n      }\n    }\n\n    // Generate nodal numbering (NOP) array\n    const nodalNumbering = this.generate2DNodalNumbering(\n      this.numElementsX,\n      this.numElementsY,\n      totalNodesY,\n      this.elementOrder\n    );\n\n    // Find boundary elements\n    const boundaryElements = this.findBoundaryElements();\n\n    debugLog(\"Generated node X coordinates: \" + JSON.stringify(nodesXCoordinates));\n    debugLog(\"Generated node Y coordinates: \" + JSON.stringify(nodesYCoordinates));\n\n    // Return statement\n    return {\n      nodesXCoordinates,\n      nodesYCoordinates,\n      totalNodesX,\n      totalNodesY,\n      nodalNumbering,\n      boundaryElements,\n    };\n  }\n\n  /**\n   * Function to generate the nodal numbering (NOP) array for a structured mesh\n   * This array represents the connectivity between elements and their corresponding nodes\n   * @param {number} numElementsX - Number of elements along the x-axis\n   * @param {number} [numElementsY] - Number of elements along the y-axis (optional for 1D)\n   * @param {number} totalNodesX - Total number of nodes along the x-axis\n   * @param {number} [totalNodesY] - Total number of nodes along the y-axis (optional for 1D)\n   * @param {string} elementOrder - The order of elements, either 'linear' or 'quadratic'\n   * @returns {array} NOP - A two-dimensional array which represents the element-to-node connectivity for the entire mesh\n   */\n  generate2DNodalNumbering(numElementsX, numElementsY, totalNodesY, elementOrder) {\n    let elementIndex = 0;\n    let nop = [];\n\n    if (elementOrder === \"linear\") {\n      /**\n       * Linear rectangular elements with the following nodes representation:\n       *\n       *   1 --- 3\n       *   |     |\n       *   0 --- 2\n       *\n       */\n      let rowCounter = 0;\n      let columnCounter = 2;\n      for (let elementIndex = 0; elementIndex < numElementsX * numElementsY; elementIndex++) {\n        rowCounter += 1;\n        nop[elementIndex] = [];\n        nop[elementIndex][0] = elementIndex + columnCounter - 1;\n        nop[elementIndex][1] = elementIndex + columnCounter;\n        nop[elementIndex][2] = elementIndex + columnCounter + numElementsY;\n        nop[elementIndex][3] = elementIndex + columnCounter + numElementsY + 1;\n        if (rowCounter === numElementsY) {\n          columnCounter += 1;\n          rowCounter = 0;\n        }\n      }\n    } else if (elementOrder === \"quadratic\") {\n      /**\n       * Quadratic rectangular elements with the following nodes representation:\n       *\n       *   2--5--8\n       *   |     |\n       *   1  4  7\n       *   |     |\n       *   0--3--6\n       *\n       */\n      for (let elementIndexX = 1; elementIndexX <= numElementsX; elementIndexX++) {\n        for (let elementIndexY = 1; elementIndexY <= numElementsY; elementIndexY++) {\n          nop[elementIndex] = [];\n          for (let nodeIndex1 = 1; nodeIndex1 <= 3; nodeIndex1++) {\n            let nodeIndex2 = 3 * nodeIndex1 - 2;\n            nop[elementIndex][nodeIndex2 - 1] =\n              totalNodesY * (2 * elementIndexX + nodeIndex1 - 3) + 2 * elementIndexY - 1;\n            nop[elementIndex][nodeIndex2] = nop[elementIndex][nodeIndex2 - 1] + 1;\n            nop[elementIndex][nodeIndex2 + 1] = nop[elementIndex][nodeIndex2 - 1] + 2;\n          }\n          elementIndex = elementIndex + 1;\n        }\n      }\n    }\n\n    return nop;\n  }\n\n  /**\n   * Function to find the elements that belong to each boundary of a domain\n   * @returns {array} An array containing arrays of elements and their adjacent boundary side for each boundary\n   * Each element in the array is of the form [elementIndex, side], where 'side' indicates which side\n   * of the reference element is in contact with the physical boundary:\n   *\n   * For 2D domains (rectangular):\n   * 0 - Bottom side of reference element (maps to physical bottom boundary)\n   * 1 - Left side of reference element (maps to physical left boundary)\n   * 2 - Top side of reference element (maps to physical top boundary)\n   * 3 - Right side of reference element (maps to physical right boundary)\n   */\n  findBoundaryElements() {\n    const boundaryElements = [];\n    const maxSides = 4; // For 2D, we have four sides (left, right, bottom, top)\n\n    for (let sideIndex = 0; sideIndex < maxSides; sideIndex++) {\n      boundaryElements.push([]);\n    }\n\n    // TODO: Why to loop through all elements? Is it not better to loop over only the\n    // elements that are on the boundary? eg: [0, this.numElementsX - 1] on x and\n    // [0, this.numElementsY - 1] on y\n    for (let elementIndexX = 0; elementIndexX < this.numElementsX; elementIndexX++) {\n      for (let elementIndexY = 0; elementIndexY < this.numElementsY; elementIndexY++) {\n        const elementIndex = elementIndexX * this.numElementsY + elementIndexY;\n\n        // Bottom boundary\n        if (elementIndexY === 0) {\n          boundaryElements[0].push([elementIndex, 0]);\n        }\n\n        // Left boundary\n        if (elementIndexX === 0) {\n          boundaryElements[1].push([elementIndex, 1]);\n        }\n\n        // Top boundary\n        if (elementIndexY === this.numElementsY - 1) {\n          boundaryElements[2].push([elementIndex, 2]);\n        }\n\n        // Right boundary\n        if (elementIndexX === this.numElementsX - 1) {\n          boundaryElements[3].push([elementIndex, 3]);\n        }\n      }\n    }\n\n    debugLog(\"Identified boundary elements by side: \" + JSON.stringify(boundaryElements));\n    this.boundaryElementsProcessed = true;\n    return boundaryElements;\n  }\n}\n","/**\n * ════════════════════════════════════════════════════════════\n *  FEAScript Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.1.4 | https://feascript.com\n * ════════════════════════════════════════════════════════════\n */\n\n/**\n * Class to handle numerical integration using Gauss quadrature\n */\nexport class NumericalIntegration {\n  /**\n   * Constructor to initialize the NumericalIntegration class\n   * @param {string} meshDimension - The dimension of the mesh\n   * @param {string} elementOrder - The order of elements\n   */\n  constructor({ meshDimension, elementOrder }) {\n    this.meshDimension = meshDimension;\n    this.elementOrder = elementOrder;\n  }\n\n  /**\n   * Function to return Gauss points and weights based on element configuration\n   * @returns {object} An object containing:\n   *  - gaussPoints: Array of Gauss points\n   *  - gaussWeights: Array of Gauss weights\n   */\n  getGaussPointsAndWeights() {\n    let gaussPoints = []; // Gauss points\n    let gaussWeights = []; // Gauss weights\n\n    if (this.elementOrder === \"linear\") {\n      // For linear elements, use 1-point Gauss quadrature\n      gaussPoints[0] = 0.5;\n      gaussWeights[0] = 1;\n    } else if (this.elementOrder === \"quadratic\") {\n      // For quadratic elements, use 3-point Gauss quadrature\n      gaussPoints[0] = (1 - Math.sqrt(3 / 5)) / 2;\n      gaussPoints[1] = 0.5;\n      gaussPoints[2] = (1 + Math.sqrt(3 / 5)) / 2;\n      gaussWeights[0] = 5 / 18;\n      gaussWeights[1] = 8 / 18;\n      gaussWeights[2] = 5 / 18;\n    }\n\n    return { gaussPoints, gaussWeights };\n  }\n}\n","/**\n * ════════════════════════════════════════════════════════════\n *  FEAScript Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.1.4 | https://feascript.com\n * ════════════════════════════════════════════════════════════\n */\n\nimport { BasisFunctions } from \"./basisFunctionsScript.js\";\nimport { Mesh1D, Mesh2D } from \"./meshGenerationScript.js\";\nimport { NumericalIntegration } from \"../methods/numericalIntegrationScript.js\";\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Function to prepare the mesh for finite element analysis\n * @param {object} meshConfig - Object containing computational mesh details\n * @returns {object} An object containing all mesh-related data\n */\nexport function prepareMesh(meshConfig) {\n  const { meshDimension, numElementsX, numElementsY, maxX, maxY, elementOrder, parsedMesh } = meshConfig;\n\n  // Create a new instance of the Mesh class\n  let mesh;\n  if (meshDimension === \"1D\") {\n    mesh = new Mesh1D({ numElementsX, maxX, elementOrder, parsedMesh });\n  } else if (meshDimension === \"2D\") {\n    mesh = new Mesh2D({ numElementsX, maxX, numElementsY, maxY, elementOrder, parsedMesh });\n  } else {\n    errorLog(\"Mesh dimension must be either '1D' or '2D'.\");\n  }\n\n  // Use the parsed mesh in case it was already passed with Gmsh format\n  const nodesCoordinatesAndNumbering = mesh.boundaryElementsProcessed ? mesh.parsedMesh : mesh.generateMesh();\n\n  // Extract nodes coordinates and nodal numbering (NOP) from the mesh data\n  let nodesXCoordinates = nodesCoordinatesAndNumbering.nodesXCoordinates;\n  let nodesYCoordinates = nodesCoordinatesAndNumbering.nodesYCoordinates;\n  let totalNodesX = nodesCoordinatesAndNumbering.totalNodesX;\n  let totalNodesY = nodesCoordinatesAndNumbering.totalNodesY;\n  let nop = nodesCoordinatesAndNumbering.nodalNumbering;\n  let boundaryElements = nodesCoordinatesAndNumbering.boundaryElements;\n\n  // Check the mesh type\n  const isParsedMesh = parsedMesh !== undefined && parsedMesh !== null;\n\n  // Calculate totalElements and totalNodes based on mesh type\n  let totalElements, totalNodes;\n\n  if (isParsedMesh) {\n    totalElements = nop.length; // Number of elements is the length of the nodal numbering array\n    totalNodes = nodesXCoordinates.length; // Number of nodes is the length of the coordinates array\n    debugLog(`Using parsed mesh with ${totalElements} elements and ${totalNodes} nodes`);\n  } else {\n    // For structured mesh, calculate based on dimensions\n    totalElements = numElementsX * (meshDimension === \"2D\" ? numElementsY : 1);\n    totalNodes = totalNodesX * (meshDimension === \"2D\" ? totalNodesY : 1);\n    debugLog(`Using mesh generated from geometry with ${totalElements} elements and ${totalNodes} nodes`);\n  }\n\n  return {\n    nodesXCoordinates,\n    nodesYCoordinates,\n    totalNodesX,\n    totalNodesY,\n    nop,\n    boundaryElements,\n    totalElements,\n    totalNodes,\n    meshDimension,\n    elementOrder,\n  };\n}\n\n/**\n * Function to initialize the FEA matrices and numerical tools\n * @param {object} meshData - Object containing mesh data from prepareMesh()\n * @returns {object} An object containing initialized matrices and numerical tools\n */\nexport function initializeFEA(meshData) {\n  const { totalNodes, nop, meshDimension, elementOrder } = meshData;\n\n  // Initialize variables for matrix assembly\n  let residualVector = [];\n  let jacobianMatrix = [];\n  let localToGlobalMap = [];\n\n  // Initialize jacobianMatrix and residualVector arrays\n  for (let nodeIndex = 0; nodeIndex < totalNodes; nodeIndex++) {\n    residualVector[nodeIndex] = 0;\n    jacobianMatrix.push([]);\n    for (let colIndex = 0; colIndex < totalNodes; colIndex++) {\n      jacobianMatrix[nodeIndex][colIndex] = 0;\n    }\n  }\n\n  // Initialize the BasisFunctions class\n  const basisFunctions = new BasisFunctions({\n    meshDimension,\n    elementOrder,\n  });\n\n  // Initialize the NumericalIntegration class\n  const numericalIntegration = new NumericalIntegration({\n    meshDimension,\n    elementOrder,\n  });\n\n  // Calculate Gauss points and weights\n  let gaussPointsAndWeights = numericalIntegration.getGaussPointsAndWeights();\n  let gaussPoints = gaussPointsAndWeights.gaussPoints;\n  let gaussWeights = gaussPointsAndWeights.gaussWeights;\n\n  // Determine the number of nodes in the reference element based on the first element in the nop array\n  const numNodes = nop[0].length;\n\n  return {\n    residualVector,\n    jacobianMatrix,\n    localToGlobalMap,\n    basisFunctions,\n    gaussPoints,\n    gaussWeights,\n    numNodes,\n  };\n}\n\n/**\n * Function to perform isoparametric mapping for 1D elements\n * @param {object} params - Parameters for the mapping\n * @returns {object} An object containing the mapped data\n */\nexport function performIsoparametricMapping1D(params) {\n  const { basisFunction, basisFunctionDerivKsi, nodesXCoordinates, localToGlobalMap, numNodes } = params;\n\n  let xCoordinates = 0;\n  let ksiDerivX = 0;\n\n  // Isoparametric mapping\n  for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n    xCoordinates += nodesXCoordinates[localToGlobalMap[localNodeIndex]] * basisFunction[localNodeIndex];\n    ksiDerivX += nodesXCoordinates[localToGlobalMap[localNodeIndex]] * basisFunctionDerivKsi[localNodeIndex];\n  }\n  let detJacobian = ksiDerivX;\n\n  // Compute x-derivative of basis functions\n  let basisFunctionDerivX = [];\n  for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n    basisFunctionDerivX[localNodeIndex] = basisFunctionDerivKsi[localNodeIndex] / detJacobian;\n  }\n\n  return {\n    xCoordinates,\n    detJacobian,\n    basisFunctionDerivX,\n  };\n}\n\n/**\n * Function to perform isoparametric mapping for 2D elements\n * @param {object} params - Parameters for the mapping\n * @returns {object} An object containing the mapped data\n */\nexport function performIsoparametricMapping2D(params) {\n  const {\n    basisFunction,\n    basisFunctionDerivKsi,\n    basisFunctionDerivEta,\n    nodesXCoordinates,\n    nodesYCoordinates,\n    localToGlobalMap,\n    numNodes,\n  } = params;\n\n  let xCoordinates = 0;\n  let yCoordinates = 0;\n  let ksiDerivX = 0;\n  let etaDerivX = 0;\n  let ksiDerivY = 0;\n  let etaDerivY = 0;\n\n  // Isoparametric mapping\n  for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n    xCoordinates += nodesXCoordinates[localToGlobalMap[localNodeIndex]] * basisFunction[localNodeIndex];\n    yCoordinates += nodesYCoordinates[localToGlobalMap[localNodeIndex]] * basisFunction[localNodeIndex];\n    ksiDerivX += nodesXCoordinates[localToGlobalMap[localNodeIndex]] * basisFunctionDerivKsi[localNodeIndex];\n    etaDerivX += nodesXCoordinates[localToGlobalMap[localNodeIndex]] * basisFunctionDerivEta[localNodeIndex];\n    ksiDerivY += nodesYCoordinates[localToGlobalMap[localNodeIndex]] * basisFunctionDerivKsi[localNodeIndex];\n    etaDerivY += nodesYCoordinates[localToGlobalMap[localNodeIndex]] * basisFunctionDerivEta[localNodeIndex];\n  }\n  let detJacobian = ksiDerivX * etaDerivY - etaDerivX * ksiDerivY;\n\n  // Compute x-derivative and y-derivative of basis functions\n  let basisFunctionDerivX = [];\n  let basisFunctionDerivY = [];\n  for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n    // The x-derivative of the n basis function\n    basisFunctionDerivX[localNodeIndex] =\n      (etaDerivY * basisFunctionDerivKsi[localNodeIndex] -\n        ksiDerivY * basisFunctionDerivEta[localNodeIndex]) /\n      detJacobian;\n    // The y-derivative of the n basis function\n    basisFunctionDerivY[localNodeIndex] =\n      (ksiDerivX * basisFunctionDerivEta[localNodeIndex] -\n        etaDerivX * basisFunctionDerivKsi[localNodeIndex]) /\n      detJacobian;\n  }\n\n  return {\n    xCoordinates,\n    yCoordinates,\n    detJacobian,\n    basisFunctionDerivX,\n    basisFunctionDerivY,\n  };\n}\n","/**\n * ════════════════════════════════════════════════════════════\n *  FEAScript Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.1.4 | https://feascript.com\n * ════════════════════════════════════════════════════════════\n */\n\n// Internal imports\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Class to handle thermal boundary conditions application\n */\nexport class ThermalBoundaryConditions {\n  /**\n   * Constructor to initialize the ThermalBoundaryConditions class\n   * @param {object} boundaryConditions - Object containing boundary conditions for the finite element analysis\n   * @param {array} boundaryElements - Array containing elements that belong to each boundary\n   * @param {array} nop - Nodal numbering (NOP) array representing the connectivity between elements and nodes\n   * @param {string} meshDimension - The dimension of the mesh (e.g., \"2D\")\n   * @param {string} elementOrder - The order of elements (e.g., \"linear\", \"quadratic\")\n   */\n  constructor(boundaryConditions, boundaryElements, nop, meshDimension, elementOrder) {\n    this.boundaryConditions = boundaryConditions;\n    this.boundaryElements = boundaryElements;\n    this.nop = nop;\n    this.meshDimension = meshDimension;\n    this.elementOrder = elementOrder;\n  }\n\n  /**\n   * Function to impose constant temperature boundary conditions (Dirichlet type)\n   * @param {array} residualVector - The residual vector to be modified\n   * @param {array} jacobianMatrix - The Jacobian matrix to be modified\n   *\n   * For consistency across both linear and nonlinear formulations,\n   * this project always refers to the assembled right-hand side vector\n   * as `residualVector` and the assembled system matrix as `jacobianMatrix`.\n   *\n   * In linear problems `jacobianMatrix` is equivalent to the\n   * classic stiffness/conductivity matrix and `residualVector`\n   * corresponds to the traditional load (RHS) vector.\n   */\n  imposeConstantTempBoundaryConditions(residualVector, jacobianMatrix) {\n    if (this.meshDimension === \"1D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        if (this.boundaryConditions[boundaryKey][0] === \"constantTemp\") {\n          const tempValue = this.boundaryConditions[boundaryKey][1];\n          debugLog(\n            `Boundary ${boundaryKey}: Applying constant temperature of ${tempValue} K (Dirichlet condition)`\n          );\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            if (this.elementOrder === \"linear\") {\n              const boundarySides = {\n                0: [0], // Node at the left side of the reference element\n                1: [1], // Node at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant temperature to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                // Set the residual vector to the ConstantTemp value\n                residualVector[globalNodeIndex] = tempValue;\n                // Set the Jacobian matrix row to zero\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\n                }\n                // Set the diagonal entry of the Jacobian matrix to one\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\n              });\n            } else if (this.elementOrder === \"quadratic\") {\n              const boundarySides = {\n                0: [0], // Node at the left side of the reference element\n                2: [2], // Node at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant temperature to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                // Set the residual vector to the ConstantTemp value\n                residualVector[globalNodeIndex] = tempValue;\n                // Set the Jacobian matrix row to zero\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\n                }\n                // Set the diagonal entry of the Jacobian matrix to one\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\n              });\n            }\n          });\n        }\n      });\n    } else if (this.meshDimension === \"2D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        if (this.boundaryConditions[boundaryKey][0] === \"constantTemp\") {\n          const tempValue = this.boundaryConditions[boundaryKey][1];\n          debugLog(\n            `Boundary ${boundaryKey}: Applying constant temperature of ${tempValue} K (Dirichlet condition)`\n          );\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            if (this.elementOrder === \"linear\") {\n              const boundarySides = {\n                0: [0, 2], // Nodes at the bottom side of the reference element\n                1: [0, 1], // Nodes at the left side of the reference element\n                2: [1, 3], // Nodes at the top side of the reference element\n                3: [2, 3], // Nodes at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant temperature to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                // Set the residual vector to the ConstantTemp value\n                residualVector[globalNodeIndex] = tempValue;\n                // Set the Jacobian matrix row to zero\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\n                }\n                // Set the diagonal entry of the Jacobian matrix to one\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\n              });\n            } else if (this.elementOrder === \"quadratic\") {\n              const boundarySides = {\n                0: [0, 3, 6], // Nodes at the bottom side of the reference element\n                1: [0, 1, 2], // Nodes at the left side of the reference element\n                2: [2, 5, 8], // Nodes at the top side of the reference element\n                3: [6, 7, 8], // Nodes at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant temperature to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                // Set the residual vector to the ConstantTemp value\n                residualVector[globalNodeIndex] = tempValue;\n                // Set the Jacobian matrix row to zero\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\n                }\n                // Set the diagonal entry of the Jacobian matrix to one\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\n              });\n            }\n          });\n        }\n      });\n    }\n  }\n\n  /**\n   * Function to impose constant temperature boundary conditions for the frontal solver\n   * @param {array} nodeConstraintCode - Array indicating boundary condition code for each node\n   * @param {array} boundaryValues - Array containing boundary condition values\n   */\n  imposeConstantTempBoundaryConditionsFront(nodeConstraintCode, boundaryValues) {\n    if (this.meshDimension === \"1D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        if (this.boundaryConditions[boundaryKey][0] === \"constantTemp\") {\n          const tempValue = this.boundaryConditions[boundaryKey][1];\n          debugLog(\n            `Boundary ${boundaryKey}: Applying constant temperature of ${tempValue} K (Dirichlet condition)`\n          );\n\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            if (this.elementOrder === \"linear\") {\n              const boundarySides = {\n                0: [0], // Node at the left side of the reference element\n                1: [1], // Node at the right side of the reference element\n              };\n\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant temperature to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n\n                // Set boundary condition code and value\n                nodeConstraintCode[globalNodeIndex] = 1;\n                boundaryValues[globalNodeIndex] = tempValue;\n              });\n            } else if (this.elementOrder === \"quadratic\") {\n              const boundarySides = {\n                0: [0], // Node at the left side of the reference element\n                2: [2], // Node at the right side of the reference element\n              };\n\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant temperature to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n\n                // Set boundary condition code and value\n                nodeConstraintCode[globalNodeIndex] = 1;\n                boundaryValues[globalNodeIndex] = tempValue;\n              });\n            }\n          });\n        }\n      });\n    } else if (this.meshDimension === \"2D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        if (this.boundaryConditions[boundaryKey][0] === \"constantTemp\") {\n          const tempValue = this.boundaryConditions[boundaryKey][1];\n          debugLog(\n            `Boundary ${boundaryKey}: Applying constant temperature of ${tempValue} K (Dirichlet condition)`\n          );\n\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            if (this.elementOrder === \"linear\") {\n              const boundarySides = {\n                0: [0, 2], // Nodes at the bottom side of the reference element\n                1: [0, 1], // Nodes at the left side of the reference element\n                2: [1, 3], // Nodes at the top side of the reference element\n                3: [2, 3], // Nodes at the right side of the reference element\n              };\n\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant temperature to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n\n                // Set boundary condition code and value\n                nodeConstraintCode[globalNodeIndex] = 1;\n                boundaryValues[globalNodeIndex] = tempValue;\n              });\n            } else if (this.elementOrder === \"quadratic\") {\n              const boundarySides = {\n                0: [0, 3, 6], // Nodes at the bottom side of the reference element\n                1: [0, 1, 2], // Nodes at the left side of the reference element\n                2: [2, 5, 8], // Nodes at the top side of the reference element\n                3: [6, 7, 8], // Nodes at the right side of the reference element\n              };\n\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant temperature to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n\n                // Set boundary condition code and value\n                nodeConstraintCode[globalNodeIndex] = 1;\n                boundaryValues[globalNodeIndex] = tempValue;\n              });\n            }\n          });\n        }\n      });\n    }\n  }\n\n  /**\n   * Function to impose convection boundary conditions (Robin type)\n   * @param {array} residualVector - The residual vector to be modified\n   * @param {array} jacobianMatrix - The Jacobian matrix to be modified\n   * @param {array} gaussPoints - Array of Gauss points for numerical integration\n   * @param {array} gaussWeights - Array of Gauss weights for numerical integration\n   * @param {array} nodesXCoordinates - Array of x-coordinates of nodes\n   * @param {array} nodesYCoordinates - Array of y-coordinates of nodes\n   * @param {object} basisFunctions - Object containing basis functions and their derivatives\n   */\n  imposeConvectionBoundaryConditions(\n    residualVector,\n    jacobianMatrix,\n    gaussPoints,\n    gaussWeights,\n    nodesXCoordinates,\n    nodesYCoordinates,\n    basisFunctions\n  ) {\n    // Extract convection parameters from boundary conditions\n    let convectionHeatTranfCoeff = [];\n    let convectionExtTemp = [];\n    Object.keys(this.boundaryConditions).forEach((key) => {\n      const boundaryCondition = this.boundaryConditions[key];\n      if (boundaryCondition[0] === \"convection\") {\n        convectionHeatTranfCoeff[key] = boundaryCondition[1];\n        convectionExtTemp[key] = boundaryCondition[2];\n      }\n    });\n\n    if (this.meshDimension === \"1D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        if (this.boundaryConditions[boundaryKey][0] === \"convection\") {\n          const convectionCoeff = convectionHeatTranfCoeff[boundaryKey];\n          const extTemp = convectionExtTemp[boundaryKey];\n          debugLog(\n            `Boundary ${boundaryKey}: Applying convection with heat transfer coefficient h=${convectionCoeff} W/(m²·K) and external temperature T∞=${extTemp} K`\n          );\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            let nodeIndex;\n            if (this.elementOrder === \"linear\") {\n              if (side === 0) {\n                // Node at the left side of the reference element\n                nodeIndex = 0;\n              } else {\n                // Node at the right side of the reference element\n                nodeIndex = 1;\n              }\n            } else if (this.elementOrder === \"quadratic\") {\n              if (side === 0) {\n                // Node at the left side of the reference element\n                nodeIndex = 0;\n              } else {\n                // Node at the right side of the reference element\n                nodeIndex = 2;\n              }\n            }\n\n            const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n            debugLog(\n              `  - Applied convection boundary condition to node ${globalNodeIndex + 1} (element ${\n                elementIndex + 1\n              }, local node ${nodeIndex + 1})`\n            );\n            residualVector[globalNodeIndex] += -convectionCoeff * extTemp;\n            jacobianMatrix[globalNodeIndex][globalNodeIndex] += convectionCoeff;\n          });\n        }\n      });\n    } else if (this.meshDimension === \"2D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        if (this.boundaryConditions[boundaryKey][0] === \"convection\") {\n          const convectionCoeff = convectionHeatTranfCoeff[boundaryKey];\n          const extTemp = convectionExtTemp[boundaryKey];\n          debugLog(\n            `Boundary ${boundaryKey}: Applying convection with heat transfer coefficient h=${convectionCoeff} W/(m²·K) and external temperature T∞=${extTemp} K`\n          );\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            if (this.elementOrder === \"linear\") {\n              let gaussPoint1, gaussPoint2, firstNodeIndex, lastNodeIndex, nodeIncrement;\n              if (side === 0) {\n                // Nodes at the bottom side of the reference element\n                gaussPoint1 = gaussPoints[0];\n                gaussPoint2 = 0;\n                firstNodeIndex = 0;\n                lastNodeIndex = 3;\n                nodeIncrement = 2;\n              } else if (side === 1) {\n                // Nodes at the left side of the reference element\n                gaussPoint1 = 0;\n                gaussPoint2 = gaussPoints[0];\n                firstNodeIndex = 0;\n                lastNodeIndex = 2;\n                nodeIncrement = 1;\n              } else if (side === 2) {\n                // Nodes at the top side of the reference element\n                gaussPoint1 = gaussPoints[0];\n                gaussPoint2 = 1;\n                firstNodeIndex = 1;\n                lastNodeIndex = 4;\n                nodeIncrement = 2;\n              } else if (side === 3) {\n                // Nodes at the right side of the reference element\n                gaussPoint1 = 1;\n                gaussPoint2 = gaussPoints[0];\n                firstNodeIndex = 2;\n                lastNodeIndex = 4;\n                nodeIncrement = 1;\n              }\n\n              let basisFunctionsAndDerivatives = basisFunctions.getBasisFunctions(gaussPoint1, gaussPoint2);\n              let basisFunction = basisFunctionsAndDerivatives.basisFunction;\n              let basisFunctionDerivKsi = basisFunctionsAndDerivatives.basisFunctionDerivKsi;\n              let basisFunctionDerivEta = basisFunctionsAndDerivatives.basisFunctionDerivEta;\n\n              let ksiDerivX = 0;\n              let ksiDerivY = 0;\n              let etaDerivX = 0;\n              let etaDerivY = 0;\n              const numNodes = this.nop[elementIndex].length;\n              for (let nodeIndex = 0; nodeIndex < numNodes; nodeIndex++) {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n\n                // For boundaries along Ksi (horizontal), use Ksi derivatives\n                if (side === 0 || side === 2) {\n                  ksiDerivX += nodesXCoordinates[globalNodeIndex] * basisFunctionDerivKsi[nodeIndex];\n                  ksiDerivY += nodesYCoordinates[globalNodeIndex] * basisFunctionDerivKsi[nodeIndex];\n                }\n                // For boundaries along Eta (vertical), use Eta derivatives\n                else if (side === 1 || side === 3) {\n                  etaDerivX += nodesXCoordinates[globalNodeIndex] * basisFunctionDerivEta[nodeIndex];\n                  etaDerivY += nodesYCoordinates[globalNodeIndex] * basisFunctionDerivEta[nodeIndex];\n                }\n              }\n\n              // Compute the length of tangent vector\n              let tangentVectorLength;\n              if (side === 0 || side === 2) {\n                tangentVectorLength = Math.sqrt(ksiDerivX ** 2 + ksiDerivY ** 2);\n              } else {\n                tangentVectorLength = Math.sqrt(etaDerivX ** 2 + etaDerivY ** 2);\n              }\n\n              for (\n                let localNodeIndex = firstNodeIndex;\n                localNodeIndex < lastNodeIndex;\n                localNodeIndex += nodeIncrement\n              ) {\n                let globalNodeIndex = this.nop[elementIndex][localNodeIndex] - 1;\n                debugLog(\n                  `  - Applied convection boundary condition to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${localNodeIndex + 1})`\n                );\n\n                // Apply boundary condition with proper Jacobian for all sides\n                residualVector[globalNodeIndex] +=\n                  -gaussWeights[0] *\n                  tangentVectorLength *\n                  basisFunction[localNodeIndex] *\n                  convectionCoeff *\n                  extTemp;\n\n                for (\n                  let localNodeIndex2 = firstNodeIndex;\n                  localNodeIndex2 < lastNodeIndex;\n                  localNodeIndex2 += nodeIncrement\n                ) {\n                  let globalNodeIndex2 = this.nop[elementIndex][localNodeIndex2] - 1;\n                  jacobianMatrix[globalNodeIndex][globalNodeIndex2] +=\n                    -gaussWeights[0] *\n                    tangentVectorLength *\n                    basisFunction[localNodeIndex] *\n                    basisFunction[localNodeIndex2] *\n                    convectionCoeff;\n                }\n              }\n            } else if (this.elementOrder === \"quadratic\") {\n              for (let gaussPointIndex = 0; gaussPointIndex < 3; gaussPointIndex++) {\n                let gaussPoint1, gaussPoint2, firstNodeIndex, lastNodeIndex, nodeIncrement;\n                if (side === 0) {\n                  // Nodes at the bottom side of the reference element\n                  gaussPoint1 = gaussPoints[gaussPointIndex];\n                  gaussPoint2 = 0;\n                  firstNodeIndex = 0;\n                  lastNodeIndex = 7;\n                  nodeIncrement = 3;\n                } else if (side === 1) {\n                  // Nodes at the left side of the reference element\n                  gaussPoint1 = 0;\n                  gaussPoint2 = gaussPoints[gaussPointIndex];\n                  firstNodeIndex = 0;\n                  lastNodeIndex = 3;\n                  nodeIncrement = 1;\n                } else if (side === 2) {\n                  // Nodes at the top side of the reference element\n                  gaussPoint1 = gaussPoints[gaussPointIndex];\n                  gaussPoint2 = 1;\n                  firstNodeIndex = 2;\n                  lastNodeIndex = 9;\n                  nodeIncrement = 3;\n                } else if (side === 3) {\n                  // Nodes at the right side of the reference element\n                  gaussPoint1 = 1;\n                  gaussPoint2 = gaussPoints[gaussPointIndex];\n                  firstNodeIndex = 6;\n                  lastNodeIndex = 9;\n                  nodeIncrement = 1;\n                }\n                let basisFunctionsAndDerivatives = basisFunctions.getBasisFunctions(gaussPoint1, gaussPoint2);\n                let basisFunction = basisFunctionsAndDerivatives.basisFunction;\n                let basisFunctionDerivKsi = basisFunctionsAndDerivatives.basisFunctionDerivKsi;\n                let basisFunctionDerivEta = basisFunctionsAndDerivatives.basisFunctionDerivEta;\n\n                let ksiDerivX = 0;\n                let ksiDerivY = 0;\n                let etaDerivX = 0;\n                let etaDerivY = 0;\n                const numNodes = this.nop[elementIndex].length;\n                for (let nodeIndex = 0; nodeIndex < numNodes; nodeIndex++) {\n                  const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n\n                  // For boundaries along Ksi (horizontal), use Ksi derivatives\n                  if (side === 0 || side === 2) {\n                    ksiDerivX += nodesXCoordinates[globalNodeIndex] * basisFunctionDerivKsi[nodeIndex];\n                    ksiDerivY += nodesYCoordinates[globalNodeIndex] * basisFunctionDerivKsi[nodeIndex];\n                  }\n                  // For boundaries along Eta (vertical), use Eta derivatives\n                  else if (side === 1 || side === 3) {\n                    etaDerivX += nodesXCoordinates[globalNodeIndex] * basisFunctionDerivEta[nodeIndex];\n                    etaDerivY += nodesYCoordinates[globalNodeIndex] * basisFunctionDerivEta[nodeIndex];\n                  }\n                }\n\n                // Compute the length of tangent vector\n                let tangentVectorLength;\n                if (side === 0 || side === 2) {\n                  tangentVectorLength = Math.sqrt(ksiDerivX ** 2 + ksiDerivY ** 2);\n                } else {\n                  tangentVectorLength = Math.sqrt(etaDerivX ** 2 + etaDerivY ** 2);\n                }\n\n                for (\n                  let localNodeIndex = firstNodeIndex;\n                  localNodeIndex < lastNodeIndex;\n                  localNodeIndex += nodeIncrement\n                ) {\n                  let globalNodeIndex = this.nop[elementIndex][localNodeIndex] - 1;\n                  debugLog(\n                    `  - Applied convection boundary condition to node ${globalNodeIndex + 1} (element ${\n                      elementIndex + 1\n                    }, local node ${localNodeIndex + 1})`\n                  );\n\n                  // Apply boundary condition with proper Jacobian for all sides\n                  residualVector[globalNodeIndex] +=\n                    -gaussWeights[gaussPointIndex] *\n                    tangentVectorLength *\n                    basisFunction[localNodeIndex] *\n                    convectionCoeff *\n                    extTemp;\n\n                  for (\n                    let localNodeIndex2 = firstNodeIndex;\n                    localNodeIndex2 < lastNodeIndex;\n                    localNodeIndex2 += nodeIncrement\n                  ) {\n                    let globalNodeIndex2 = this.nop[elementIndex][localNodeIndex2] - 1;\n                    jacobianMatrix[globalNodeIndex][globalNodeIndex2] +=\n                      -gaussWeights[gaussPointIndex] *\n                      tangentVectorLength *\n                      basisFunction[localNodeIndex] *\n                      basisFunction[localNodeIndex2] *\n                      convectionCoeff;\n                  }\n                }\n              }\n            }\n          });\n        }\n      });\n    }\n  }\n\n  /**\n   * Function to impose convection boundary conditions for the frontal solver\n   * @param {number} elementIndex - Index of the element being processed\n   * @param {array} nodesXCoordinates - Array of x-coordinates of nodes\n   * @param {array} nodesYCoordinates - Array of y-coordinates of nodes\n   * @param {array} gaussPoints - Array of Gauss points for numerical integration\n   * @param {array} gaussWeights - Array of Gauss weights for numerical integration\n   * @param {object} basisFunctions - Object containing basis functions and their derivatives\n   * @returns {object} An object containing:\n   *  - localJacobianMatrix: Local Jacobian matrix with convection contributions\n   *  - localResidualVector: Residual vector with convection contributions\n   */\n  imposeConvectionBoundaryConditionsFront(\n    elementIndex,\n    nodesXCoordinates,\n    nodesYCoordinates,\n    gaussPoints,\n    gaussWeights,\n    basisFunctions\n  ) {\n    // Extract convection parameters from boundary conditions\n    let convectionHeatTranfCoeff = [];\n    let convectionExtTemp = [];\n    Object.keys(this.boundaryConditions).forEach((key) => {\n      const boundaryCondition = this.boundaryConditions[key];\n      if (boundaryCondition[0] === \"convection\") {\n        convectionHeatTranfCoeff[key] = boundaryCondition[1];\n        convectionExtTemp[key] = boundaryCondition[2];\n      }\n    });\n\n    // Initialize local Jacobian matrix and local residual vector\n    const numNodes = this.nop[elementIndex].length;\n    const localJacobianMatrix = Array(numNodes)\n      .fill()\n      .map(() => Array(numNodes).fill(0));\n    const localResidualVector = Array(numNodes).fill(0);\n\n    // Check if this element is on a convection boundary\n    for (const boundaryKey in this.boundaryElements) {\n      if (this.boundaryConditions[boundaryKey]?.[0] === \"convection\") {\n        const convectionCoeff = convectionHeatTranfCoeff[boundaryKey];\n        const extTemp = convectionExtTemp[boundaryKey];\n        debugLog(\n          `Boundary ${boundaryKey}: Applying convection with heat transfer coefficient h=${convectionCoeff} W/(m²·K) and external temperature T∞=${extTemp} K`\n        );\n\n        // Find if this element is on this boundary and which side\n        const boundaryElement = this.boundaryElements[boundaryKey].find(\n          ([elemIdx, _]) => elemIdx === elementIndex\n        );\n\n        if (boundaryElement) {\n          const side = boundaryElement[1];\n\n          if (this.meshDimension === \"1D\") {\n            // Handle 1D case\n            let nodeIndex;\n            if (this.elementOrder === \"linear\") {\n              nodeIndex = side === 0 ? 0 : 1;\n            } else if (this.elementOrder === \"quadratic\") {\n              nodeIndex = side === 0 ? 0 : 2;\n            }\n\n            // Add contribution to local Jacobian matrix and local residual vector\n            debugLog(\n              `  - Applied convection boundary condition to node ${nodeIndex + 1} (element ${\n                elementIndex + 1\n              }, local node ${nodeIndex + 1})`\n            );\n            localResidualVector[nodeIndex] += -convectionCoeff * extTemp;\n            localJacobianMatrix[nodeIndex][nodeIndex] += convectionCoeff;\n          } else if (this.meshDimension === \"2D\") {\n            // Handle 2D case\n            if (this.elementOrder === \"linear\") {\n              let gaussPoint1, gaussPoint2, firstNodeIndex, lastNodeIndex, nodeIncrement;\n\n              if (side === 0) {\n                // Nodes at the bottom side of the reference element\n                gaussPoint1 = gaussPoints[0];\n                gaussPoint2 = 0;\n                firstNodeIndex = 0;\n                lastNodeIndex = 3;\n                nodeIncrement = 2;\n              } else if (side === 1) {\n                // Nodes at the left side of the reference element\n                gaussPoint1 = 0;\n                gaussPoint2 = gaussPoints[0];\n                firstNodeIndex = 0;\n                lastNodeIndex = 2;\n                nodeIncrement = 1;\n              } else if (side === 2) {\n                // Nodes at the top side of the reference element\n                gaussPoint1 = gaussPoints[0];\n                gaussPoint2 = 1;\n                firstNodeIndex = 1;\n                lastNodeIndex = 4;\n                nodeIncrement = 2;\n              } else if (side === 3) {\n                // Nodes at the right side of the reference element\n                gaussPoint1 = 1;\n                gaussPoint2 = gaussPoints[0];\n                firstNodeIndex = 2;\n                lastNodeIndex = 4;\n                nodeIncrement = 1;\n              }\n\n              // Get basis functions\n              const basisFunctionsAndDerivatives = basisFunctions.getBasisFunctions(gaussPoint1, gaussPoint2);\n              const basisFunction = basisFunctionsAndDerivatives.basisFunction;\n              const basisFunctionDerivKsi = basisFunctionsAndDerivatives.basisFunctionDerivKsi;\n              const basisFunctionDerivEta = basisFunctionsAndDerivatives.basisFunctionDerivEta;\n\n              // Calculate tangent vector components\n              let ksiDerivX = 0,\n                ksiDerivY = 0,\n                etaDerivX = 0,\n                etaDerivY = 0;\n              for (let nodeIndex = 0; nodeIndex < numNodes; nodeIndex++) {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n\n                if (side === 0 || side === 2) {\n                  ksiDerivX += nodesXCoordinates[globalNodeIndex] * basisFunctionDerivKsi[nodeIndex];\n                  ksiDerivY += nodesYCoordinates[globalNodeIndex] * basisFunctionDerivKsi[nodeIndex];\n                } else if (side === 1 || side === 3) {\n                  etaDerivX += nodesXCoordinates[globalNodeIndex] * basisFunctionDerivEta[nodeIndex];\n                  etaDerivY += nodesYCoordinates[globalNodeIndex] * basisFunctionDerivEta[nodeIndex];\n                }\n              }\n\n              // Compute tangent vector length\n              let tangentVectorLength;\n              if (side === 0 || side === 2) {\n                tangentVectorLength = Math.sqrt(ksiDerivX ** 2 + ksiDerivY ** 2);\n              } else {\n                tangentVectorLength = Math.sqrt(etaDerivX ** 2 + etaDerivY ** 2);\n              }\n\n              // Apply boundary conditions to local matrices\n              for (\n                let localNodeIndex = firstNodeIndex;\n                localNodeIndex < lastNodeIndex;\n                localNodeIndex += nodeIncrement\n              ) {\n                localResidualVector[localNodeIndex] +=\n                  -gaussWeights[0] *\n                  tangentVectorLength *\n                  basisFunction[localNodeIndex] *\n                  convectionCoeff *\n                  extTemp;\n\n                for (\n                  let localNodeIndex2 = firstNodeIndex;\n                  localNodeIndex2 < lastNodeIndex;\n                  localNodeIndex2 += nodeIncrement\n                ) {\n                  localJacobianMatrix[localNodeIndex][localNodeIndex2] +=\n                    -gaussWeights[0] *\n                    tangentVectorLength *\n                    basisFunction[localNodeIndex] *\n                    basisFunction[localNodeIndex2] *\n                    convectionCoeff;\n                }\n              }\n            } else if (this.elementOrder === \"quadratic\") {\n              // Handle quadratic elements (similar pattern but with more Gauss points)\n              for (let gaussPointIndex = 0; gaussPointIndex < 3; gaussPointIndex++) {\n                let gaussPoint1, gaussPoint2, firstNodeIndex, lastNodeIndex, nodeIncrement;\n\n                if (side === 0) {\n                  // Nodes at the bottom side of the reference element\n                  gaussPoint1 = gaussPoints[gaussPointIndex];\n                  gaussPoint2 = 0;\n                  firstNodeIndex = 0;\n                  lastNodeIndex = 7;\n                  nodeIncrement = 3;\n                } else if (side === 1) {\n                  // Nodes at the left side of the reference element\n                  gaussPoint1 = 0;\n                  gaussPoint2 = gaussPoints[gaussPointIndex];\n                  firstNodeIndex = 0;\n                  lastNodeIndex = 3;\n                  nodeIncrement = 1;\n                } else if (side === 2) {\n                  // Nodes at the top side of the reference element\n                  gaussPoint1 = gaussPoints[gaussPointIndex];\n                  gaussPoint2 = 1;\n                  firstNodeIndex = 2;\n                  lastNodeIndex = 9;\n                  nodeIncrement = 3;\n                } else if (side === 3) {\n                  // Nodes at the right side of the reference element\n                  gaussPoint1 = 1;\n                  gaussPoint2 = gaussPoints[gaussPointIndex];\n                  firstNodeIndex = 6;\n                  lastNodeIndex = 9;\n                  nodeIncrement = 1;\n                }\n                let basisFunctionsAndDerivatives = basisFunctions.getBasisFunctions(gaussPoint1, gaussPoint2);\n                let basisFunction = basisFunctionsAndDerivatives.basisFunction;\n                let basisFunctionDerivKsi = basisFunctionsAndDerivatives.basisFunctionDerivKsi;\n                let basisFunctionDerivEta = basisFunctionsAndDerivatives.basisFunctionDerivEta;\n\n                let ksiDerivX = 0;\n                let ksiDerivY = 0;\n                let etaDerivX = 0;\n                let etaDerivY = 0;\n                const numNodes = this.nop[elementIndex].length;\n                for (let nodeIndex = 0; nodeIndex < numNodes; nodeIndex++) {\n                  const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n\n                  // For boundaries along Ksi (horizontal), use Ksi derivatives\n                  if (side === 0 || side === 2) {\n                    ksiDerivX += nodesXCoordinates[globalNodeIndex] * basisFunctionDerivKsi[nodeIndex];\n                    ksiDerivY += nodesYCoordinates[globalNodeIndex] * basisFunctionDerivKsi[nodeIndex];\n                  }\n                  // For boundaries along Eta (vertical), use Eta derivatives\n                  else if (side === 1 || side === 3) {\n                    etaDerivX += nodesXCoordinates[globalNodeIndex] * basisFunctionDerivEta[nodeIndex];\n                    etaDerivY += nodesYCoordinates[globalNodeIndex] * basisFunctionDerivEta[nodeIndex];\n                  }\n                }\n\n                // Compute the length of tangent vector\n                let tangentVectorLength;\n                if (side === 0 || side === 2) {\n                  tangentVectorLength = Math.sqrt(ksiDerivX ** 2 + ksiDerivY ** 2);\n                } else {\n                  tangentVectorLength = Math.sqrt(etaDerivX ** 2 + etaDerivY ** 2);\n                }\n\n                // Apply boundary conditions to local matrices\n                for (\n                  let localNodeIndex = firstNodeIndex;\n                  localNodeIndex < lastNodeIndex;\n                  localNodeIndex += nodeIncrement\n                ) {\n                  localResidualVector[localNodeIndex] +=\n                    -gaussWeights[gaussPointIndex] *\n                    tangentVectorLength *\n                    basisFunction[localNodeIndex] *\n                    convectionCoeff *\n                    extTemp;\n\n                  for (\n                    let localNodeIndex2 = firstNodeIndex;\n                    localNodeIndex2 < lastNodeIndex;\n                    localNodeIndex2 += nodeIncrement\n                  ) {\n                    localJacobianMatrix[localNodeIndex][localNodeIndex2] +=\n                      -gaussWeights[gaussPointIndex] *\n                      tangentVectorLength *\n                      basisFunction[localNodeIndex] *\n                      basisFunction[localNodeIndex2] *\n                      convectionCoeff;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return { localJacobianMatrix, localResidualVector };\n  }\n}\n","/**\n * ════════════════════════════════════════════════════════════\n *  FEAScript Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.1.4 | https://feascript.com\n * ════════════════════════════════════════════════════════════\n */\n\n// Internal imports\nimport {\n  initializeFEA,\n  performIsoparametricMapping1D,\n  performIsoparametricMapping2D,\n} from \"../mesh/meshUtilsScript.js\";\nimport { ThermalBoundaryConditions } from \"./thermalBoundaryConditionsScript.js\";\nimport { basicLog, debugLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Function to assemble the Jacobian matrix and residuals vector for the solid heat transfer model\n * @param {object} meshData - Object containing prepared mesh data\n * @param {object} boundaryConditions - Object containing boundary conditions for the finite element analysis\n * @returns {object} An object containing:\n *  - jacobianMatrix: The assembled Jacobian matrix\n *  - residualVector: The assembled residual vector\n *\n * For consistency across both linear and nonlinear formulations,\n * this project always refers to the assembled right-hand side vector\n * as `residualVector` and the assembled system matrix as `jacobianMatrix`.\n *\n * In linear problems `jacobianMatrix` is equivalent to the\n * classic stiffness/conductivity matrix and `residualVector`\n * corresponds to the traditional load (RHS) vector.\n */\nexport function assembleHeatConductionMat(meshData, boundaryConditions) {\n  basicLog(\"Starting solid heat transfer matrix assembly...\");\n\n  // Extract mesh data\n  const {\n    nodesXCoordinates,\n    nodesYCoordinates,\n    nop,\n    boundaryElements,\n    totalElements,\n    meshDimension,\n    elementOrder,\n  } = meshData;\n\n  // Initialize FEA components\n  const FEAData = initializeFEA(meshData);\n  const {\n    residualVector,\n    jacobianMatrix,\n    localToGlobalMap,\n    basisFunctions,\n    gaussPoints,\n    gaussWeights,\n    numNodes,\n  } = FEAData;\n\n  // Matrix assembly\n  for (let elementIndex = 0; elementIndex < totalElements; elementIndex++) {\n    // Map local element nodes to global mesh nodes\n    for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n      // Subtract 1 from nop in order to start numbering from 0\n      localToGlobalMap[localNodeIndex] = nop[elementIndex][localNodeIndex] - 1;\n    }\n\n    // Loop over Gauss points\n    for (let gaussPointIndex1 = 0; gaussPointIndex1 < gaussPoints.length; gaussPointIndex1++) {\n      // 1D solid heat transfer\n      if (meshDimension === \"1D\") {\n        // Get basis functions for the current Gauss point\n        const basisFunctionsAndDerivatives = basisFunctions.getBasisFunctions(gaussPoints[gaussPointIndex1]);\n\n        // Perform isoparametric mapping\n        const mappingResult = performIsoparametricMapping1D({\n          basisFunction: basisFunctionsAndDerivatives.basisFunction,\n          basisFunctionDerivKsi: basisFunctionsAndDerivatives.basisFunctionDerivKsi,\n          nodesXCoordinates,\n          localToGlobalMap,\n          numNodes,\n        });\n\n        // Extract mapping results\n        const { detJacobian, basisFunctionDerivX } = mappingResult;\n\n        // Computation of Galerkin's residuals and Jacobian matrix\n        for (let localNodeIndex1 = 0; localNodeIndex1 < numNodes; localNodeIndex1++) {\n          let localToGlobalMap1 = localToGlobalMap[localNodeIndex1];\n          // residualVector is zero for this case\n\n          for (let localNodeIndex2 = 0; localNodeIndex2 < numNodes; localNodeIndex2++) {\n            let localToGlobalMap2 = localToGlobalMap[localNodeIndex2];\n            jacobianMatrix[localToGlobalMap1][localToGlobalMap2] +=\n              -gaussWeights[gaussPointIndex1] *\n              detJacobian *\n              (basisFunctionDerivX[localNodeIndex1] * basisFunctionDerivX[localNodeIndex2]);\n          }\n        }\n      }\n      // 2D solid heat transfer\n      else if (meshDimension === \"2D\") {\n        for (let gaussPointIndex2 = 0; gaussPointIndex2 < gaussPoints.length; gaussPointIndex2++) {\n          // Get basis functions for the current Gauss point\n          const basisFunctionsAndDerivatives = basisFunctions.getBasisFunctions(\n            gaussPoints[gaussPointIndex1],\n            gaussPoints[gaussPointIndex2]\n          );\n\n          // Perform isoparametric mapping\n          const mappingResult = performIsoparametricMapping2D({\n            basisFunction: basisFunctionsAndDerivatives.basisFunction,\n            basisFunctionDerivKsi: basisFunctionsAndDerivatives.basisFunctionDerivKsi,\n            basisFunctionDerivEta: basisFunctionsAndDerivatives.basisFunctionDerivEta,\n            nodesXCoordinates,\n            nodesYCoordinates,\n            localToGlobalMap,\n            numNodes,\n          });\n\n          // Extract mapping results\n          const { detJacobian, basisFunctionDerivX, basisFunctionDerivY } = mappingResult;\n\n          // Computation of Galerkin's residuals and Jacobian matrix\n          for (let localNodeIndex1 = 0; localNodeIndex1 < numNodes; localNodeIndex1++) {\n            let localToGlobalMap1 = localToGlobalMap[localNodeIndex1];\n            // residualVector is zero for this case\n\n            for (let localNodeIndex2 = 0; localNodeIndex2 < numNodes; localNodeIndex2++) {\n              let localToGlobalMap2 = localToGlobalMap[localNodeIndex2];\n              jacobianMatrix[localToGlobalMap1][localToGlobalMap2] +=\n                -gaussWeights[gaussPointIndex1] *\n                gaussWeights[gaussPointIndex2] *\n                detJacobian *\n                (basisFunctionDerivX[localNodeIndex1] * basisFunctionDerivX[localNodeIndex2] +\n                  basisFunctionDerivY[localNodeIndex1] * basisFunctionDerivY[localNodeIndex2]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Apply boundary conditions\n  const thermalBoundaryConditions = new ThermalBoundaryConditions(\n    boundaryConditions,\n    boundaryElements,\n    nop,\n    meshDimension,\n    elementOrder\n  );\n\n  // Impose Convection boundary conditions\n  thermalBoundaryConditions.imposeConvectionBoundaryConditions(\n    residualVector,\n    jacobianMatrix,\n    gaussPoints,\n    gaussWeights,\n    nodesXCoordinates,\n    nodesYCoordinates,\n    basisFunctions\n  );\n\n  // Impose ConstantTemp boundary conditions\n  thermalBoundaryConditions.imposeConstantTempBoundaryConditions(residualVector, jacobianMatrix);\n  basicLog(\"Solid heat transfer matrix assembly completed\");\n\n  return {\n    jacobianMatrix,\n    residualVector,\n  };\n}\n\n/**\n * Function to assemble the local Jacobian matrix and residual vector for the solid heat transfer model when using the frontal system solver\n * @param {number} elementIndex - Index of the element being processed\n * @param {array} nop - Nodal connectivity array (element-to-node mapping)\n * @param {object} meshData - Object containing prepared mesh data\n * @param {object} basisFunctions - Object containing basis functions and their derivatives\n * @param {object} FEAData - Object containing FEA-related data\n * @returns {object} An object containing:\n *  - localJacobianMatrix: Local Jacobian matrix\n *  - localResidualVector: Residual vector contributions\n *  - ngl: Array mapping local node indices to global node indices\n */\nexport function assembleHeatConductionFront({ elementIndex, nop, meshData, basisFunctions, FEAData }) {\n  // Extract numerical integration parameters and mesh coordinates\n  const { gaussPoints, gaussWeights, numNodes } = FEAData;\n  const { nodesXCoordinates, nodesYCoordinates, meshDimension } = meshData;\n\n  // Initialize local Jacobian matrix and local residual vector\n  const localJacobianMatrix = Array(numNodes)\n    .fill()\n    .map(() => Array(numNodes).fill(0));\n  const localResidualVector = Array(numNodes).fill(0);\n\n  // Build the mapping from local node indices to global node indices\n  const ngl = Array(numNodes);\n  const localToGlobalMap = Array(numNodes);\n  for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n    ngl[localNodeIndex] = Math.abs(nop[elementIndex][localNodeIndex]);\n    localToGlobalMap[localNodeIndex] = Math.abs(nop[elementIndex][localNodeIndex]) - 1;\n  }\n\n  // Loop over Gauss points\n  if (meshDimension === \"1D\") {\n    // 1D solid heat transfer\n    for (let gaussPointIndex1 = 0; gaussPointIndex1 < gaussPoints.length; gaussPointIndex1++) {\n      // Get basis functions for the current Gauss point\n      const { basisFunction, basisFunctionDerivKsi } = basisFunctions.getBasisFunctions(\n        gaussPoints[gaussPointIndex1]\n      );\n\n      // Perform isoparametric mapping\n      const { detJacobian, basisFunctionDerivX } = performIsoparametricMapping1D({\n        basisFunction,\n        basisFunctionDerivKsi,\n        nodesXCoordinates,\n        localToGlobalMap,\n        numNodes,\n      });\n\n      // Computation of Galerkin's residuals and local Jacobian matrix\n      for (let localNodeIndex1 = 0; localNodeIndex1 < numNodes; localNodeIndex1++) {\n        for (let localNodeIndex2 = 0; localNodeIndex2 < numNodes; localNodeIndex2++) {\n          localJacobianMatrix[localNodeIndex1][localNodeIndex2] -=\n            gaussWeights[gaussPointIndex1] *\n            detJacobian *\n            (basisFunctionDerivX[localNodeIndex1] * basisFunctionDerivX[localNodeIndex2]);\n        }\n      }\n    }\n  } else if (meshDimension === \"2D\") {\n    // 2D solid heat transfer\n    for (let gaussPointIndex1 = 0; gaussPointIndex1 < gaussPoints.length; gaussPointIndex1++) {\n      for (let gaussPointIndex2 = 0; gaussPointIndex2 < gaussPoints.length; gaussPointIndex2++) {\n        // Get basis functions for the current Gauss point\n        const { basisFunction, basisFunctionDerivKsi, basisFunctionDerivEta } =\n          basisFunctions.getBasisFunctions(gaussPoints[gaussPointIndex1], gaussPoints[gaussPointIndex2]);\n\n        // Create mapping from local element space to global mesh (convert to 0-based indexing)\n        const localToGlobalMap = ngl.map((globalIndex) => globalIndex - 1);\n\n        // Perform isoparametric mapping\n        const { detJacobian, basisFunctionDerivX, basisFunctionDerivY } = performIsoparametricMapping2D({\n          basisFunction,\n          basisFunctionDerivKsi,\n          basisFunctionDerivEta,\n          nodesXCoordinates,\n          nodesYCoordinates,\n          localToGlobalMap,\n          numNodes,\n        });\n\n        // Computation of Galerkin's residuals and local Jacobian matrix\n        for (let localNodeIndex1 = 0; localNodeIndex1 < numNodes; localNodeIndex1++) {\n          for (let localNodeIndex2 = 0; localNodeIndex2 < numNodes; localNodeIndex2++) {\n            localJacobianMatrix[localNodeIndex1][localNodeIndex2] -=\n              gaussWeights[gaussPointIndex1] *\n              gaussWeights[gaussPointIndex2] *\n              detJacobian *\n              (basisFunctionDerivX[localNodeIndex1] * basisFunctionDerivX[localNodeIndex2] +\n                basisFunctionDerivY[localNodeIndex1] * basisFunctionDerivY[localNodeIndex2]);\n          }\n        }\n      }\n    }\n  }\n\n  return { localJacobianMatrix, localResidualVector, ngl };\n}\n","/**\n * ════════════════════════════════════════════════════════════\n *  FEAScript Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.1.4 | https://feascript.com\n * ════════════════════════════════════════════════════════════\n */\n\n// Internal imports\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Class to handle generic boundary conditions application\n */\nexport class GenericBoundaryConditions {\n  /**\n   * Constructor to initialize the GenericBoundaryConditions class\n   * @param {object} boundaryConditions - Object containing boundary conditions for the finite element analysis\n   * @param {array} boundaryElements - Array containing elements that belong to each boundary\n   * @param {array} nop - Nodal numbering (NOP) array representing the connectivity between elements and nodes\n   * @param {string} meshDimension - The dimension of the mesh (e.g., \"2D\")\n   * @param {string} elementOrder - The order of elements (e.g., \"linear\", \"quadratic\")\n   */\n  constructor(boundaryConditions, boundaryElements, nop, meshDimension, elementOrder) {\n    this.boundaryConditions = boundaryConditions;\n    this.boundaryElements = boundaryElements;\n    this.nop = nop;\n    this.meshDimension = meshDimension;\n    this.elementOrder = elementOrder;\n  }\n\n  /**\n   * Function to impose Dirichlet boundary conditions\n   * @param {array} residualVector - The residual vector to be modified\n   * @param {array} jacobianMatrix - The Jacobian matrix to be modified\n   *\n   * For consistency across both linear and nonlinear formulations,\n   * this project always refers to the assembled right-hand side vector\n   * as `residualVector` and the assembled system matrix as `jacobianMatrix`.\n   *\n   * In linear problems `jacobianMatrix` is equivalent to the\n   * classic stiffness/conductivity matrix and `residualVector`\n   * corresponds to the traditional load (RHS) vector.\n   */\n  imposeDirichletBoundaryConditions(residualVector, jacobianMatrix) {\n    if (this.meshDimension === \"1D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        if (this.boundaryConditions[boundaryKey][0] === \"constantValue\") {\n          const value = this.boundaryConditions[boundaryKey][1];\n          debugLog(`Boundary ${boundaryKey}: Applying constant value of ${value} (Dirichlet condition)`);\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            if (this.elementOrder === \"linear\") {\n              const boundarySides = {\n                0: [0], // Node at the left side of the reference element\n                1: [1], // Node at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant value to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                // Set the residual vector to the value\n                residualVector[globalNodeIndex] = value;\n                // Set the Jacobian matrix row to zero\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\n                }\n                // Set the diagonal entry of the Jacobian matrix to one\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\n              });\n            } else if (this.elementOrder === \"quadratic\") {\n              const boundarySides = {\n                0: [0], // Node at the left side of the reference element\n                2: [2], // Node at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant value to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                // Set the residual vector to the value\n                residualVector[globalNodeIndex] = value;\n                // Set the Jacobian matrix row to zero\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\n                }\n                // Set the diagonal entry of the Jacobian matrix to one\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\n              });\n            }\n          });\n        }\n      });\n    } else if (this.meshDimension === \"2D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        if (this.boundaryConditions[boundaryKey][0] === \"constantValue\") {\n          const value = this.boundaryConditions[boundaryKey][1];\n          debugLog(`Boundary ${boundaryKey}: Applying constant value of ${value} (Dirichlet condition)`);\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            if (this.elementOrder === \"linear\") {\n              const boundarySides = {\n                0: [0, 2], // Nodes at the bottom side of the reference element\n                1: [0, 1], // Nodes at the left side of the reference element\n                2: [1, 3], // Nodes at the top side of the reference element\n                3: [2, 3], // Nodes at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant value to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                // Set the residual vector to the value\n                residualVector[globalNodeIndex] = value;\n                // Set the Jacobian matrix row to zero\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\n                }\n                // Set the diagonal entry of the Jacobian matrix to one\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\n              });\n            } else if (this.elementOrder === \"quadratic\") {\n              const boundarySides = {\n                0: [0, 3, 6], // Nodes at the bottom side of the reference element\n                1: [0, 1, 2], // Nodes at the left side of the reference element\n                2: [2, 5, 8], // Nodes at the top side of the reference element\n                3: [6, 7, 8], // Nodes at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant value to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                // Set the residual vector to the value\n                residualVector[globalNodeIndex] = value;\n                // Set the Jacobian matrix row to zero\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\n                }\n                // Set the diagonal entry of the Jacobian matrix to one\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\n              });\n            }\n          });\n        }\n      });\n    }\n  }\n\n  /**\n   * Function to impose constant value (Dirichlet) boundary conditions for the frontal solver\n   * @param {array} nodeConstraintCode - Array indicating boundary condition code for each node\n   * @param {array} boundaryValues - Array containing boundary condition values\n   */\n  imposeConstantValueBoundaryConditionsFront(nodeConstraintCode, boundaryValues) {\n    if (this.meshDimension === \"1D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        if (this.boundaryConditions[boundaryKey][0] === \"constantValue\") {\n          const value = this.boundaryConditions[boundaryKey][1];\n          debugLog(`Boundary ${boundaryKey}: Applying constant value of ${value} (Dirichlet condition)`);\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            if (this.elementOrder === \"linear\") {\n              const boundarySides = {\n                0: [0], // Node at the left side of the reference element\n                1: [1], // Node at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant value to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                nodeConstraintCode[globalNodeIndex] = 1;\n                boundaryValues[globalNodeIndex] = value;\n              });\n            } else if (this.elementOrder === \"quadratic\") {\n              const boundarySides = {\n                0: [0], // Node at the left side of the reference element\n                2: [2], // Node at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant value to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                nodeConstraintCode[globalNodeIndex] = 1;\n                boundaryValues[globalNodeIndex] = value;\n              });\n            }\n          });\n        }\n      });\n    } else if (this.meshDimension === \"2D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        if (this.boundaryConditions[boundaryKey][0] === \"constantValue\") {\n          const value = this.boundaryConditions[boundaryKey][1];\n          debugLog(`Boundary ${boundaryKey}: Applying constant value of ${value} (Dirichlet condition)`);\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            if (this.elementOrder === \"linear\") {\n              const boundarySides = {\n                0: [0, 2], // Nodes at the bottom side of the reference element\n                1: [0, 1], // Nodes at the left side of the reference element\n                2: [1, 3], // Nodes at the top side of the reference element\n                3: [2, 3], // Nodes at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant value to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                nodeConstraintCode[globalNodeIndex] = 1;\n                boundaryValues[globalNodeIndex] = value;\n              });\n            } else if (this.elementOrder === \"quadratic\") {\n              const boundarySides = {\n                0: [0, 3, 6], // Nodes at the bottom side of the reference element\n                1: [0, 1, 2], // Nodes at the left side of the reference element\n                2: [2, 5, 8], // Nodes at the top side of the reference element\n                3: [6, 7, 8], // Nodes at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant value to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                nodeConstraintCode[globalNodeIndex] = 1;\n                boundaryValues[globalNodeIndex] = value;\n              });\n            }\n          });\n        }\n      });\n    }\n  }\n}\n","/**\n * ════════════════════════════════════════════════════════════\n *  FEAScript Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.1.4 | https://feascript.com\n * ════════════════════════════════════════════════════════════\n */\n\n// Internal imports\nimport { GenericBoundaryConditions } from \"./genericBoundaryConditionsScript.js\";\nimport {\n  initializeFEA,\n  performIsoparametricMapping1D,\n  performIsoparametricMapping2D,\n} from \"../mesh/meshUtilsScript.js\";\nimport { basicLog, debugLog } from \"../utilities/loggingScript.js\";\n\n// Base viscous term that remains when eikonal equation is fully activated\nconst baseEikonalViscousTerm = 1e-2;\n\n/**\n * Function to assemble the Jacobian matrix and residuals vector for the front propagation model\n * @param {object} meshData - Object containing prepared mesh data\n * @param {object} boundaryConditions - Object containing boundary conditions for the finite element analysis\n * @param {array} solutionVector - The solution vector for non-linear equations\n * @param {number} eikonalActivationFlag - Activation parameter for the eikonal equation\n * @returns {object}  An object containing:\n *  - jacobianMatrix: The assembled Jacobian matrix\n *  - residualVector: The assembled residual vector\n */\nexport function assembleFrontPropagationMat(\n  meshData,\n  boundaryConditions,\n  solutionVector,\n  eikonalActivationFlag\n) {\n  basicLog(\"Starting front propagation matrix assembly...\");\n\n  // Calculate eikonal viscous term\n  let eikonalViscousTerm = 1 - eikonalActivationFlag + baseEikonalViscousTerm; // Viscous term for the front propagation (eikonal) equation\n  debugLog(`eikonalViscousTerm: ${eikonalViscousTerm}`);\n  debugLog(`eikonalActivationFlag: ${eikonalActivationFlag}`);\n\n  // Extract mesh data\n  const {\n    nodesXCoordinates,\n    nodesYCoordinates,\n    nop,\n    boundaryElements,\n    totalElements,\n    meshDimension,\n    elementOrder,\n  } = meshData;\n\n  // Initialize FEA components\n  const FEAData = initializeFEA(meshData);\n  const {\n    residualVector,\n    jacobianMatrix,\n    localToGlobalMap,\n    basisFunctions,\n    gaussPoints,\n    gaussWeights,\n    numNodes,\n  } = FEAData;\n\n  // Matrix assembly\n  for (let elementIndex = 0; elementIndex < totalElements; elementIndex++) {\n    // Map local element nodes to global mesh nodes\n    for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n      // Subtract 1 from nop in order to start numbering from 0\n      localToGlobalMap[localNodeIndex] = nop[elementIndex][localNodeIndex] - 1;\n    }\n\n    // Loop over Gauss points\n    for (let gaussPointIndex1 = 0; gaussPointIndex1 < gaussPoints.length; gaussPointIndex1++) {\n      // 1D front propagation (eikonal) equation\n      if (meshDimension === \"1D\") {\n        // Unsupported 1D front propagation\n        errorLog(\"1D front propagation is not yet supported\");\n\n        // Get basis functions for the current Gauss point\n        let basisFunctionsAndDerivatives = basisFunctions.getBasisFunctions(gaussPoints[gaussPointIndex1]);\n\n        // Perform isoparametric mapping\n        const mappingResult = performIsoparametricMapping1D({\n          basisFunction: basisFunctionsAndDerivatives.basisFunction,\n          basisFunctionDerivKsi: basisFunctionsAndDerivatives.basisFunctionDerivKsi,\n          nodesXCoordinates,\n          localToGlobalMap,\n          numNodes,\n        });\n\n        // Extract mapping results\n        const { detJacobian, basisFunctionDerivX } = mappingResult;\n        const basisFunction = basisFunctionsAndDerivatives.basisFunction;\n\n        // Calculate solution derivative\n        let solutionDerivX = 0;\n        for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n          solutionDerivX +=\n            solutionVector[localToGlobalMap[localNodeIndex]] * basisFunctionDerivX[localNodeIndex];\n        }\n\n        // Computation of Galerkin's residuals and Jacobian matrix\n        for (let localNodeIndex1 = 0; localNodeIndex1 < numNodes; localNodeIndex1++) {\n          let localToGlobalMap1 = localToGlobalMap[localNodeIndex1];\n          // residualVector\n          // TODO residualVector calculation here\n\n          for (let localNodeIndex2 = 0; localNodeIndex2 < numNodes; localNodeIndex2++) {\n            let localToGlobalMap2 = localToGlobalMap[localNodeIndex2];\n            // jacobianMatrix\n            // TODO jacobianMatrix calculation here\n          }\n        }\n      }\n      // 2D front propagation (eikonal) equation\n      else if (meshDimension === \"2D\") {\n        for (let gaussPointIndex2 = 0; gaussPointIndex2 < gaussPoints.length; gaussPointIndex2++) {\n          // Get basis functions for the current Gauss point\n          let basisFunctionsAndDerivatives = basisFunctions.getBasisFunctions(\n            gaussPoints[gaussPointIndex1],\n            gaussPoints[gaussPointIndex2]\n          );\n\n          // Perform isoparametric mapping\n          const mappingResult = performIsoparametricMapping2D({\n            basisFunction: basisFunctionsAndDerivatives.basisFunction,\n            basisFunctionDerivKsi: basisFunctionsAndDerivatives.basisFunctionDerivKsi,\n            basisFunctionDerivEta: basisFunctionsAndDerivatives.basisFunctionDerivEta,\n            nodesXCoordinates,\n            nodesYCoordinates,\n            localToGlobalMap,\n            numNodes,\n          });\n\n          // Extract mapping results\n          const { detJacobian, basisFunctionDerivX, basisFunctionDerivY } = mappingResult;\n          const basisFunction = basisFunctionsAndDerivatives.basisFunction;\n\n          // Calculate solution derivatives\n          let solutionDerivX = 0;\n          let solutionDerivY = 0;\n          for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n            solutionDerivX +=\n              solutionVector[localToGlobalMap[localNodeIndex]] * basisFunctionDerivX[localNodeIndex];\n            solutionDerivY +=\n              solutionVector[localToGlobalMap[localNodeIndex]] * basisFunctionDerivY[localNodeIndex];\n          }\n\n          // Computation of Galerkin's residuals and Jacobian matrix\n          for (let localNodeIndex1 = 0; localNodeIndex1 < numNodes; localNodeIndex1++) {\n            let localToGlobalMap1 = localToGlobalMap[localNodeIndex1];\n\n            // residualVector: Viscous term contribution (to stabilize the solution)\n            residualVector[localToGlobalMap1] +=\n              eikonalViscousTerm *\n                gaussWeights[gaussPointIndex1] *\n                gaussWeights[gaussPointIndex2] *\n                detJacobian *\n                basisFunctionDerivX[localNodeIndex1] *\n                solutionDerivX +\n              eikonalViscousTerm *\n                gaussWeights[gaussPointIndex1] *\n                gaussWeights[gaussPointIndex2] *\n                detJacobian *\n                basisFunctionDerivY[localNodeIndex1] *\n                solutionDerivY;\n\n            // residualVector: Eikonal equation contribution\n            if (eikonalActivationFlag !== 0) {\n              residualVector[localToGlobalMap1] +=\n                eikonalActivationFlag *\n                (gaussWeights[gaussPointIndex1] *\n                  gaussWeights[gaussPointIndex2] *\n                  detJacobian *\n                  basisFunction[localNodeIndex1] *\n                  Math.sqrt(solutionDerivX ** 2 + solutionDerivY ** 2) -\n                  gaussWeights[gaussPointIndex1] *\n                    gaussWeights[gaussPointIndex2] *\n                    detJacobian *\n                    basisFunction[localNodeIndex1]);\n            }\n\n            for (let localNodeIndex2 = 0; localNodeIndex2 < numNodes; localNodeIndex2++) {\n              let localToGlobalMap2 = localToGlobalMap[localNodeIndex2];\n\n              // jacobianMatrix: Viscous term contribution\n              jacobianMatrix[localToGlobalMap1][localToGlobalMap2] +=\n                -eikonalViscousTerm *\n                gaussWeights[gaussPointIndex1] *\n                gaussWeights[gaussPointIndex2] *\n                detJacobian *\n                (basisFunctionDerivX[localNodeIndex1] * basisFunctionDerivX[localNodeIndex2] +\n                  basisFunctionDerivY[localNodeIndex1] * basisFunctionDerivY[localNodeIndex2]);\n\n              // jacobianMatrix: Eikonal equation contribution\n              if (eikonalActivationFlag !== 0) {\n                jacobianMatrix[localToGlobalMap1][localToGlobalMap2] +=\n                  eikonalActivationFlag *\n                    (-(\n                      detJacobian *\n                      solutionDerivX *\n                      basisFunction[localNodeIndex1] *\n                      gaussWeights[gaussPointIndex1] *\n                      gaussWeights[gaussPointIndex2]\n                    ) /\n                      Math.sqrt(solutionDerivX ** 2 + solutionDerivY ** 2 + 1e-8)) *\n                    basisFunctionDerivX[localNodeIndex2] -\n                  eikonalActivationFlag *\n                    ((detJacobian *\n                      solutionDerivY *\n                      basisFunction[localNodeIndex1] *\n                      gaussWeights[gaussPointIndex1] *\n                      gaussWeights[gaussPointIndex2]) /\n                      Math.sqrt(solutionDerivX ** 2 + solutionDerivY ** 2 + 1e-8)) *\n                    basisFunctionDerivY[localNodeIndex2];\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Apply boundary conditions\n  const genericBoundaryConditions = new GenericBoundaryConditions(\n    boundaryConditions,\n    boundaryElements,\n    nop,\n    meshDimension,\n    elementOrder\n  );\n\n  // Impose Dirichlet boundary conditions\n  genericBoundaryConditions.imposeDirichletBoundaryConditions(residualVector, jacobianMatrix);\n  basicLog(\"Front propagation matrix assembly completed\");\n\n  return {\n    jacobianMatrix,\n    residualVector,\n  };\n}\n\n/**\n * Function to assemble the local Jacobian matrix and residual vector for the front propagation model when using the frontal system solver\n * @param {number} elementIndex - Index of the element being processed\n * @param {array} nop - Nodal connectivity array (element-to-node mapping)\n * @param {object} meshData - Object containing prepared mesh data\n * @param {object} basisFunctions - Object containing basis functions and their derivatives\n * @param {object} FEAData - Object containing FEA-related data\n * @param {array} solutionVector - The solution vector for non-linear equations\n * @param {number} eikonalActivationFlag - Activation parameter for the eikonal equation\n * @returns {object} An object containing:\n *  - localJacobianMatrix: Local Jacobian matrix\n *  - residualVector: Residual vector contributions\n *  - ngl: Array mapping local node indices to global node indices\n */\nexport function assembleFrontPropagationFront({\n  elementIndex,\n  nop,\n  meshData,\n  basisFunctions,\n  FEAData,\n  solutionVector,\n  eikonalActivationFlag,\n}) {\n  // Extract numerical integration parameters and mesh coordinates\n  const { gaussPoints, gaussWeights, numNodes } = FEAData;\n  const { nodesXCoordinates, nodesYCoordinates, meshDimension } = meshData;\n\n  // Calculate eikonal viscous term\n  let eikonalViscousTerm = 1 - eikonalActivationFlag + baseEikonalViscousTerm; // Viscous term for the front propagation (eikonal) equation\n\n  // Initialize local Jacobian matrix and local residual vector\n  const localJacobianMatrix = Array(numNodes)\n    .fill()\n    .map(() => Array(numNodes).fill(0));\n  const localResidualVector = Array(numNodes).fill(0);\n\n  // Build the mapping from local node indices to global node indices\n  const ngl = Array(numNodes);\n  const localToGlobalMap = Array(numNodes);\n  for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n    ngl[localNodeIndex] = Math.abs(nop[elementIndex][localNodeIndex]);\n    localToGlobalMap[localNodeIndex] = Math.abs(nop[elementIndex][localNodeIndex]) - 1;\n  }\n\n  // Loop over Gauss points\n  for (let gaussPointIndex1 = 0; gaussPointIndex1 < gaussPoints.length; gaussPointIndex1++) {\n    // 1D front propagation (eikonal) equation\n    if (meshDimension === \"1D\") {\n      // Unsupported 1D front propagation\n      errorLog(\"1D front propagation is not yet supported\");\n\n      // Get basis functions for the current Gauss point\n      let basisFunctionsAndDerivatives = basisFunctions.getBasisFunctions(gaussPoints[gaussPointIndex1]);\n\n      // Perform isoparametric mapping\n      const mappingResult = performIsoparametricMapping1D({\n        basisFunction: basisFunctionsAndDerivatives.basisFunction,\n        basisFunctionDerivKsi: basisFunctionsAndDerivatives.basisFunctionDerivKsi,\n        nodesXCoordinates,\n        localToGlobalMap,\n        numNodes,\n      });\n\n      // Extract mapping results\n      const { detJacobian, basisFunctionDerivX } = mappingResult;\n      const basisFunction = basisFunctionsAndDerivatives.basisFunction;\n\n      // Calculate solution derivative\n      let solutionDerivX = 0;\n      for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n        solutionDerivX +=\n          solutionVector[localToGlobalMap[localNodeIndex]] * basisFunctionDerivX[localNodeIndex];\n      }\n\n      // Computation of Galerkin's residuals and Jacobian matrix\n      for (let localNodeIndex1 = 0; localNodeIndex1 < numNodes; localNodeIndex1++) {\n        let localToGlobalMap1 = localToGlobalMap[localNodeIndex1];\n        // residualVector\n        // TODO residualVector calculation here\n\n        for (let localNodeIndex2 = 0; localNodeIndex2 < numNodes; localNodeIndex2++) {\n          let localToGlobalMap2 = localToGlobalMap[localNodeIndex2];\n          // localJacobianMatrix\n          // TODO localJacobianMatrix calculation here\n        }\n      }\n      // 2D front propagation (eikonal) equation\n    } else if (meshDimension === \"2D\") {\n      for (let gaussPointIndex2 = 0; gaussPointIndex2 < gaussPoints.length; gaussPointIndex2++) {\n        // Get basis functions for the current Gauss point\n        const { basisFunction, basisFunctionDerivKsi, basisFunctionDerivEta } =\n          basisFunctions.getBasisFunctions(gaussPoints[gaussPointIndex1], gaussPoints[gaussPointIndex2]);\n\n        // Perform isoparametric mapping\n        const { detJacobian, basisFunctionDerivX, basisFunctionDerivY } = performIsoparametricMapping2D({\n          basisFunction,\n          basisFunctionDerivKsi,\n          basisFunctionDerivEta,\n          nodesXCoordinates,\n          nodesYCoordinates,\n          localToGlobalMap,\n          numNodes,\n        });\n\n        // Calculate solution derivatives\n        let solutionDerivX = 0;\n        let solutionDerivY = 0;\n        for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n          solutionDerivX +=\n            solutionVector[localToGlobalMap[localNodeIndex]] * basisFunctionDerivX[localNodeIndex];\n          solutionDerivY +=\n            solutionVector[localToGlobalMap[localNodeIndex]] * basisFunctionDerivY[localNodeIndex];\n        }\n\n        // Computation of Galerkin's residuals and Jacobian matrix\n        for (let localNodeIndex1 = 0; localNodeIndex1 < numNodes; localNodeIndex1++) {\n          let localToGlobalMap1 = localToGlobalMap[localNodeIndex1];\n          // Viscous term contribution\n          localResidualVector[localNodeIndex1] +=\n            eikonalViscousTerm *\n              gaussWeights[gaussPointIndex1] *\n              gaussWeights[gaussPointIndex2] *\n              detJacobian *\n              basisFunctionDerivX[localNodeIndex1] *\n              solutionDerivX +\n            eikonalViscousTerm *\n              gaussWeights[gaussPointIndex1] *\n              gaussWeights[gaussPointIndex2] *\n              detJacobian *\n              basisFunctionDerivY[localNodeIndex1] *\n              solutionDerivY;\n\n          // Eikonal equation contribution\n          if (eikonalActivationFlag !== 0) {\n            localResidualVector[localNodeIndex1] +=\n              eikonalActivationFlag *\n              (gaussWeights[gaussPointIndex1] *\n                gaussWeights[gaussPointIndex2] *\n                detJacobian *\n                basisFunction[localNodeIndex1] *\n                Math.sqrt(solutionDerivX ** 2 + solutionDerivY ** 2) -\n                gaussWeights[gaussPointIndex1] *\n                  gaussWeights[gaussPointIndex2] *\n                  detJacobian *\n                  basisFunction[localNodeIndex1]);\n          }\n\n          for (let localNodeIndex2 = 0; localNodeIndex2 < numNodes; localNodeIndex2++) {\n            // Viscous term contribution\n            localJacobianMatrix[localNodeIndex1][localNodeIndex2] -=\n              eikonalViscousTerm *\n              gaussWeights[gaussPointIndex1] *\n              gaussWeights[gaussPointIndex2] *\n              detJacobian *\n              (basisFunctionDerivX[localNodeIndex1] * basisFunctionDerivX[localNodeIndex2] +\n                basisFunctionDerivY[localNodeIndex1] * basisFunctionDerivY[localNodeIndex2]);\n\n            // Eikonal equation contribution\n            if (eikonalActivationFlag !== 0) {\n              localJacobianMatrix[localNodeIndex1][localNodeIndex2] +=\n                eikonalActivationFlag *\n                  (-(\n                    detJacobian *\n                    solutionDerivX *\n                    basisFunction[localNodeIndex1] *\n                    gaussWeights[gaussPointIndex1] *\n                    gaussWeights[gaussPointIndex2]\n                  ) /\n                    Math.sqrt(solutionDerivX ** 2 + solutionDerivY ** 2 + 1e-8)) *\n                  basisFunctionDerivX[localNodeIndex2] -\n                eikonalActivationFlag *\n                  ((detJacobian *\n                    solutionDerivY *\n                    basisFunction[localNodeIndex1] *\n                    gaussWeights[gaussPointIndex1] *\n                    gaussWeights[gaussPointIndex2]) /\n                    Math.sqrt(solutionDerivX ** 2 + solutionDerivY ** 2 + 1e-8)) *\n                  basisFunctionDerivY[localNodeIndex2];\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return { localJacobianMatrix, localResidualVector, ngl };\n}\n","/**\n * ════════════════════════════════════════════════════════════\n *  FEAScript Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.1.4 | https://feascript.com\n * ════════════════════════════════════════════════════════════\n */\n\n// Internal imports\nimport { BasisFunctions } from \"../mesh/basisFunctionsScript.js\";\nimport { initializeFEA } from \"../mesh/meshUtilsScript.js\";\nimport { assembleHeatConductionFront } from \"../models/heatConductionScript.js\";\nimport { ThermalBoundaryConditions } from \"../models/thermalBoundaryConditionsScript.js\";\nimport { assembleFrontPropagationFront } from \"../models/frontPropagationScript.js\";\nimport { GenericBoundaryConditions } from \"../models/genericBoundaryConditionsScript.js\";\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n// Create object templates\nconst frontalData = {};\nconst frontalState = {};\nconst elementData = { currentElementIndex: 0 };\nconst frontStorage = {};\nlet basisFunctions;\n\n/**\n * Function to run the frontal solver and obtain results for plotting\n * @param {function} assembleFront - Matrix assembler based on the physical model\n * @param {object} meshData - Object containing mesh data\n * @param {object} boundaryConditions - Object containing boundary conditions\n * @param {object} [options] - Additional options for the solver\n * @returns {object} An object containing the solution vector and node coordinates\n */\nexport function runFrontalSolver(assembleFront, meshData, boundaryConditions, options = {}) {\n  // Initialize FEA components\n  const FEAData = initializeFEA(meshData);\n  const totalNodes = meshData.nodesXCoordinates.length;\n  const numElements = meshData.totalElements;\n  const numNodes = FEAData.numNodes;\n\n  // Calculate required array sizes\n  initializeFrontalArrays(numNodes, numElements);\n\n  // Start timing for system solving (frontal algorithm)\n  basicLog(\"Solving system using frontal...\");\n  console.time(\"systemSolving\");\n\n  // Initialize basis functions\n  basisFunctions = new BasisFunctions({\n    meshDimension: meshData.meshDimension,\n    elementOrder: meshData.elementOrder,\n  });\n\n  // Copy node connectivity array into frontalData storage\n  for (let elementIndex = 0; elementIndex < meshData.totalElements; elementIndex++) {\n    for (let nodeIndex = 0; nodeIndex < FEAData.numNodes; nodeIndex++) {\n      frontalData.nodalNumbering[elementIndex][nodeIndex] = meshData.nop[elementIndex][nodeIndex];\n    }\n  }\n\n  // Apply Dirichlet-type boundary conditions\n  // Initialize all nodes with no boundary condition\n  for (let nodeIndex = 0; nodeIndex < meshData.nodesXCoordinates.length; nodeIndex++) {\n    frontalData.nodeConstraintCode[nodeIndex] = 0;\n    frontalData.boundaryValues[nodeIndex] = 0;\n  }\n\n  // Handle Dirichlet-type boundary conditions differently based on which solver is being used\n  let dirichletBoundaryConditionsHandler;\n  // Solid heat transfer model (heatConductionScript solver)\n  if (assembleFront === assembleHeatConductionFront) {\n    dirichletBoundaryConditionsHandler = new ThermalBoundaryConditions(\n      boundaryConditions,\n      meshData.boundaryElements,\n      meshData.nop,\n      meshData.meshDimension,\n      meshData.elementOrder\n    );\n\n    dirichletBoundaryConditionsHandler.imposeConstantTempBoundaryConditionsFront(\n      frontalData.nodeConstraintCode,\n      frontalData.boundaryValues\n    );\n    // Front propagation model (frontPropagationScript solver)\n  } else if (assembleFront === assembleFrontPropagationFront) {\n    dirichletBoundaryConditionsHandler = new GenericBoundaryConditions(\n      boundaryConditions,\n      meshData.boundaryElements,\n      meshData.nop,\n      meshData.meshDimension,\n      meshData.elementOrder\n    );\n\n    dirichletBoundaryConditionsHandler.imposeConstantValueBoundaryConditionsFront(\n      frontalData.nodeConstraintCode,\n      frontalData.boundaryValues\n    );\n  }\n  // Initialize global residual vector\n  for (let nodeIndex = 0; nodeIndex < meshData.nodesXCoordinates.length; nodeIndex++) {\n    frontalData.globalResidualVector[nodeIndex] = 0;\n  }\n\n  frontalState.totalNodes = meshData.nodesXCoordinates.length;\n  frontalState.writeFlag = 0;\n  frontalState.transformationFlag = 1;\n  frontalState.determinant = 1;\n\n  for (let elementIndex = 0; elementIndex < meshData.totalElements; elementIndex++) {\n    frontalState.nodesPerElement[elementIndex] = FEAData.numNodes;\n  }\n\n  // Parameters for non-linear assemblers\n  frontalState.currentSolutionVector = options.solutionVector;\n  frontalState.eikonalActivationFlag = options.eikonalActivationFlag;\n\n  // Pass assembleFront and dirichletBoundaryConditionsHandler to runFrontalAlgorithm\n  runFrontalAlgorithm(meshData, FEAData, dirichletBoundaryConditionsHandler, assembleFront);\n\n  // Copy solution\n  for (let nodeIndex = 0; nodeIndex < meshData.nodesXCoordinates.length; nodeIndex++) {\n    frontalData.solutionVector[nodeIndex] = frontalState.globalSolutionVector[nodeIndex];\n  }\n\n  // Output results to console for debugging\n  const { nodesXCoordinates, nodesYCoordinates } = meshData;\n  for (let nodeIndex = 0; nodeIndex < meshData.nodesXCoordinates.length; nodeIndex++) {\n    if (meshData.meshDimension === \"1D\") {\n      // 1D case - only output X coordinates and temperature\n      debugLog(\n        `${nodesXCoordinates[nodeIndex].toExponential(5)}  ${frontalData.solutionVector[\n          nodeIndex\n        ].toExponential(5)}`\n      );\n    } else {\n      // 2D case - output X, Y coordinates and temperature\n      debugLog(\n        `${nodesXCoordinates[nodeIndex].toExponential(5)}  ${nodesYCoordinates[nodeIndex].toExponential(\n          5\n        )}  ${frontalData.solutionVector[nodeIndex].toExponential(5)}`\n      );\n    }\n  }\n\n  console.timeEnd(\"systemSolving\");\n  basicLog(\"System solved successfully\");\n\n  const { nodesXCoordinates: finalNodesX, nodesYCoordinates: finalNodesY } = meshData;\n  return {\n    solutionVector: frontalData.solutionVector.slice(0, totalNodes),\n    nodesCoordinates: {\n      nodesXCoordinates: finalNodesX,\n      nodesYCoordinates: finalNodesY,\n    },\n  };\n}\n\n/**\n * Function to initialize arrays dynamically based on problem size\n * @param {number} numNodes - Number of nodes per element\n * @param {number} numElements - Number of elements in the mesh\n */\nfunction initializeFrontalArrays(numNodes, numElements) {\n  // Use the actual number of elements from the mesh\n  frontalData.nodalNumbering = Array(numElements)\n    .fill()\n    .map(() => Array(numNodes).fill(0));\n  frontalData.nodeConstraintCode = Array(numNodes).fill(0);\n  frontalData.boundaryValues = Array(numNodes).fill(0);\n  frontalData.globalResidualVector = Array(numNodes).fill(0);\n  frontalData.solutionVector = Array(numNodes).fill(0);\n  frontalData.topologyData = Array(numElements).fill(0);\n  frontalData.lateralData = Array(numElements).fill(0);\n\n  // Initialize frontalState arrays\n  frontalState.writeFlag = 0;\n  frontalState.totalNodes = numNodes;\n  frontalState.transformationFlag = 0;\n  frontalState.nodesPerElement = Array(numElements).fill(0);\n  frontalState.determinant = 1;\n\n  // For matrix operations, estimate required size based on problem complexity\n  const systemSize = Math.max(numNodes, 2000);\n  frontalState.globalSolutionVector = Array(systemSize).fill(0);\n  frontalState.frontDataIndex = 0;\n\n  // Initialize elementData arrays\n  elementData.localJacobianMatrix = Array(numNodes)\n    .fill()\n    .map(() => Array(numNodes).fill(0));\n  elementData.currentElementIndex = 0;\n\n  // Initialize frontStorage arrays\n  const frontSize = estimateFrontSize(numNodes, numElements);\n  frontStorage.frontValues = Array(frontSize).fill(0);\n  frontStorage.columnHeaders = Array(systemSize).fill(0);\n  frontStorage.pivotRow = Array(systemSize).fill(0);\n  frontStorage.pivotData = Array(frontSize).fill(0);\n}\n\n/**\n * Function to estimate the required front size\n * @param {number} numNodes - Number of of nodes per element\n * @param {number} numElements - Number of elements in the mesh\n * @returns {number} Estimated front size\n */\nfunction estimateFrontSize(numNodes, numElements) {\n  const frontWidthEstimate = Math.max(Math.ceil(Math.sqrt(numElements)) * numNodes, numNodes * 2);\n  return frontWidthEstimate * numElements;\n}\n// Old function to estimate the required front size\n// function estimateFrontSize(numNodes, numElements, numNodes) {\n//   const frontWidthEstimate = Math.ceil(Math.sqrt(numElements) * numNodes * 2);\n//   const frontSize = frontWidthEstimate * numNodes * 4;\n//   return Math.max(frontSize, 10000);\n// }\n\n/**\n * Function to compute local Jacobian matrix and local residual vector\n * @param {object} meshData - Object containing mesh data\n * @param {object} FEAData - Object containing FEA-related data\n * @param {object} thermalBoundaryConditions - Object containing thermal boundary conditions\n * @param {function} assembleFront - Matrix assembler based on the physical model\n */\nfunction assembleElementContribution(meshData, FEAData, thermalBoundaryConditions, assembleFront) {\n  const elementIndex = elementData.currentElementIndex - 1;\n\n  // Guard against out-of-range indices\n  if (elementIndex < 0 || elementIndex >= meshData.totalElements) {\n    errorLog(`Skipping out-of-range elementIndex=${elementIndex} (totalElements=${meshData.totalElements})`);\n    return false;\n  }\n\n  // Domain terms\n  const { localJacobianMatrix, localResidualVector, ngl } = assembleFront({\n    elementIndex,\n    nop: frontalData.nodalNumbering,\n    meshData,\n    basisFunctions: basisFunctions,\n    FEAData,\n    // These are ignored by linear assemblers\n    solutionVector: frontalState.currentSolutionVector,\n    eikonalActivationFlag: frontalState.eikonalActivationFlag,\n  });\n\n  // Handle Robin-type boundary conditions differently based on which solver is being used\n  let boundaryLocalJacobianMatrix = Array(FEAData.numNodes)\n    .fill()\n    .map(() => Array(FEAData.numNodes).fill(0));\n  let boundaryResidualVector = Array(FEAData.numNodes).fill(0);\n\n  // heatConductionScript solver\n  if (assembleFront === assembleHeatConductionFront) {\n    // Check if this element is on a Robin-type boundary\n    let isOnRobinTypeBoundary = false;\n    for (const boundaryKey in meshData.boundaryElements) {\n      if (\n        thermalBoundaryConditions.boundaryConditions[boundaryKey]?.[0] === \"convection\" &&\n        meshData.boundaryElements[boundaryKey].some(([elemIdx, _]) => elemIdx === elementIndex)\n      ) {\n        isOnRobinTypeBoundary = true;\n        break;\n      }\n    }\n\n    // Only calculate Robin-type for elements when required\n    if (isOnRobinTypeBoundary) {\n      const { gaussPoints, gaussWeights } = FEAData;\n      const result = thermalBoundaryConditions.imposeConvectionBoundaryConditionsFront(\n        elementIndex,\n        meshData.nodesXCoordinates,\n        meshData.nodesYCoordinates,\n        gaussPoints,\n        gaussWeights,\n        basisFunctions\n      );\n      boundaryLocalJacobianMatrix = result.localJacobianMatrix;\n      boundaryResidualVector = result.localResidualVector;\n    }\n  } else if (assembleFront === assembleFrontPropagationFront) {\n    // For now, no Robin-type boundary conditions exist for any other solver\n  }\n\n  // Combine domain and boundary contributions\n  for (let localNodeI = 0; localNodeI < FEAData.numNodes; localNodeI++) {\n    for (let localNodeJ = 0; localNodeJ < FEAData.numNodes; localNodeJ++) {\n      elementData.localJacobianMatrix[localNodeI][localNodeJ] =\n        localJacobianMatrix[localNodeI][localNodeJ] + boundaryLocalJacobianMatrix[localNodeI][localNodeJ];\n    }\n  }\n\n  // Assemble local element residual\n  for (let localNodeIndex = 0; localNodeIndex < FEAData.numNodes; localNodeIndex++) {\n    const globalNodeIndex = ngl[localNodeIndex] - 1;\n    frontalData.globalResidualVector[globalNodeIndex] +=\n      localResidualVector[localNodeIndex] + boundaryResidualVector[localNodeIndex];\n  }\n\n  return true;\n}\n\n/**\n * Function to implement the frontal solver algorithm\n * @param {object} meshData - Object containing mesh data\n * @param {object} FEAData - Object containing FEA-related data\n * @param {object} thermalBoundaryConditions - Object containing thermal boundary conditions\n * @param {function} assembleFront - Matrix assembler based on the physical model\n */\nfunction runFrontalAlgorithm(meshData, FEAData, thermalBoundaryConditions, assembleFront) {\n  // Allocate local arrays dynamically\n  const totalElements = meshData.totalElements;\n  const numNodes = meshData.nodesXCoordinates.length;\n  const systemSize = Math.max(numNodes, frontalState.globalSolutionVector.length);\n  let localDestination = Array(FEAData.numNodes).fill(0);\n  let rowDestination = Array(FEAData.numNodes).fill(0);\n  let rowHeaders = Array(systemSize).fill(0);\n  let pivotRowIndices = Array(systemSize).fill(0);\n  let pivotColumnIndices = Array(systemSize).fill(0);\n  let modifiedRows = Array(systemSize).fill(0);\n  let pivotColumn = Array(systemSize).fill(0);\n  let frontMatrix = Array(systemSize)\n    .fill()\n    .map(() => Array(systemSize).fill(0));\n  let rowSwapCount = Array(numNodes).fill(0);\n  let columnSwapCount = Array(numNodes).fill(0);\n  let lastAppearanceCheck = Array(numNodes).fill(0);\n  let pivotColumnGlobalIndex; // Pivot column global index\n\n  let frontDataCounter = 1;\n  frontalState.writeFlag++;\n  let pivotDataIndex = 1;\n  let summedRows = 1;\n  elementData.currentElementIndex = 0;\n\n  for (let nodeIndex = 0; nodeIndex < frontalState.totalNodes; nodeIndex++) {\n    rowSwapCount[nodeIndex] = 0;\n    columnSwapCount[nodeIndex] = 0;\n  }\n\n  if (frontalState.transformationFlag !== 0) {\n    // Prefront: find last appearance of each node\n    for (let nodeIndex = 0; nodeIndex < frontalState.totalNodes; nodeIndex++) {\n      lastAppearanceCheck[nodeIndex] = 0;\n    }\n\n    for (let elementIndex = 0; elementIndex < totalElements; elementIndex++) {\n      let reverseElementIndex = totalElements - elementIndex - 1;\n      for (\n        let localNodeIndex = 0;\n        localNodeIndex < frontalState.nodesPerElement[reverseElementIndex];\n        localNodeIndex++\n      ) {\n        let globalNodeIndex = frontalData.nodalNumbering[reverseElementIndex][localNodeIndex];\n        if (lastAppearanceCheck[globalNodeIndex - 1] === 0) {\n          lastAppearanceCheck[globalNodeIndex - 1] = 1;\n          frontalData.nodalNumbering[reverseElementIndex][localNodeIndex] =\n            -frontalData.nodalNumbering[reverseElementIndex][localNodeIndex];\n        }\n      }\n    }\n  }\n\n  frontalState.transformationFlag = 0;\n  let columnCount = 0;\n  let rowCount = 0;\n\n  for (let i = 0; i < systemSize; i++) {\n    for (let j = 0; j < systemSize; j++) {\n      frontMatrix[j][i] = 0;\n    }\n  }\n\n  while (true) {\n    // Assemble a new element only while we still have elements\n    let assembled = false;\n    let numElementNodes = 0;\n    let numElementColumns = 0;\n\n    if (elementData.currentElementIndex < totalElements) {\n      elementData.currentElementIndex++;\n      assembled = assembleElementContribution(meshData, FEAData, thermalBoundaryConditions, assembleFront);\n    }\n\n    if (assembled) {\n      const currentElement = elementData.currentElementIndex;\n      numElementNodes = frontalState.nodesPerElement[currentElement - 1];\n      numElementColumns = frontalState.nodesPerElement[currentElement - 1];\n\n      for (let localNodeIndex = 0; localNodeIndex < numElementColumns; localNodeIndex++) {\n        let globalNodeIndex = frontalData.nodalNumbering[currentElement - 1][localNodeIndex];\n        let columnIndex;\n\n        if (columnCount === 0) {\n          columnCount++;\n          localDestination[localNodeIndex] = columnCount;\n          frontStorage.columnHeaders[columnCount - 1] = globalNodeIndex;\n        } else {\n          for (columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n            if (Math.abs(globalNodeIndex) === Math.abs(frontStorage.columnHeaders[columnIndex])) break;\n          }\n\n          if (columnIndex === columnCount) {\n            columnCount++;\n            localDestination[localNodeIndex] = columnCount;\n            frontStorage.columnHeaders[columnCount - 1] = globalNodeIndex;\n          } else {\n            localDestination[localNodeIndex] = columnIndex + 1;\n            frontStorage.columnHeaders[columnIndex] = globalNodeIndex;\n          }\n        }\n\n        let rowIndex;\n        if (rowCount === 0) {\n          rowCount++;\n          rowDestination[localNodeIndex] = rowCount;\n          rowHeaders[rowCount - 1] = globalNodeIndex;\n        } else {\n          for (rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n            if (Math.abs(globalNodeIndex) === Math.abs(rowHeaders[rowIndex])) break;\n          }\n\n          if (rowIndex === rowCount) {\n            rowCount++;\n            rowDestination[localNodeIndex] = rowCount;\n            rowHeaders[rowCount - 1] = globalNodeIndex;\n          } else {\n            rowDestination[localNodeIndex] = rowIndex + 1;\n            rowHeaders[rowIndex] = globalNodeIndex;\n          }\n        }\n      }\n\n      if (rowCount > systemSize || columnCount > systemSize) {\n        errorLog(\"Error: systemSize not large enough\");\n        return;\n      }\n\n      for (let localColumnIndex = 0; localColumnIndex < numElementColumns; localColumnIndex++) {\n        let frontColumnIndex = localDestination[localColumnIndex];\n        for (let localRowIndex = 0; localRowIndex < numElementNodes; localRowIndex++) {\n          let frontRowIndex = rowDestination[localRowIndex];\n          frontMatrix[frontRowIndex - 1][frontColumnIndex - 1] +=\n            elementData.localJacobianMatrix[localRowIndex][localColumnIndex];\n        }\n      }\n    }\n\n    // Pivoting/elimination continues whether or not a new element was assembled\n    let availableColumnCount = 0;\n    for (let columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n      if (frontStorage.columnHeaders[columnIndex] < 0) {\n        pivotColumnIndices[availableColumnCount] = columnIndex + 1;\n        availableColumnCount++;\n      }\n    }\n\n    let constrainedRowCount = 0;\n    let availableRowCount = 0;\n    for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n      let globalNodeIndex = rowHeaders[rowIndex];\n      if (globalNodeIndex < 0) {\n        pivotRowIndices[availableRowCount] = rowIndex + 1;\n        availableRowCount++;\n        let absoluteNodeIndex = Math.abs(globalNodeIndex);\n        if (frontalData.nodeConstraintCode[absoluteNodeIndex - 1] === 1) {\n          modifiedRows[constrainedRowCount] = rowIndex + 1;\n          constrainedRowCount++;\n          frontalData.nodeConstraintCode[absoluteNodeIndex - 1] = 2;\n          frontalData.globalResidualVector[absoluteNodeIndex - 1] =\n            frontalData.boundaryValues[absoluteNodeIndex - 1];\n        }\n      }\n    }\n\n    if (constrainedRowCount > 0) {\n      for (let constrainedIndex = 0; constrainedIndex < constrainedRowCount; constrainedIndex++) {\n        let rowIndex = modifiedRows[constrainedIndex] - 1;\n        let globalNodeIndex = Math.abs(rowHeaders[rowIndex]);\n        for (let columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n          frontMatrix[rowIndex][columnIndex] = 0;\n          let columnGlobalIndex = Math.abs(frontStorage.columnHeaders[columnIndex]);\n          if (columnGlobalIndex === globalNodeIndex) frontMatrix[rowIndex][columnIndex] = 1;\n        }\n      }\n    }\n\n    if (availableColumnCount > summedRows || elementData.currentElementIndex < totalElements) {\n      if (availableColumnCount === 0) {\n        errorLog(\"Error: no more rows fully summed\");\n        return;\n      }\n\n      let pivotRowIndex = pivotRowIndices[0];\n      let pivotColumnIndex = pivotColumnIndices[0];\n      let pivotValue = frontMatrix[pivotRowIndex - 1][pivotColumnIndex - 1];\n\n      if (Math.abs(pivotValue) < 1e-4) {\n        pivotValue = 0;\n        for (let columnIndex = 0; columnIndex < availableColumnCount; columnIndex++) {\n          let testColumnIndex = pivotColumnIndices[columnIndex];\n          for (let rowIndex = 0; rowIndex < availableRowCount; rowIndex++) {\n            let testRowIndex = pivotRowIndices[rowIndex];\n            let testValue = frontMatrix[testRowIndex - 1][testColumnIndex - 1];\n            if (Math.abs(testValue) > Math.abs(pivotValue)) {\n              pivotValue = testValue;\n              pivotColumnIndex = testColumnIndex;\n              pivotRowIndex = testRowIndex;\n            }\n          }\n        }\n      }\n\n      let pivotGlobalRowIndex = Math.abs(rowHeaders[pivotRowIndex - 1]);\n      pivotColumnGlobalIndex = Math.abs(frontStorage.columnHeaders[pivotColumnIndex - 1]); // Assign, don't declare\n      let permutationHelper =\n        pivotGlobalRowIndex +\n        pivotColumnGlobalIndex +\n        rowSwapCount[pivotGlobalRowIndex - 1] +\n        columnSwapCount[pivotColumnGlobalIndex - 1];\n      frontalState.determinant =\n        (frontalState.determinant * pivotValue * (-1) ** permutationHelper) / Math.abs(pivotValue);\n\n      for (let nodeIndex = 0; nodeIndex < frontalState.totalNodes; nodeIndex++) {\n        if (nodeIndex >= pivotGlobalRowIndex) rowSwapCount[nodeIndex]--;\n        if (nodeIndex >= pivotColumnGlobalIndex) columnSwapCount[nodeIndex]--;\n      }\n\n      if (Math.abs(pivotValue) < 1e-10) {\n        errorLog(\n          `Matrix singular or ill-conditioned, currentElementIndex=${elementData.currentElementIndex}, pivotGlobalRowIndex=${pivotGlobalRowIndex}, pivotColumnGlobalIndex=${pivotColumnGlobalIndex}, pivotValue=${pivotValue}`\n        );\n      }\n\n      if (pivotValue === 0) return;\n\n      for (let columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n        frontStorage.pivotRow[columnIndex] = frontMatrix[pivotRowIndex - 1][columnIndex] / pivotValue;\n      }\n\n      let rightHandSide = frontalData.globalResidualVector[pivotGlobalRowIndex - 1] / pivotValue;\n      frontalData.globalResidualVector[pivotGlobalRowIndex - 1] = rightHandSide;\n      pivotColumn[pivotRowIndex - 1] = pivotValue;\n\n      if (pivotRowIndex > 1) {\n        for (let rowIndex = 0; rowIndex < pivotRowIndex - 1; rowIndex++) {\n          let globalRowIndex = Math.abs(rowHeaders[rowIndex]);\n          let eliminationFactor = frontMatrix[rowIndex][pivotColumnIndex - 1];\n          pivotColumn[rowIndex] = eliminationFactor;\n          if (pivotColumnIndex > 1 && eliminationFactor !== 0) {\n            for (let columnIndex = 0; columnIndex < pivotColumnIndex - 1; columnIndex++) {\n              frontMatrix[rowIndex][columnIndex] -= eliminationFactor * frontStorage.pivotRow[columnIndex];\n            }\n          }\n          if (pivotColumnIndex < columnCount) {\n            for (let columnIndex = pivotColumnIndex; columnIndex < columnCount; columnIndex++) {\n              frontMatrix[rowIndex][columnIndex - 1] =\n                frontMatrix[rowIndex][columnIndex] - eliminationFactor * frontStorage.pivotRow[columnIndex];\n            }\n          }\n          frontalData.globalResidualVector[globalRowIndex - 1] -= eliminationFactor * rightHandSide;\n        }\n      }\n\n      if (pivotRowIndex < rowCount) {\n        for (let rowIndex = pivotRowIndex; rowIndex < rowCount; rowIndex++) {\n          let globalRowIndex = Math.abs(rowHeaders[rowIndex]);\n          let eliminationFactor = frontMatrix[rowIndex][pivotColumnIndex - 1];\n          pivotColumn[rowIndex] = eliminationFactor;\n          if (pivotColumnIndex > 1) {\n            for (let columnIndex = 0; columnIndex < pivotColumnIndex - 1; columnIndex++) {\n              frontMatrix[rowIndex - 1][columnIndex] =\n                frontMatrix[rowIndex][columnIndex] - eliminationFactor * frontStorage.pivotRow[columnIndex];\n            }\n          }\n          if (pivotColumnIndex < columnCount) {\n            for (let columnIndex = pivotColumnIndex; columnIndex < columnCount; columnIndex++) {\n              frontMatrix[rowIndex - 1][columnIndex - 1] =\n                frontMatrix[rowIndex][columnIndex] - eliminationFactor * frontStorage.pivotRow[columnIndex];\n            }\n          }\n          frontalData.globalResidualVector[globalRowIndex - 1] -= eliminationFactor * rightHandSide;\n        }\n      }\n\n      for (let i = 0; i < rowCount; i++) {\n        frontStorage.pivotData[pivotDataIndex + i - 1] = pivotColumn[i];\n      }\n      pivotDataIndex += rowCount;\n\n      for (let i = 0; i < rowCount; i++) {\n        frontStorage.pivotData[pivotDataIndex + i - 1] = rowHeaders[i];\n      }\n      pivotDataIndex += rowCount;\n\n      frontStorage.pivotData[pivotDataIndex - 1] = pivotRowIndex;\n      pivotDataIndex++;\n\n      for (let i = 0; i < columnCount; i++) {\n        frontStorage.frontValues[frontDataCounter - 1 + i] = frontStorage.pivotRow[i];\n      }\n      frontDataCounter += columnCount;\n\n      for (let i = 0; i < columnCount; i++) {\n        frontStorage.frontValues[frontDataCounter - 1 + i] = frontStorage.columnHeaders[i];\n      }\n      frontDataCounter += columnCount;\n\n      frontStorage.frontValues[frontDataCounter - 1] = pivotGlobalRowIndex;\n      frontStorage.frontValues[frontDataCounter] = columnCount;\n      frontStorage.frontValues[frontDataCounter + 1] = pivotColumnIndex;\n      frontStorage.frontValues[frontDataCounter + 2] = pivotValue;\n      frontDataCounter += 4;\n\n      for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n        frontMatrix[rowIndex][columnCount - 1] = 0;\n      }\n\n      for (let columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n        frontMatrix[rowCount - 1][columnIndex] = 0;\n      }\n\n      columnCount--;\n      if (pivotColumnIndex < columnCount + 1) {\n        for (let columnIndex = pivotColumnIndex - 1; columnIndex < columnCount; columnIndex++) {\n          frontStorage.columnHeaders[columnIndex] = frontStorage.columnHeaders[columnIndex + 1];\n        }\n      }\n\n      rowCount--;\n      if (pivotRowIndex < rowCount + 1) {\n        for (let rowIndex = pivotRowIndex - 1; rowIndex < rowCount; rowIndex++) {\n          rowHeaders[rowIndex] = rowHeaders[rowIndex + 1];\n        }\n      }\n\n      if (rowCount > 1 || elementData.currentElementIndex < totalElements) continue;\n\n      pivotColumnGlobalIndex = Math.abs(frontStorage.columnHeaders[0]); // Assign, don't declare\n      pivotRowIndex = 1;\n      pivotValue = frontMatrix[0][0];\n      pivotGlobalRowIndex = Math.abs(rowHeaders[0]);\n      pivotColumnIndex = 1;\n      permutationHelper =\n        pivotGlobalRowIndex +\n        pivotColumnGlobalIndex +\n        rowSwapCount[pivotGlobalRowIndex - 1] +\n        columnSwapCount[pivotColumnGlobalIndex - 1];\n      frontalState.determinant =\n        (frontalState.determinant * pivotValue * (-1) ** permutationHelper) / Math.abs(pivotValue);\n\n      frontStorage.pivotRow[0] = 1;\n      if (Math.abs(pivotValue) < 1e-10) {\n        errorLog(\n          `Matrix singular or ill-conditioned, currentElementIndex=${elementData.currentElementIndex}, pivotGlobalRowIndex=${pivotGlobalRowIndex}, pivotColumnGlobalIndex=${pivotColumnGlobalIndex}, pivotValue=${pivotValue}`\n        );\n      }\n\n      if (pivotValue === 0) return;\n\n      frontalData.globalResidualVector[pivotGlobalRowIndex - 1] =\n        frontalData.globalResidualVector[pivotGlobalRowIndex - 1] / pivotValue;\n      frontStorage.frontValues[frontDataCounter - 1] = frontStorage.pivotRow[0];\n      frontDataCounter++;\n      frontStorage.frontValues[frontDataCounter - 1] = frontStorage.columnHeaders[0];\n      frontDataCounter++;\n      frontStorage.frontValues[frontDataCounter - 1] = pivotGlobalRowIndex;\n      frontStorage.frontValues[frontDataCounter] = columnCount;\n      frontStorage.frontValues[frontDataCounter + 1] = pivotColumnIndex;\n      frontStorage.frontValues[frontDataCounter + 2] = pivotValue;\n      frontDataCounter += 4;\n\n      frontStorage.pivotData[pivotDataIndex - 1] = pivotColumn[0];\n      pivotDataIndex++;\n      frontStorage.pivotData[pivotDataIndex - 1] = rowHeaders[0];\n      pivotDataIndex++;\n      frontStorage.pivotData[pivotDataIndex - 1] = pivotRowIndex;\n      pivotDataIndex++;\n\n      frontalState.frontDataIndex = frontDataCounter;\n      if (frontalState.writeFlag === 1)\n        debugLog(`total ecs transfer in matrix reduction=${frontDataCounter}`);\n\n      // Back substitution\n      performBackSubstitution(frontDataCounter);\n      break;\n    }\n  }\n}\n\n/**\n * Function to perform back substitution for the frontal solver\n * @param {number} frontDataCounter - Index counter for the element contributions\n */\nfunction performBackSubstitution(frontDataCounter) {\n  for (let nodeIndex = 0; nodeIndex < frontalState.totalNodes; nodeIndex++) {\n    frontalState.globalSolutionVector[nodeIndex] = frontalData.boundaryValues[nodeIndex];\n  }\n\n  for (let iterationIndex = 1; iterationIndex <= frontalState.totalNodes; iterationIndex++) {\n    frontDataCounter -= 4;\n    let pivotGlobalRowIndex = frontStorage.frontValues[frontDataCounter - 1];\n    let columnCount = frontStorage.frontValues[frontDataCounter];\n    let pivotColumnIndex = frontStorage.frontValues[frontDataCounter + 1];\n    let pivotValue = frontStorage.frontValues[frontDataCounter + 2];\n\n    if (iterationIndex === 1) {\n      frontDataCounter--;\n      frontStorage.columnHeaders[0] = frontStorage.frontValues[frontDataCounter - 1];\n      frontDataCounter--;\n      frontStorage.pivotRow[0] = frontStorage.frontValues[frontDataCounter - 1];\n    } else {\n      frontDataCounter -= columnCount;\n      for (let columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n        frontStorage.columnHeaders[columnIndex] =\n          frontStorage.frontValues[frontDataCounter - 1 + columnIndex];\n      }\n      frontDataCounter -= columnCount;\n      for (let columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n        frontStorage.pivotRow[columnIndex] = frontStorage.frontValues[frontDataCounter - 1 + columnIndex];\n      }\n    }\n\n    let pivotColumnGlobalIndex = Math.abs(frontStorage.columnHeaders[pivotColumnIndex - 1]);\n    if (frontalData.nodeConstraintCode[pivotColumnGlobalIndex - 1] > 0) continue;\n\n    let accumulatedValue = 0;\n    frontStorage.pivotRow[pivotColumnIndex - 1] = 0;\n    for (let columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n      accumulatedValue -=\n        frontStorage.pivotRow[columnIndex] *\n        frontalState.globalSolutionVector[Math.abs(frontStorage.columnHeaders[columnIndex]) - 1];\n    }\n\n    frontalState.globalSolutionVector[pivotColumnGlobalIndex - 1] =\n      accumulatedValue + frontalData.globalResidualVector[pivotGlobalRowIndex - 1];\n\n    frontalData.nodeConstraintCode[pivotColumnGlobalIndex - 1] = 1;\n  }\n\n  if (frontalState.writeFlag === 1)\n    debugLog(`value of frontDataCounter after backsubstitution=${frontDataCounter}`);\n}\n","/**\n * ════════════════════════════════════════════════════════════\n *  FEAScript Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.1.4 | https://feascript.com\n * ════════════════════════════════════════════════════════════\n */\n\n// Internal imports\nimport { euclideanNorm } from \"../methods/euclideanNormScript.js\";\nimport { solveLinearSystem } from \"./linearSystemSolverScript.js\";\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\nimport { runFrontalSolver } from \"./frontalSolverScript.js\";\nimport { assembleFrontPropagationFront } from \"../models/frontPropagationScript.js\";\n\n/**\n * Function to solve a system of non-linear equations using the Newton-Raphson method\n * @param {function} assembleMat - Matrix assembler based on the physical model\n * @param {object} context - Context object containing simulation data and options\n * @returns {object} An object containing:\n *  - solutionVector: The solution vector\n *  - iterations: The number of iterations performed\n *  - converged: Boolean indicating whether the method converged\n */\n\nexport function newtonRaphson(assembleMat, context = {}) {\n  let errorNorm = 0;\n  let converged = false;\n  let iterations = 0;\n  let deltaX = [];\n  let solutionVector = [];\n  let jacobianMatrix = [];\n  let residualVector = [];\n\n  // Extract context\n  const { maxIterations = 100, tolerance = 1e-4 } = context;\n\n  // Calculate system size\n  let totalNodes = context.meshData.nodesXCoordinates.length;\n\n  // Initialize arrays with proper size\n  for (let i = 0; i < totalNodes; i++) {\n    deltaX[i] = 0;\n    solutionVector[i] = 0;\n  }\n\n  // Initialize solution from context if available\n  if (context.initialSolution && context.initialSolution.length === totalNodes) {\n    solutionVector = [...context.initialSolution];\n  }\n\n  while (iterations < maxIterations && !converged) {\n    // Update solution\n    for (let i = 0; i < solutionVector.length; i++) {\n      solutionVector[i] = Number(solutionVector[i]) + Number(deltaX[i]);\n    }\n\n    // Check if using frontal solver\n    if (context.solverMethod === \"frontal\") {\n      const frontalResult = runFrontalSolver(\n        assembleFrontPropagationFront,\n        context.meshData,\n        context.boundaryConditions,\n        { solutionVector, eikonalActivationFlag: context.eikonalActivationFlag }\n      );\n      deltaX = frontalResult.solutionVector;\n    } else {\n      // Compute Jacobian and residual matrices\n      ({ jacobianMatrix, residualVector } = assembleMat(\n        context.meshData,\n        context.boundaryConditions,\n        solutionVector, // The solution vector is required in the case of a non-linear equation\n        context.eikonalActivationFlag // Currently used only in the front propagation solver (TODO refactor in case of a solver not needing it)\n      ));\n\n      // Solve the linear system based on the specified solver method\n      const linearSystemResult = solveLinearSystem(context.solverMethod, jacobianMatrix, residualVector);\n      deltaX = linearSystemResult.solutionVector;\n    }\n\n    // Check convergence\n    errorNorm = euclideanNorm(deltaX);\n\n    // Norm for each iteration\n    basicLog(`Newton-Raphson iteration ${iterations + 1}: Error norm = ${errorNorm.toExponential(4)}`);\n\n    if (errorNorm <= tolerance) {\n      converged = true;\n    } else if (errorNorm > 1e2) {\n      errorLog(`Solution not converged. Error norm: ${errorNorm}`);\n      break;\n    }\n\n    iterations++;\n  }\n\n  return {\n    solutionVector,\n    converged,\n    iterations,\n    jacobianMatrix,\n    residualVector,\n  };\n}\n","/**\n * ════════════════════════════════════════════════════════════\n *  FEAScript Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.1.4 | https://feascript.com\n * ════════════════════════════════════════════════════════════\n */\n\n// Internal imports\nimport { newtonRaphson } from \"./methods/newtonRaphsonScript.js\";\nimport { solveLinearSystem } from \"./methods/linearSystemSolverScript.js\";\nimport { solveLinearSystemAsync } from \"./methods/linearSystemSolverScript.js\";\nimport { prepareMesh } from \"./mesh/meshUtilsScript.js\";\nimport { assembleFrontPropagationMat } from \"./models/frontPropagationScript.js\";\nimport { assembleGeneralFormPDEMat, assembleGeneralFormPDEFront } from \"./models/generalFormPDEScript.js\";\nimport { assembleHeatConductionMat, assembleHeatConductionFront } from \"./models/heatConductionScript.js\";\nimport { runFrontalSolver } from \"./methods/frontalSolverScript.js\";\nimport { basicLog, debugLog, warnLog, errorLog } from \"./utilities/loggingScript.js\";\n\n/**\n * Class to implement finite element analysis in JavaScript\n * @param {string} solverConfig - Parameter specifying the type of solver\n * @param {object} meshConfig - Object containing computational mesh details\n * @param {object} boundaryConditions - Object containing boundary conditions for the finite element analysis\n * @returns {object} An object containifng the solution vector and additional mesh information\n */\nexport class FEAScriptModel {\n  constructor() {\n    this.solverConfig = null;\n    this.meshConfig = {};\n    this.boundaryConditions = {};\n    this.solverMethod = \"lusolve\"; // Default solver method\n    this.coefficientFunctions = null; // Add storage for coefficient functions\n    warnLog(\n      \"FEAScript is provided “as is” without any warranty. The authors are not responsible for any damages or losses that may result from using the software. See the license for more details: https://github.com/FEAScript/FEAScript-core/blob/main/LICENSE\"\n    );\n    basicLog(\"FEAScriptModel instance created\");\n  }\n\n  /**\n   * Sets the solver configuration\n   * @param {string} solverConfig - Parameter specifying the type of solver\n   * @param {object} [options] - Optional additional configuration\n   */\n  setSolverConfig(solverConfig, options = {}) {\n    this.solverConfig = solverConfig;\n\n    // Store coefficient functions if provided\n    if (options?.coefficientFunctions) {\n      this.coefficientFunctions = options.coefficientFunctions;\n      debugLog(\"Coefficient functions set\");\n    }\n    // Only update if a value is provided, otherwise keep the default\n    if (options?.maxIterations !== undefined) {\n      this.maxIterations = options.maxIterations;\n    }\n    if (options?.tolerance !== undefined) {\n      this.tolerance = options.tolerance;\n    }\n\n    debugLog(`Solver config set to: ${solverConfig}`);\n  }\n\n  setMeshConfig(meshConfig) {\n    this.meshConfig = meshConfig;\n    debugLog(`Mesh config set with dimensions: ${meshConfig.meshDimension}`);\n  }\n\n  addBoundaryCondition(boundaryKey, condition) {\n    this.boundaryConditions[boundaryKey] = condition;\n    debugLog(`Boundary condition added for boundary: ${boundaryKey}, type: ${condition[0]}`);\n  }\n\n  setSolverMethod(solverMethod) {\n    this.solverMethod = solverMethod;\n    debugLog(`Solver method set to: ${solverMethod}`);\n  }\n\n  /**\n   * Function to solve the finite element problem synchronously\n   * @param {object} [options] - Additional parameters for the solver, such as `maxIterations` and `tolerance`\n   * @returns {object} An object containing the solution vector and the coordinates of the mesh nodes\n   */\n  solve(options = {}) {\n    if (!this.solverConfig || !this.meshConfig || !this.boundaryConditions) {\n      errorLog(\"Solver config, mesh config, and boundary conditions must be set before solving.\");\n    }\n    /**\n     * For consistency across both linear and nonlinear formulations,\n     * this project always refers to the assembled right-hand side vector\n     * as `residualVector` and the assembled system matrix as `jacobianMatrix`.\n     *\n     * In linear problems `jacobianMatrix` is equivalent to the\n     * classic stiffness/conductivity matrix and `residualVector`\n     * corresponds to the traditional load (RHS) vector.\n     */\n\n    let jacobianMatrix = [];\n    let residualVector = [];\n    let solutionVector = [];\n    let initialSolution = [];\n\n    // Prepare the mesh\n    basicLog(\"Preparing mesh...\");\n    const meshData = prepareMesh(this.meshConfig);\n    basicLog(\"Mesh preparation completed\");\n\n    // Extract node coordinates from meshData\n    const nodesCoordinates = {\n      nodesXCoordinates: meshData.nodesXCoordinates,\n      nodesYCoordinates: meshData.nodesYCoordinates,\n    };\n\n    // Select and execute the appropriate solver based on solverConfig\n    basicLog(\"Beginning solving process...\");\n    console.time(\"totalSolvingTime\");\n    basicLog(`Using solver: ${this.solverConfig}`);\n    if (this.solverConfig === \"heatConductionScript\") {\n      // Check if using frontal solver\n      if (this.solverMethod === \"frontal\") {\n        const frontalResult = runFrontalSolver(\n          assembleHeatConductionFront,\n          meshData,\n          this.boundaryConditions\n        );\n        solutionVector = frontalResult.solutionVector;\n      } else {\n        // Use regular linear solver methods\n        ({ jacobianMatrix, residualVector } = assembleHeatConductionMat(meshData, this.boundaryConditions));\n        const linearSystemResult = solveLinearSystem(this.solverMethod, jacobianMatrix, residualVector, {\n          maxIterations: options.maxIterations ?? this.maxIterations,\n          tolerance: options.tolerance ?? this.tolerance,\n        });\n        solutionVector = linearSystemResult.solutionVector;\n      }\n    } else if (this.solverConfig === \"frontPropagationScript\") {\n      // Initialize eikonalActivationFlag\n      let eikonalActivationFlag = 0;\n      const eikonalExteralIterations = 5; // Number of incremental steps for the eikonal equation\n\n      // Create context object with all necessary properties\n      const context = {\n        meshData: meshData,\n        boundaryConditions: this.boundaryConditions,\n        eikonalActivationFlag: eikonalActivationFlag,\n        solverMethod: this.solverMethod,\n        initialSolution,\n        // TODO: Consider using different maxIterations/tolerance for Newton-Raphson and linear solver\n        maxIterations: options.maxIterations ?? this.maxIterations,\n        tolerance: options.tolerance ?? this.tolerance,\n      };\n\n      while (eikonalActivationFlag <= 1) {\n        // Update the context object with current eikonalActivationFlag\n        context.eikonalActivationFlag = eikonalActivationFlag;\n\n        // Pass the previous solution as initial guess\n        if (solutionVector.length > 0) {\n          context.initialSolution = [...solutionVector];\n        }\n\n        // Solve the assembled non-linear system\n        const newtonRaphsonResult = newtonRaphson(assembleFrontPropagationMat, context);\n\n        // Extract results\n        jacobianMatrix = newtonRaphsonResult.jacobianMatrix;\n        residualVector = newtonRaphsonResult.residualVector;\n        solutionVector = newtonRaphsonResult.solutionVector;\n\n        // Increment for next iteration\n        eikonalActivationFlag += 1 / eikonalExteralIterations;\n      }\n    } else if (this.solverConfig === \"generalFormPDEScript\") {\n      // Check if using frontal solver\n      if (this.solverMethod === \"frontal\") {\n        errorLog(\n          \"Frontal solver is not yet supported for generalFormPDEScript. Please use 'lusolve' or 'jacobi'.\"\n        );\n      } else {\n        // Use regular linear solver methods\n        ({ jacobianMatrix, residualVector } = assembleGeneralFormPDEMat(\n          meshData,\n          this.boundaryConditions,\n          this.coefficientFunctions\n        ));\n\n        const linearSystemResult = solveLinearSystem(this.solverMethod, jacobianMatrix, residualVector, {\n          maxIterations: options.maxIterations ?? this.maxIterations,\n          tolerance: options.tolerance ?? this.tolerance,\n        });\n        solutionVector = linearSystemResult.solutionVector;\n      }\n    }\n    console.timeEnd(\"totalSolvingTime\");\n    basicLog(\"Solving process completed\");\n\n    return { solutionVector, nodesCoordinates };\n  }\n\n  /**\n   * Function to solve the finite element problem asynchronously\n   * @param {object} computeEngine - The compute engine to use for the asynchronous solver (e.g., a worker or a WebGPU context)\n   * @param {object} [options] - Additional parameters for the solver, such as `maxIterations` and `tolerance`\n   * @returns {Promise<object>} A promise that resolves to an object containing the solution vector and the coordinates of the mesh nodes\n   */\n  async solveAsync(computeEngine, options = {}) {\n    if (!this.solverConfig || !this.meshConfig || !this.boundaryConditions) {\n      errorLog(\"Solver config, mesh config, and boundary conditions must be set before solving.\");\n    }\n\n    let jacobianMatrix = [];\n    let residualVector = [];\n    let solutionVector = [];\n\n    basicLog(\"Preparing mesh...\");\n    const meshData = prepareMesh(this.meshConfig);\n    basicLog(\"Mesh preparation completed\");\n    const nodesCoordinates = {\n      nodesXCoordinates: meshData.nodesXCoordinates,\n      nodesYCoordinates: meshData.nodesYCoordinates,\n    };\n\n    basicLog(\"Beginning solving process...\");\n    console.time(\"totalSolvingTime\");\n\n    basicLog(`Using solver: ${this.solverConfig}`);\n    if (this.solverConfig === \"heatConductionScript\") {\n      ({ jacobianMatrix, residualVector } = assembleHeatConductionMat(meshData, this.boundaryConditions));\n\n      if (this.solverMethod === \"jacobi-gpu\") {\n        const { solutionVector: x } = await solveLinearSystemAsync(\"jacobi-gpu\", jacobianMatrix, residualVector, {\n          computeEngine,\n          maxIterations: options.maxIterations ?? this.maxIterations,\n          tolerance: options.tolerance ?? this.tolerance,\n        });\n        solutionVector = x;\n      } else {\n        // Other async solver\n      }\n    }\n    console.timeEnd(\"totalSolvingTime\");\n    basicLog(\"Solving process completed\");\n\n    return { solutionVector, nodesCoordinates };\n  }\n\n}\n","/**\n * ════════════════════════════════════════════════════════════\n *  FEAScript Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.1.4 | https://feascript.com\n * ════════════════════════════════════════════════════════════\n */\n\n// Internal imports\nimport { initializeFEA, performIsoparametricMapping1D } from \"../mesh/meshUtilsScript.js\";\nimport { GenericBoundaryConditions } from \"./genericBoundaryConditionsScript.js\";\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Function to assemble the Jacobian matrix and residuals vector for the general form PDE model\n * @param {object} meshData - Object containing prepared mesh data\n * @param {object} boundaryConditions - Object containing boundary conditions\n * @param {object} coefficientFunctions - Functions A(x), B(x), C(x), D(x) for the PDE\n * @returns {object} An object containing:\n *  - jacobianMatrix: The assembled Jacobian matrix\n *  - residualVector: The assembled residual vector\n */\nexport function assembleGeneralFormPDEMat(meshData, boundaryConditions, coefficientFunctions) {\n  basicLog(\"Starting general form PDE matrix assembly...\");\n\n  // Extract mesh data\n  const {\n    nodesXCoordinates,\n    nodesYCoordinates,\n    nop,\n    boundaryElements,\n    totalElements,\n    meshDimension,\n    elementOrder,\n  } = meshData;\n\n  // Extract coefficient functions\n  const { A, B, C, D } = coefficientFunctions;\n\n  // Initialize FEA components\n  const FEAData = initializeFEA(meshData);\n  const {\n    residualVector,\n    jacobianMatrix,\n    localToGlobalMap,\n    basisFunctions,\n    gaussPoints,\n    gaussWeights,\n    numNodes,\n  } = FEAData;\n\n  if (meshDimension === \"1D\") {\n    // 1D general form PDE\n\n    // Matrix assembly\n    for (let elementIndex = 0; elementIndex < totalElements; elementIndex++) {\n      // Map local element nodes to global mesh nodes\n      for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n        // Convert to 0-based indexing\n        localToGlobalMap[localNodeIndex] = Math.abs(nop[elementIndex][localNodeIndex]) - 1;\n      }\n\n      // Loop over Gauss points\n      for (let gaussPointIndex = 0; gaussPointIndex < gaussPoints.length; gaussPointIndex++) {\n        // Get basis functions for the current Gauss point\n        const { basisFunction, basisFunctionDerivKsi } = basisFunctions.getBasisFunctions(\n          gaussPoints[gaussPointIndex]\n        );\n\n        // Perform isoparametric mapping\n        const { detJacobian, basisFunctionDerivX } = performIsoparametricMapping1D({\n          basisFunction,\n          basisFunctionDerivKsi,\n          nodesXCoordinates,\n          localToGlobalMap,\n          numNodes,\n        });\n\n        // Calculate the physical coordinate for this Gauss point\n        let xCoord = 0;\n        for (let i = 0; i < numNodes; i++) {\n          xCoord += nodesXCoordinates[localToGlobalMap[i]] * basisFunction[i];\n        }\n\n        // Evaluate coefficient functions at this physical coordinate\n        const a = A(xCoord);\n        const b = B(xCoord);\n        const c = C(xCoord);\n        const d = D(xCoord);\n\n        // Computation of Galerkin's residuals and local Jacobian matrix\n        for (let localNodeIndex1 = 0; localNodeIndex1 < numNodes; localNodeIndex1++) {\n          const globalNodeIndex1 = localToGlobalMap[localNodeIndex1];\n\n          // Source term contribution to residual vector\n          residualVector[globalNodeIndex1] -=\n            gaussWeights[gaussPointIndex] * detJacobian * d * basisFunction[localNodeIndex1];\n\n          for (let localNodeIndex2 = 0; localNodeIndex2 < numNodes; localNodeIndex2++) {\n            const globalNodeIndex2 = localToGlobalMap[localNodeIndex2];\n\n            // Diffusion term\n            jacobianMatrix[globalNodeIndex1][globalNodeIndex2] +=\n              gaussWeights[gaussPointIndex] *\n              detJacobian *\n              a *\n              basisFunctionDerivX[localNodeIndex1] *\n              basisFunctionDerivX[localNodeIndex2];\n\n            // Advection term\n            jacobianMatrix[globalNodeIndex1][globalNodeIndex2] -=\n              gaussWeights[gaussPointIndex] *\n              detJacobian *\n              b *\n              basisFunctionDerivX[localNodeIndex2] *\n              basisFunction[localNodeIndex1];\n\n            // Reaction term\n            jacobianMatrix[globalNodeIndex1][globalNodeIndex2] -=\n              gaussWeights[gaussPointIndex] *\n              detJacobian *\n              c *\n              basisFunction[localNodeIndex1] *\n              basisFunction[localNodeIndex2];\n          }\n        }\n      }\n    }\n  } else if (meshDimension === \"2D\") {\n    errorLog(\"2D general form PDE is not yet supported in assembleGeneralFormPDEMat.\");\n    // 2D general form PDE - empty for now\n  }\n\n  // Apply boundary conditions\n  const genericBoundaryConditions = new GenericBoundaryConditions(\n    boundaryConditions,\n    boundaryElements,\n    nop,\n    meshDimension,\n    elementOrder\n  );\n\n  // Apply Dirichlet boundary conditions only\n  genericBoundaryConditions.imposeDirichletBoundaryConditions(residualVector, jacobianMatrix);\n\n  basicLog(\"General form PDE matrix assembly completed\");\n\n  return {\n    jacobianMatrix,\n    residualVector,\n  };\n}\n\n/**\n * Function to assemble the frontal solver matrix for the general form PDE model\n * @param {object} data - Object containing element data for the frontal solver\n * @returns {object} An object containing local Jacobian matrix and residual vector\n */\nexport function assembleGeneralFormPDEFront({\n  elementIndex,\n  nop,\n  meshData,\n  basisFunctions,\n  FEAData,\n  coefficientFunctions,\n}) {\n  // Extract numerical integration parameters and mesh coordinates\n  const { gaussPoints, gaussWeights, numNodes } = FEAData;\n  const { nodesXCoordinates, nodesYCoordinates, meshDimension } = meshData;\n  const { A, B, C, D } = coefficientFunctions;\n\n  // Initialize local Jacobian matrix and local residual vector\n  const localJacobianMatrix = Array(numNodes)\n    .fill()\n    .map(() => Array(numNodes).fill(0));\n  const localResidualVector = Array(numNodes).fill(0);\n\n  // Build the mapping from local node indices to global node indices\n  const ngl = Array(numNodes);\n  const localToGlobalMap = Array(numNodes);\n  for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n    ngl[localNodeIndex] = Math.abs(nop[elementIndex][localNodeIndex]);\n    localToGlobalMap[localNodeIndex] = Math.abs(nop[elementIndex][localNodeIndex]) - 1;\n  }\n\n  if (meshDimension === \"1D\") {\n    // 1D general form PDE\n\n    // Loop over Gauss points\n    for (let gaussPointIndex = 0; gaussPointIndex < gaussPoints.length; gaussPointIndex++) {\n      // Get basis functions for the current Gauss point\n      const { basisFunction, basisFunctionDerivKsi } = basisFunctions.getBasisFunctions(\n        gaussPoints[gaussPointIndex]\n      );\n\n      // Perform isoparametric mapping\n      const { detJacobian, basisFunctionDerivX } = performIsoparametricMapping1D({\n        basisFunction,\n        basisFunctionDerivKsi,\n        nodesXCoordinates,\n        localToGlobalMap,\n        numNodes,\n      });\n\n      // Calculate the physical coordinate for this Gauss point\n      let xCoord = 0;\n      for (let i = 0; i < numNodes; i++) {\n        xCoord += nodesXCoordinates[localToGlobalMap[i]] * basisFunction[i];\n      }\n\n      // Evaluate coefficient functions at this physical coordinate\n      const a = A(xCoord);\n      const b = B(xCoord);\n      const c = C(xCoord);\n      const d = D(xCoord);\n\n      // Computation of local Jacobian matrix and residual vector\n      for (let localNodeIndex1 = 0; localNodeIndex1 < numNodes; localNodeIndex1++) {\n        // Source term contribution to local residual vector\n        localResidualVector[localNodeIndex1] -=\n          gaussWeights[gaussPointIndex] * detJacobian * d * basisFunction[localNodeIndex1];\n\n        for (let localNodeIndex2 = 0; localNodeIndex2 < numNodes; localNodeIndex2++) {\n          // Diffusion term\n          localJacobianMatrix[localNodeIndex1][localNodeIndex2] +=\n            gaussWeights[gaussPointIndex] *\n            detJacobian *\n            a *\n            basisFunctionDerivX[localNodeIndex1] *\n            basisFunctionDerivX[localNodeIndex2];\n\n          // Advection term\n          localJacobianMatrix[localNodeIndex1][localNodeIndex2] -=\n            gaussWeights[gaussPointIndex] *\n            detJacobian *\n            b *\n            basisFunctionDerivX[localNodeIndex2] *\n            basisFunction[localNodeIndex1];\n\n          // Reaction term\n          localJacobianMatrix[localNodeIndex1][localNodeIndex2] -=\n            gaussWeights[gaussPointIndex] *\n            detJacobian *\n            c *\n            basisFunction[localNodeIndex1] *\n            basisFunction[localNodeIndex2];\n        }\n      }\n    }\n  } else if (meshDimension === \"2D\") {\n    errorLog(\"2D general form PDE is not yet supported in assembleGeneralFormPDEFront.\");\n    // 2D general form PDE - empty for now\n  }\n\n  return {\n    localJacobianMatrix,\n    localResidualVector,\n    ngl,\n  };\n}\n","/**\n * ════════════════════════════════════════════════════════════\n *  FEAScript Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.1.4 | https://feascript.com\n * ════════════════════════════════════════════════════════════\n */\n\n// Internal imports\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Function to import mesh data from Gmsh format containing quadrilateral and triangular elements\n * @param {File} file - The Gmsh file to be parsed (.msh version 4.1)\n * @returns {object} The parsed mesh data including node coordinates, element connectivity, and boundary conditions\n */\nconst importGmshQuadTri = async (file) => {\n  let result = {\n    nodesXCoordinates: [],\n    nodesYCoordinates: [],\n    nodalNumbering: {\n      quadElements: [],\n      triangleElements: [],\n    },\n    boundaryElements: [],\n    boundaryConditions: [],\n    boundaryNodePairs: {}, // Store boundary node pairs for processing in meshGenerationScript\n    gmshV: 0,\n    ascii: false,\n    fltBytes: \"8\",\n    totalNodesX: 0,\n    totalNodesY: 0,\n    physicalPropMap: [],\n    elementTypes: {},\n  };\n\n  let content = await file.text();\n  let lines = content\n    .split(\"\\n\")\n    .map((line) => line.trim())\n    .filter((line) => line !== \"\" && line !== \" \");\n\n  let section = \"\";\n  let lineIndex = 0;\n\n  let nodeEntityBlocks = 0;\n  let totalNodes = 0;\n  let nodeBlocksProcessed = 0;\n  let currentNodeBlock = { numNodes: 0 };\n  let nodeTagsCollected = 0;\n  let nodeTags = [];\n  let nodeCoordinatesCollected = 0;\n\n  let elementEntityBlocks = 0;\n  let totalElements = 0;\n  let elementBlocksProcessed = 0;\n  let currentElementBlock = {\n    dim: 0,\n    tag: 0,\n    elementType: 0,\n    numElements: 0,\n  };\n  let elementsProcessedInBlock = 0;\n\n  let boundaryElementsByTag = {};\n\n  while (lineIndex < lines.length) {\n    const line = lines[lineIndex];\n\n    if (line === \"$MeshFormat\") {\n      section = \"meshFormat\";\n      lineIndex++;\n      continue;\n    } else if (line === \"$EndMeshFormat\") {\n      section = \"\";\n      lineIndex++;\n      continue;\n    } else if (line === \"$PhysicalNames\") {\n      section = \"physicalNames\";\n      lineIndex++;\n      continue;\n    } else if (line === \"$EndPhysicalNames\") {\n      section = \"\";\n      lineIndex++;\n      continue;\n    } else if (line === \"$Entities\") {\n      section = \"entities\";\n      lineIndex++;\n      continue;\n    } else if (line === \"$EndEntities\") {\n      section = \"\";\n      lineIndex++;\n      continue;\n    } else if (line === \"$Nodes\") {\n      section = \"nodes\";\n      lineIndex++;\n      continue;\n    } else if (line === \"$EndNodes\") {\n      section = \"\";\n      lineIndex++;\n      continue;\n    } else if (line === \"$Elements\") {\n      section = \"elements\";\n      lineIndex++;\n      continue;\n    } else if (line === \"$EndElements\") {\n      section = \"\";\n      lineIndex++;\n      continue;\n    }\n\n    const parts = line.split(/\\s+/).filter((part) => part !== \"\");\n\n    if (section === \"meshFormat\") {\n      result.gmshV = parseFloat(parts[0]);\n      result.ascii = parts[1] === \"0\";\n      result.fltBytes = parts[2];\n    } else if (section === \"physicalNames\") {\n      if (parts.length >= 3) {\n        if (!/^\\d+$/.test(parts[0])) {\n          lineIndex++;\n          continue;\n        }\n\n        const dimension = parseInt(parts[0], 10);\n        const tag = parseInt(parts[1], 10);\n        let name = parts.slice(2).join(\" \");\n        name = name.replace(/^\"|\"$/g, \"\");\n\n        result.physicalPropMap.push({\n          tag,\n          dimension,\n          name,\n        });\n      }\n    } else if (section === \"nodes\") {\n      if (nodeEntityBlocks === 0) {\n        nodeEntityBlocks = parseInt(parts[0], 10);\n        totalNodes = parseInt(parts[1], 10);\n        result.nodesXCoordinates = new Array(totalNodes).fill(0);\n        result.nodesYCoordinates = new Array(totalNodes).fill(0);\n        lineIndex++;\n        continue;\n      }\n\n      if (nodeBlocksProcessed < nodeEntityBlocks && currentNodeBlock.numNodes === 0) {\n        currentNodeBlock = {\n          dim: parseInt(parts[0], 10),\n          tag: parseInt(parts[1], 10),\n          parametric: parseInt(parts[2], 10),\n          numNodes: parseInt(parts[3], 10),\n        };\n\n        nodeTags = [];\n        nodeTagsCollected = 0;\n        nodeCoordinatesCollected = 0;\n\n        lineIndex++;\n        continue;\n      }\n\n      if (nodeTagsCollected < currentNodeBlock.numNodes) {\n        for (let i = 0; i < parts.length && nodeTagsCollected < currentNodeBlock.numNodes; i++) {\n          nodeTags.push(parseInt(parts[i], 10));\n          nodeTagsCollected++;\n        }\n\n        if (nodeTagsCollected < currentNodeBlock.numNodes) {\n          lineIndex++;\n          continue;\n        }\n\n        lineIndex++;\n        continue;\n      }\n\n      if (nodeCoordinatesCollected < currentNodeBlock.numNodes) {\n        const nodeTag = nodeTags[nodeCoordinatesCollected] - 1;\n        const x = parseFloat(parts[0]);\n        const y = parseFloat(parts[1]);\n\n        result.nodesXCoordinates[nodeTag] = x;\n        result.nodesYCoordinates[nodeTag] = y;\n        result.totalNodesX++;\n        result.totalNodesY++;\n\n        nodeCoordinatesCollected++;\n\n        if (nodeCoordinatesCollected === currentNodeBlock.numNodes) {\n          nodeBlocksProcessed++;\n          currentNodeBlock = { numNodes: 0 };\n        }\n      }\n    } else if (section === \"elements\") {\n      if (elementEntityBlocks === 0) {\n        elementEntityBlocks = parseInt(parts[0], 10);\n        totalElements = parseInt(parts[1], 10);\n        lineIndex++;\n        continue;\n      }\n\n      if (elementBlocksProcessed < elementEntityBlocks && currentElementBlock.numElements === 0) {\n        currentElementBlock = {\n          dim: parseInt(parts[0], 10),\n          tag: parseInt(parts[1], 10),\n          elementType: parseInt(parts[2], 10),\n          numElements: parseInt(parts[3], 10),\n        };\n\n        result.elementTypes[currentElementBlock.elementType] =\n          (result.elementTypes[currentElementBlock.elementType] || 0) + currentElementBlock.numElements;\n\n        elementsProcessedInBlock = 0;\n        lineIndex++;\n        continue;\n      }\n\n      if (elementsProcessedInBlock < currentElementBlock.numElements) {\n        const elementTag = parseInt(parts[0], 10);\n        const nodeIndices = parts.slice(1).map((idx) => parseInt(idx, 10));\n\n        if (currentElementBlock.elementType === 1 || currentElementBlock.elementType === 8) {\n          const physicalTag = currentElementBlock.tag;\n\n          if (!boundaryElementsByTag[physicalTag]) {\n            boundaryElementsByTag[physicalTag] = [];\n          }\n\n          boundaryElementsByTag[physicalTag].push(nodeIndices);\n\n          // Store boundary node pairs for later processing in meshGenerationScript\n          if (!result.boundaryNodePairs[physicalTag]) {\n            result.boundaryNodePairs[physicalTag] = [];\n          }\n          result.boundaryNodePairs[physicalTag].push(nodeIndices);\n        } else if (currentElementBlock.elementType === 2) {\n          // Linear triangle elements (3 nodes)\n          result.nodalNumbering.triangleElements.push(nodeIndices);\n        } else if (currentElementBlock.elementType === 3) {\n          // Linear quadrilateral elements (4 nodes)\n          result.nodalNumbering.quadElements.push(nodeIndices);\n        } else if (currentElementBlock.elementType === 10) {\n          // Quadratic quadrilateral elements (9 nodes)\n          result.nodalNumbering.quadElements.push(nodeIndices);\n        }\n\n        elementsProcessedInBlock++;\n\n        if (elementsProcessedInBlock === currentElementBlock.numElements) {\n          elementBlocksProcessed++;\n          currentElementBlock = { numElements: 0 };\n        }\n      }\n    }\n\n    lineIndex++;\n  }\n\n  // Store boundary conditions information\n  result.physicalPropMap.forEach((prop) => {\n    if (prop.dimension === 1) {\n      const boundaryNodes = boundaryElementsByTag[prop.tag] || [];\n\n      if (boundaryNodes.length > 0) {\n        result.boundaryConditions.push({\n          name: prop.name,\n          tag: prop.tag,\n          nodes: boundaryNodes,\n        });\n      }\n    }\n  });\n\n  debugLog(\n    `Parsed boundary node pairs by physical tag: ${JSON.stringify(\n      result.boundaryNodePairs\n    )}. These pairs will be used to identify boundary elements in the mesh.`\n  );\n\n  return result;\n};\n\nexport { importGmshQuadTri };\n","/**\n * ════════════════════════════════════════════════════════════\n *  FEAScript Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.1.4 | https://feascript.com\n * ════════════════════════════════════════════════════════════\n */\n\n/**\n * Function to create plots of the solution vector\n * @param {*} solutionVector - The computed solution vector\n * @param {*} nodesCoordinates - Object containing x and y coordinates for the nodes\n * @param {string} solverConfig - Parameter specifying the type of solver\n * @param {string} meshDimension - The dimension of the solution\n * @param {string} plotType - The type of plot\n * @param {string} plotDivId - The id of the div where the plot will be rendered\n * @param {string} [meshType=\"structured\"] - Type of mesh: \"structured\" or \"unstructured\"\n */\nexport function plotSolution(\n  solutionVector,\n  nodesCoordinates,\n  solverConfig,\n  meshDimension,\n  plotType,\n  plotDivId,\n  meshType = \"structured\"\n) {\n  const { nodesXCoordinates, nodesYCoordinates } = nodesCoordinates;\n\n  if (meshDimension === \"1D\" && plotType === \"line\") {\n    // Check if solutionVector is a nested array\n    let yData;\n    if (solutionVector.length > 0 && Array.isArray(solutionVector[0])) {\n      yData = solutionVector.map((arr) => arr[0]);\n    } else {\n      yData = solutionVector;\n    }\n    let xData = Array.from(nodesXCoordinates);\n\n    let lineData = {\n      x: xData,\n      y: yData,\n      mode: \"lines\",\n      type: \"scatter\",\n      line: { color: \"rgb(219, 64, 82)\", width: 2 },\n      name: \"Solution\",\n    };\n\n    let maxWindowWidth = Math.min(window.innerWidth, 700);\n    let maxPlotWidth = Math.max(...xData);\n    let zoomFactor = maxWindowWidth / maxPlotWidth;\n    let plotWidth = Math.max(zoomFactor * maxPlotWidth, 400);\n    let plotHeight = 350;\n\n    let layout = {\n      title: `line plot - ${solverConfig}`,\n      width: plotWidth,\n      height: plotHeight,\n      xaxis: { title: \"x\" },\n      yaxis: { title: \"Solution\" },\n      margin: { l: 70, r: 40, t: 50, b: 50 },\n    };\n\n    Plotly.newPlot(plotDivId, [lineData], layout, { responsive: true });\n  } else if (meshDimension === \"2D\" && plotType === \"contour\") {\n    // Use the user-provided mesh type\n    const isStructured = meshType === \"structured\";\n\n    // For auto-detection (if needed)\n    const uniqueXCoords = new Set(nodesXCoordinates).size;\n    const uniqueYCoords = new Set(nodesYCoordinates).size;\n\n    // Extract scalar values from solution vector\n    let zValues;\n    if (Array.isArray(solutionVector[0])) {\n      zValues = solutionVector.map((val) => val[0]);\n    } else {\n      zValues = solutionVector;\n    }\n\n    // Common sizing parameters for both plot types\n    let maxWindowWidth = Math.min(window.innerWidth, 700);\n    let maxX = Math.max(...nodesXCoordinates);\n    let maxY = Math.max(...nodesYCoordinates);\n    let aspectRatio = maxY / maxX;\n    let plotWidth = Math.min(maxWindowWidth, 600);\n    let plotHeight = plotWidth * aspectRatio * 0.8; // Slightly reduce height for better appearance\n\n    // Common layout properties\n    let layout = {\n      title: `${plotType} plot - ${solverConfig}`,\n      width: plotWidth,\n      height: plotHeight,\n      xaxis: { title: \"x\" },\n      yaxis: { title: \"y\" },\n      margin: { l: 50, r: 50, t: 50, b: 50 },\n      hovermode: \"closest\",\n    };\n\n    if (isStructured) {\n      // Calculate the number of nodes along the x-axis and y-axis\n      const numNodesX = uniqueXCoords;\n      const numNodesY = uniqueYCoords;\n\n      // Reshape the nodesXCoordinates and nodesYCoordinates arrays to match the grid dimensions\n      let reshapedXCoordinates = math.reshape(Array.from(nodesXCoordinates), [numNodesX, numNodesY]);\n      let reshapedYCoordinates = math.reshape(Array.from(nodesYCoordinates), [numNodesX, numNodesY]);\n\n      // Reshape the solution array to match the grid dimensions\n      let reshapedSolution = math.reshape(Array.from(solutionVector), [numNodesX, numNodesY]);\n\n      // Transpose the reshapedSolution array to get column-wise data\n      let transposedSolution = math.transpose(reshapedSolution);\n\n      // Create an array for x-coordinates used in the contour plot\n      let reshapedXForPlot = [];\n      for (let i = 0; i < numNodesX * numNodesY; i += numNodesY) {\n        let xValue = nodesXCoordinates[i];\n        reshapedXForPlot.push(xValue);\n      }\n\n      // Create the data structure for the contour plot\n      let contourData = {\n        z: transposedSolution,\n        type: \"contour\",\n        contours: {\n          coloring: \"heatmap\",\n          showlabels: false,\n        },\n        //colorscale: 'Viridis',\n        colorbar: {\n          title: \"Solution\",\n        },\n        x: reshapedXForPlot,\n        y: reshapedYCoordinates[0],\n        name: \"Solution Field\",\n      };\n\n      // Create the plot using Plotly\n      Plotly.newPlot(plotDivId, [contourData], layout, { responsive: true });\n    } else {\n      // Create an interpolated contour plot for the unstructured mesh\n      let contourData = {\n        x: nodesXCoordinates,\n        y: nodesYCoordinates,\n        z: zValues,\n        type: \"contour\",\n        contours: {\n          coloring: \"heatmap\",\n          showlabels: false,\n        },\n        //colorscale: 'Viridis',\n        colorbar: {\n          title: \"Solution\",\n        },\n        name: \"Solution Field\",\n      };\n\n      // Create the plot using only the contour fill\n      Plotly.newPlot(plotDivId, [contourData], layout, { responsive: true });\n    }\n  }\n}\n","/**\n * ════════════════════════════════════════════════════════════\n *  FEAScript Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.1.4 | https://feascript.com\n * ════════════════════════════════════════════════════════════\n */\n\n// External imports\nimport * as Comlink from \"../vendor/comlink.mjs\";\n\n// Internal imports\nimport { basicLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Class to facilitate communication with web workers for FEAScript operations\n */\nexport class FEAScriptWorker {\n  /**\n   * Constructor to initialize the FEAScriptWorker class\n   * Sets up the worker and initializes the workerWrapper.\n   */\n  constructor() {\n    this.worker = null;\n    this.feaWorker = null;\n    this.isReady = false;\n\n    this._initWorker();\n  }\n\n  /**\n   * Function to initialize the web worker and wrap it using Comlink.\n   * @private\n   * @throws Will throw an error if the worker fails to initialize.\n   */\n  async _initWorker() {\n    try {\n      this.worker = new Worker(new URL(\"./wrapperScript.js\", import.meta.url), {\n        type: \"module\",\n      });\n\n      this.worker.onerror = (event) => {\n        console.error(\"FEAScriptWorker: Worker error:\", event);\n      };\n      const workerWrapper = Comlink.wrap(this.worker);\n\n      this.feaWorker = await new workerWrapper();\n\n      this.isReady = true;\n    } catch (error) {\n      console.error(\"Failed to initialize worker\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Function to ensure that the worker is ready before performing any operations.\n   * @private\n   * @returns {Promise<void>} Resolves when the worker is ready.\n   * @throws Will throw an error if the worker is not ready within the timeout period.\n   */\n  async _ensureReady() {\n    if (this.isReady) return Promise.resolve();\n\n    return new Promise((resolve, reject) => {\n      let attempts = 0;\n      const maxAttempts = 50; // 5 seconds max\n\n      const checkReady = () => {\n        attempts++;\n        if (this.isReady) {\n          resolve();\n        } else if (attempts >= maxAttempts) {\n          reject(new Error(\"Timeout waiting for worker to be ready\"));\n        } else {\n          setTimeout(checkReady, 1000);\n        }\n      };\n      checkReady();\n    });\n  }\n\n  /**\n   * Function to set the solver configuration in the worker.\n   * @param {string} solverConfig - The solver configuration to set.\n   * @returns {Promise<boolean>} Resolves when the configuration is set.\n   */\n  async setSolverConfig(solverConfig) {\n    await this._ensureReady();\n    basicLog(`FEAScriptWorker: Setting solver config to: ${solverConfig}`);\n    return this.feaWorker.setSolverConfig(solverConfig);\n  }\n\n  /**\n   * Sets the mesh configuration in the worker.\n   * @param {object} meshConfig - The mesh configuration to set.\n   * @returns {Promise<boolean>} Resolves when the configuration is set.\n   */\n  async setMeshConfig(meshConfig) {\n    await this._ensureReady();\n    basicLog(`FEAScriptWorker: Setting mesh config`);\n    return this.feaWorker.setMeshConfig(meshConfig);\n  }\n\n  /**\n   * Adds a boundary condition to the worker.\n   * @param {string} boundaryKey - The key identifying the boundary.\n   * @param {array} condition - The boundary condition to add.\n   * @returns {Promise<boolean>} Resolves when the boundary condition is added.\n   */\n  async addBoundaryCondition(boundaryKey, condition) {\n    await this._ensureReady();\n    basicLog(`FEAScriptWorker: Adding boundary condition for boundary: ${boundaryKey}`);\n    return this.feaWorker.addBoundaryCondition(boundaryKey, condition);\n  }\n\n  /**\n   * Sets the solver method in the worker.\n   * @param {string} solverMethod - The solver method to set.\n   * @returns {Promise<boolean>} Resolves when the solver method is set.\n   */\n  async setSolverMethod(solverMethod) {\n    await this._ensureReady();\n    basicLog(`FEAScriptWorker: Setting solver method to: ${solverMethod}`);\n    return this.feaWorker.setSolverMethod(solverMethod);\n  }\n\n  /**\n   * Requests the worker to solve the problem.\n   * @returns {Promise<object>} Resolves with the solution result.\n   */\n  async solve() {\n    await this._ensureReady();\n    basicLog(\"FEAScriptWorker: Requesting solution from worker...\");\n\n    const startTime = performance.now();\n    const result = await this.feaWorker.solve();\n    const endTime = performance.now();\n\n    basicLog(`FEAScriptWorker: Solution completed in ${((endTime - startTime) / 1000).toFixed(2)}s`);\n    return result;\n  }\n\n  /**\n   * Retrieves model information from the worker.\n   * @returns {Promise<object>} Resolves with the model information.\n   */\n  async getModelInfo() {\n    await this._ensureReady();\n    return this.feaWorker.getModelInfo();\n  }\n\n  /**\n   * Sends a ping request to the worker to check its availability.\n   * @returns {Promise<boolean>} Resolves if the worker responds.\n   */\n  async ping() {\n    await this._ensureReady();\n    return this.feaWorker.ping();\n  }\n\n  /**\n   * Terminates the worker and cleans up resources.\n   */\n  terminate() {\n    if (this.worker) {\n      this.worker.terminate();\n      this.worker = null;\n      this.feaWorker = null;\n      this.isReady = false;\n    }\n  }\n}\n","/**\n * ════════════════════════════════════════════════════════════\n *  FEAScript Library\n *  Lightweight Finite Element Simulation in JavaScript\n *  Version: 0.1.4 | https://feascript.com\n * ════════════════════════════════════════════════════════════\n */\n\nexport { FEAScriptModel } from \"./FEAScript.js\";\nexport { importGmshQuadTri } from \"./readers/gmshReaderScript.js\";\nexport { logSystem } from \"./utilities/loggingScript.js\";\nexport { plotSolution } from \"./visualization/plotSolutionScript.js\";\nexport { FEAScriptWorker } from \"./workers/workerScript.js\";\nexport const printVersion = \"0.1.4\";"],"names":["euclideanNorm","vector","norm","i","length","Math","sqrt","currentLogLevel","logSystem","level","console","log","basicLog","debugLog","message","errorLog","proxyMarker","Symbol","createEndpoint","releaseProxy","finalizer","throwMarker","isObject","val","transferHandlers","Map","canHandle","serialize","obj","port1","port2","MessageChannel","expose","deserialize","port","start","wrap","value","serialized","Error","isError","name","stack","Object","assign","ep","globalThis","allowedOrigins","addEventListener","callback","ev","data","origin","allowedOrigin","RegExp","test","isAllowedOrigin","warn","id","type","path","argumentList","map","fromWireValue","returnValue","parent","slice","reduce","prop","rawValue","apply","proxy","transfers","transferCache","set","transfer","undefined","Promise","resolve","catch","then","wireValue","transferables","toWireValue","postMessage","removeEventListener","closeEndPoint","error","TypeError","endpoint","constructor","isMessagePort","close","target","pendingListeners","resolver","get","delete","createProxy","throwIfProxyReleased","isReleased","releaseEndpoint","requestResponseMessage","proxyCounter","WeakMap","proxyFinalizers","FinalizationRegistry","newCount","isProxyReleased","Proxy","_target","unregister","unregisterProxy","clear","r","p","toString","bind","_thisArg","rawArgumentList","last","processArguments","construct","register","registerProxy","processed","v","arr","Array","prototype","concat","handler","serializedValue","msg","fill","floor","random","Number","MAX_SAFE_INTEGER","join","solveLinearSystem","solverMethod","jacobianMatrix","residualVector","options","maxIterations","tolerance","solutionVector","converged","iterations","time","jacobianMatrixSparse","math","sparse","luFactorization","slu","solutionMatrix","lusolve","squeeze","valueOf","jacobiSolverResult","A","b","x0","n","x","xNew","iter","sum","j","maxDiff","max","abs","jacobiSolver","timeEnd","async","solveLinearSystemAsync","isArray","toArray","created","computeEngine","worker","Worker","URL","url","Comlink.wrap","initialize","createDefaultComputeEngine","result","webgpuJacobiSolver","destroy","terminate","BasisFunctions","meshDimension","elementOrder","this","getBasisFunctions","ksi","eta","basisFunction","basisFunctionDerivKsi","basisFunctionDerivEta","l1","c","l2","l3","dl1","dl2","dl3","Mesh","numElementsX","maxX","numElementsY","maxY","parsedMesh","boundaryElementsProcessed","parseMeshFromGmsh","nodalNumbering","quadElements","triangleElements","JSON","stringify","elementTypes","mappedNodalNumbering","elemIdx","gmshNodes","feaScriptNodes","push","physicalPropMap","boundaryElements","fixedBoundaryElements","boundaryNodePairs","forEach","dimension","tag","nodesPair","node1","node2","foundElement","elemNodes","includes","side","node1Index","indexOf","node2Index","Mesh1D","super","generateMesh","nodesXCoordinates","totalNodesX","deltaX","nodeIndex","generate1DNodalNumbering","findBoundaryElements","nop","elementIndex","columnCounter","sideIndex","Mesh2D","nodesYCoordinates","totalNodesY","deltaY","nodeIndexY","nodeIndexX","nnode","generate2DNodalNumbering","rowCounter","elementIndexX","elementIndexY","nodeIndex1","nodeIndex2","NumericalIntegration","getGaussPointsAndWeights","gaussPoints","gaussWeights","prepareMesh","meshConfig","mesh","nodesCoordinatesAndNumbering","totalElements","totalNodes","initializeFEA","meshData","colIndex","basisFunctions","gaussPointsAndWeights","localToGlobalMap","numNodes","performIsoparametricMapping1D","params","xCoordinates","ksiDerivX","localNodeIndex","detJacobian","basisFunctionDerivX","performIsoparametricMapping2D","yCoordinates","etaDerivX","ksiDerivY","etaDerivY","basisFunctionDerivY","ThermalBoundaryConditions","boundaryConditions","imposeConstantTempBoundaryConditions","keys","boundaryKey","tempValue","globalNodeIndex","imposeConstantTempBoundaryConditionsFront","nodeConstraintCode","boundaryValues","imposeConvectionBoundaryConditions","convectionHeatTranfCoeff","convectionExtTemp","key","boundaryCondition","convectionCoeff","extTemp","gaussPoint1","gaussPoint2","firstNodeIndex","lastNodeIndex","nodeIncrement","basisFunctionsAndDerivatives","tangentVectorLength","localNodeIndex2","globalNodeIndex2","gaussPointIndex","imposeConvectionBoundaryConditionsFront","localJacobianMatrix","localResidualVector","boundaryElement","find","_","assembleHeatConductionMat","FEAData","gaussPointIndex1","mappingResult","localNodeIndex1","localToGlobalMap1","localToGlobalMap2","gaussPointIndex2","thermalBoundaryConditions","assembleHeatConductionFront","ngl","globalIndex","GenericBoundaryConditions","imposeDirichletBoundaryConditions","imposeConstantValueBoundaryConditionsFront","assembleFrontPropagationMat","eikonalActivationFlag","eikonalViscousTerm","solutionDerivX","solutionDerivY","assembleFrontPropagationFront","frontalData","frontalState","elementData","currentElementIndex","frontStorage","runFrontalSolver","assembleFront","numElements","globalResidualVector","topologyData","lateralData","writeFlag","transformationFlag","nodesPerElement","determinant","systemSize","globalSolutionVector","frontDataIndex","frontSize","frontWidthEstimate","ceil","estimateFrontSize","frontValues","columnHeaders","pivotRow","pivotData","initializeFrontalArrays","dirichletBoundaryConditionsHandler","currentSolutionVector","pivotColumnGlobalIndex","localDestination","rowDestination","rowHeaders","pivotRowIndices","pivotColumnIndices","modifiedRows","pivotColumn","frontMatrix","rowSwapCount","columnSwapCount","lastAppearanceCheck","frontDataCounter","pivotDataIndex","summedRows","reverseElementIndex","columnCount","rowCount","assembled","numElementNodes","numElementColumns","assembleElementContribution","currentElement","columnIndex","rowIndex","localColumnIndex","frontColumnIndex","localRowIndex","availableColumnCount","constrainedRowCount","availableRowCount","absoluteNodeIndex","constrainedIndex","pivotRowIndex","pivotColumnIndex","pivotValue","testColumnIndex","testRowIndex","testValue","pivotGlobalRowIndex","permutationHelper","rightHandSide","globalRowIndex","eliminationFactor","performBackSubstitution","runFrontalAlgorithm","toExponential","finalNodesX","finalNodesY","nodesCoordinates","boundaryLocalJacobianMatrix","boundaryResidualVector","isOnRobinTypeBoundary","some","localNodeI","localNodeJ","iterationIndex","accumulatedValue","newtonRaphson","assembleMat","context","errorNorm","initialSolution","FEAScriptModel","solverConfig","coefficientFunctions","setSolverConfig","setMeshConfig","addBoundaryCondition","condition","setSolverMethod","solve","eikonalExteralIterations","newtonRaphsonResult","B","C","D","xCoord","a","d","globalNodeIndex1","assembleGeneralFormPDEMat","solveAsync","importGmshQuadTri","file","gmshV","ascii","fltBytes","lines","text","split","line","trim","filter","section","lineIndex","nodeEntityBlocks","nodeBlocksProcessed","currentNodeBlock","nodeTagsCollected","nodeTags","nodeCoordinatesCollected","elementEntityBlocks","elementBlocksProcessed","currentElementBlock","dim","elementType","elementsProcessedInBlock","boundaryElementsByTag","parts","part","parseFloat","parseInt","replace","parametric","nodeTag","y","nodeIndices","idx","physicalTag","boundaryNodes","nodes","plotSolution","plotType","plotDivId","meshType","yData","xData","from","lineData","mode","color","width","maxWindowWidth","min","window","innerWidth","maxPlotWidth","zoomFactor","layout","title","height","xaxis","yaxis","margin","l","t","Plotly","newPlot","responsive","isStructured","uniqueXCoords","Set","size","uniqueYCoords","zValues","aspectRatio","plotWidth","hovermode","numNodesX","numNodesY","reshape","reshapedYCoordinates","reshapedSolution","transposedSolution","transpose","reshapedXForPlot","xValue","contourData","z","contours","coloring","showlabels","colorbar","FEAScriptWorker","feaWorker","isReady","_initWorker","onerror","event","workerWrapper","_ensureReady","reject","attempts","checkReady","setTimeout","startTime","performance","now","toFixed","getModelInfo","ping","printVersion"],"mappings":"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"}