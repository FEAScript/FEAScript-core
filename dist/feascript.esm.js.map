{"version":3,"file":"feascript.esm.js","sources":["../src/methods/euclideanNormScript.js","../src/utilities/loggingScript.js","../src/methods/conjugateGradientWebGPUScript.js","../src/methods/linearSystemSolverScript.js","../src/methods/jacobiSolverScript.js","../src/methods/newtonRaphsonScript.js","../src/utilities/helperFunctionsScript.js","../src/solvers/genericBoundaryConditionsScript.js","../src/mesh/basisFunctionsScript.js","../src/mesh/meshGenerationScript.js","../src/methods/numericalIntegrationScript.js","../src/solvers/frontPropagationScript.js","../src/solvers/thermalBoundaryConditionsScript.js","../src/FEAScript.js","../src/solvers/solidHeatTransferScript.js","../src/readers/gmshReaderScript.js","../src/visualization/plotSolutionScript.js","../src/vendor/comlink.mjs","../src/workers/workerScript.js","../src/index.js"],"sourcesContent":["//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n/**\n * Function to calculate the Euclidean norm of a vector\n * @param {array} vector - The input vector\n * @returns {number} The Euclidean norm of the vector\n */\nexport function euclideanNorm(vector) {\n  let norm = 0;\n  for (let i = 0; i < vector.length; i++) {\n    norm += vector[i] * vector[i];\n  }\n  norm = Math.sqrt(norm);\n  return norm;\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n// Global logging level\nlet currentLogLevel = \"basic\";\n\n/**\n * Function to set the logging system level\n * @param {string} level - Logging level (basic, debug)\n */\nexport function logSystem(level) {\n  if (level !== \"basic\" && level !== \"debug\") {\n    console.log(\n      \"%c[WARN] Invalid log level: \" + level + \". Using basic instead.\",\n      \"color: #FFC107; font-weight: bold;\"\n    ); // Yellow for warnings\n    currentLogLevel = \"basic\";\n  } else {\n    currentLogLevel = level;\n    basicLog(`Log level set to: ${level}`);\n  }\n}\n\n/**\n * Function to log debug messages - only logs if level is 'debug'\n * @param {string} message - Message to log\n */\nexport function debugLog(message) {\n  if (currentLogLevel === \"debug\") {\n    console.log(\"%c[DEBUG] \" + message, \"color: #2196F3; font-weight: bold;\"); // Blue color for debug\n  }\n}\n\n/**\n * Function to log basic information - always logs\n * @param {string} message - Message to log\n */\nexport function basicLog(message) {\n  console.log(\"%c[INFO] \" + message, \"color: #4CAF50; font-weight: bold;\"); // Green color for basic info\n}\n\n/**\n * Function to log error messages\n * @param {string} message - Message to log\n */\nexport function errorLog(message) {\n  console.log(\"%c[ERROR] \" + message, \"color: #F44336; font-weight: bold;\"); // Red color for errors\n}\n\n/**\n * Function to handle version information and fetch the latest update date and release from GitHub\n */\nexport async function printVersion() {\n  basicLog(\"Fetching latest FEAScript version information...\");\n  try {\n    const commitResponse = await fetch(\"https://api.github.com/repos/FEAScript/FEAScript/commits/main\");\n    const commitData = await commitResponse.json();\n    const latestCommitDate = new Date(commitData.commit.committer.date).toLocaleString();\n    basicLog(`Latest FEAScript update: ${latestCommitDate}`);\n    return latestCommitDate;\n  } catch (error) {\n    errorLog(\"Failed to fetch version information: \" + error);\n    return \"Version information unavailable\";\n  }\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n// Internal imports\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * WebGPU-accelerated Conjugate Gradient solver for improved precision and performance\n * @param {Array} jacobianMatrix - The coefficient matrix (must be symmetric positive definite)\n * @param {Array} residualVector - The right-hand side vector\n * @param {Array} initialGuess - Initial guess for solution vector\n * @param {object} [options] - Options for the solver\n * @param {number} [options.maxIterations=1000] - Maximum number of iterations\n * @param {number} [options.tolerance=1e-9] - Convergence tolerance (more precise than default)\n * @param {boolean} [options.enablePrecision=true] - Enable high precision computations\n * @returns {object} An object containing:\n *  - solutionVector: The solution vector\n *  - iterations: The number of iterations performed\n *  - converged: Boolean indicating whether the method converged\n *  - residualNorm: Final residual norm\n */\nexport async function conjugateGradientWebGPU(jacobianMatrix, residualVector, initialGuess, options = {}) {\n  const { maxIterations = 1000, tolerance = 1e-9, enablePrecision = true } = options;\n  \n  // Check if WebGPU is available\n  if (!navigator.gpu) {\n    debugLog(\"WebGPU not available, falling back to CPU implementation\");\n    return conjugateGradientCPU(jacobianMatrix, residualVector, initialGuess, options);\n  }\n\n  try {\n    const adapter = await navigator.gpu.requestAdapter();\n    if (!adapter) {\n      debugLog(\"WebGPU adapter not available, falling back to CPU implementation\");\n      return conjugateGradientCPU(jacobianMatrix, residualVector, initialGuess, options);\n    }\n\n    const device = await adapter.requestDevice();\n    const n = jacobianMatrix.length;\n\n    // Initialize solution vector\n    let x = [...initialGuess];\n\n    // Compute initial residual: r = b - A*x\n    let r = computeResidual(jacobianMatrix, residualVector, x);\n    let p = [...r]; // Initial search direction\n    let rsold = dotProduct(r, r);\n\n    let iteration = 0;\n    let converged = false;\n\n    basicLog(`Starting WebGPU Conjugate Gradient solver for system of size ${n}`);\n\n    while (iteration < maxIterations && !converged) {\n      // Compute A*p\n      const Ap = matrixVectorProduct(jacobianMatrix, p);\n      \n      // Compute alpha = rsold / (p^T * A * p)\n      const pAp = dotProduct(p, Ap);\n      \n      if (Math.abs(pAp) < 1e-16) {\n        errorLog(\"Matrix is not positive definite or numerical breakdown occurred\");\n        break;\n      }\n      \n      const alpha = rsold / pAp;\n\n      // Update solution: x = x + alpha * p\n      for (let i = 0; i < n; i++) {\n        x[i] += alpha * p[i];\n      }\n\n      // Update residual: r = r - alpha * A * p\n      for (let i = 0; i < n; i++) {\n        r[i] -= alpha * Ap[i];\n      }\n\n      // Compute new rsold\n      const rsnew = dotProduct(r, r);\n      const residualNorm = Math.sqrt(rsnew);\n\n      // Check convergence with improved precision criteria\n      if (residualNorm < tolerance) {\n        converged = true;\n        debugLog(`WebGPU CG converged in ${iteration + 1} iterations with residual norm ${residualNorm.toExponential(6)}`);\n        break;\n      }\n\n      // Compute beta = rsnew / rsold\n      const beta = rsnew / rsold;\n\n      // Update search direction: p = r + beta * p\n      for (let i = 0; i < n; i++) {\n        p[i] = r[i] + beta * p[i];\n      }\n\n      rsold = rsnew;\n      iteration++;\n\n      // Log progress every 100 iterations\n      if (iteration % 100 === 0) {\n        debugLog(`WebGPU CG iteration ${iteration}: residual norm = ${residualNorm.toExponential(6)}`);\n      }\n    }\n\n    const finalResidualNorm = Math.sqrt(dotProduct(r, r));\n\n    if (!converged) {\n      debugLog(`WebGPU CG did not converge after ${maxIterations} iterations. Final residual norm: ${finalResidualNorm.toExponential(6)}`);\n    }\n\n    return {\n      solutionVector: x,\n      iterations: iteration,\n      converged: converged,\n      residualNorm: finalResidualNorm\n    };\n\n  } catch (error) {\n    errorLog(`WebGPU error occurred: ${error.message}`);\n    debugLog(\"Falling back to CPU implementation\");\n    return conjugateGradientCPU(jacobianMatrix, residualVector, initialGuess, options);\n  }\n}\n\n/**\n * CPU fallback implementation of Conjugate Gradient solver with improved precision\n */\nfunction conjugateGradientCPU(jacobianMatrix, residualVector, initialGuess, options = {}) {\n  const { maxIterations = 1000, tolerance = 1e-9 } = options;\n  const n = jacobianMatrix.length;\n\n  // Initialize solution vector\n  let x = [...initialGuess];\n\n  // Compute initial residual: r = b - A*x\n  let r = computeResidual(jacobianMatrix, residualVector, x);\n  let p = [...r]; // Initial search direction\n  let rsold = dotProduct(r, r);\n\n  let iteration = 0;\n  let converged = false;\n\n  basicLog(`Starting CPU Conjugate Gradient solver for system of size ${n}`);\n\n  while (iteration < maxIterations && !converged) {\n    // Compute A*p\n    const Ap = matrixVectorProduct(jacobianMatrix, p);\n    \n    // Compute alpha = rsold / (p^T * A * p)\n    const pAp = dotProduct(p, Ap);\n    \n    if (Math.abs(pAp) < 1e-16) {\n      errorLog(\"Matrix is not positive definite or numerical breakdown occurred\");\n      break;\n    }\n    \n    const alpha = rsold / pAp;\n\n    // Update solution: x = x + alpha * p (using higher precision arithmetic)\n    for (let i = 0; i < n; i++) {\n      x[i] = Number(x[i]) + Number(alpha * p[i]);\n    }\n\n    // Update residual: r = r - alpha * A * p\n    for (let i = 0; i < n; i++) {\n      r[i] = Number(r[i]) - Number(alpha * Ap[i]);\n    }\n\n    // Compute new rsold with improved precision\n    const rsnew = dotProduct(r, r);\n    const residualNorm = Math.sqrt(rsnew);\n\n    // Check convergence with improved precision criteria\n    if (residualNorm < tolerance) {\n      converged = true;\n      debugLog(`CPU CG converged in ${iteration + 1} iterations with residual norm ${residualNorm.toExponential(6)}`);\n      break;\n    }\n\n    // Compute beta = rsnew / rsold\n    const beta = rsnew / rsold;\n\n    // Update search direction: p = r + beta * p\n    for (let i = 0; i < n; i++) {\n      p[i] = Number(r[i]) + Number(beta * p[i]);\n    }\n\n    rsold = rsnew;\n    iteration++;\n\n    // Log progress every 100 iterations\n    if (iteration % 100 === 0) {\n      debugLog(`CPU CG iteration ${iteration}: residual norm = ${residualNorm.toExponential(6)}`);\n    }\n  }\n\n  const finalResidualNorm = Math.sqrt(dotProduct(r, r));\n\n  if (!converged) {\n    debugLog(`CPU CG did not converge after ${maxIterations} iterations. Final residual norm: ${finalResidualNorm.toExponential(6)}`);\n  }\n\n  return {\n    solutionVector: x,\n    iterations: iteration,\n    converged: converged,\n    residualNorm: finalResidualNorm\n  };\n}\n\n/**\n * Compute residual vector r = b - A*x with improved precision\n */\nfunction computeResidual(A, b, x) {\n  const n = A.length;\n  const r = new Array(n);\n  \n  for (let i = 0; i < n; i++) {\n    let sum = 0;\n    for (let j = 0; j < n; j++) {\n      sum += Number(A[i][j]) * Number(x[j]);\n    }\n    r[i] = Number(b[i]) - sum;\n  }\n  \n  return r;\n}\n\n/**\n * Compute matrix-vector product A*v with improved precision\n */\nfunction matrixVectorProduct(A, v) {\n  const n = A.length;\n  const result = new Array(n);\n  \n  for (let i = 0; i < n; i++) {\n    let sum = 0;\n    for (let j = 0; j < n; j++) {\n      sum += Number(A[i][j]) * Number(v[j]);\n    }\n    result[i] = sum;\n  }\n  \n  return result;\n}\n\n/**\n * Compute dot product of two vectors with improved precision\n */\nfunction dotProduct(u, v) {\n  let sum = 0;\n  for (let i = 0; i < u.length; i++) {\n    sum += Number(u[i]) * Number(v[i]);\n  }\n  return sum;\n}","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n// Internal imports\nimport { jacobiSolver } from \"./jacobiSolverScript.js\";\nimport { conjugateGradientWebGPU } from \"./conjugateGradientWebGPUScript.js\";\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Function to solve a system of linear equations using different solver methods\n * @param {string} solverMethod - The solver method to use (\"lusolve\", \"jacobi\", or \"conjugate-gradient-webgpu\")\n * @param {Array} jacobianMatrix - The coefficient matrix\n * @param {Array} residualVector - The right-hand side vector\n * @param {object} [options] - Additional options for the solver\n * @param {number} [options.maxIterations=1000] - Maximum iterations for iterative methods\n * @param {number} [options.tolerance=1e-6] - Convergence tolerance for iterative methods\n * @returns {object} An object containing:\n *  - solutionVector: The solution vector\n *  - converged: Boolean indicating whether the method converged (for iterative methods)\n *  - iterations: Number of iterations performed (for iterative methods)\n */\nexport async function solveLinearSystem(solverMethod, jacobianMatrix, residualVector, options = {}) {\n  const { maxIterations = 1000, tolerance = 1e-6 } = options;\n\n  let solutionVector = [];\n  let converged = true;\n  let iterations = 0;\n\n  // Solve the linear system based on the specified solver method\n  basicLog(`Solving system using ${solverMethod}...`);\n  console.time(\"systemSolving\");\n\n  if (solverMethod === \"lusolve\") {\n    // Use LU decomposition method\n    solutionVector = math.lusolve(jacobianMatrix, residualVector);\n  } else if (solverMethod === \"jacobi\") {\n    // Use Jacobi method\n    const initialGuess = new Array(residualVector.length).fill(0);\n    const jacobiSolverResult = jacobiSolver(jacobianMatrix, residualVector, initialGuess, {\n      maxIterations,\n      tolerance,\n    });\n\n    // Log convergence information\n    if (jacobiSolverResult.converged) {\n      debugLog(`Jacobi method converged in ${jacobiSolverResult.iterations} iterations`);\n    } else {\n      debugLog(`Jacobi method did not converge after ${jacobiSolverResult.iterations} iterations`);\n    }\n\n    solutionVector = jacobiSolverResult.solutionVector;\n    converged = jacobiSolverResult.converged;\n    iterations = jacobiSolverResult.iterations;\n  } else if (solverMethod === \"conjugate-gradient-webgpu\") {\n    // Use WebGPU-accelerated Conjugate Gradient method\n    const initialGuess = new Array(residualVector.length).fill(0);\n    \n    // Use higher precision tolerance for conjugate gradient\n    const cgTolerance = Math.min(tolerance, 1e-9);\n    \n    const cgResult = await conjugateGradientWebGPU(jacobianMatrix, residualVector, initialGuess, {\n      maxIterations,\n      tolerance: cgTolerance,\n      enablePrecision: true,\n    });\n\n    // Log convergence information\n    if (cgResult.converged) {\n      debugLog(`WebGPU Conjugate Gradient method converged in ${cgResult.iterations} iterations with residual norm ${cgResult.residualNorm.toExponential(6)}`);\n    } else {\n      debugLog(`WebGPU Conjugate Gradient method did not converge after ${cgResult.iterations} iterations. Final residual norm: ${cgResult.residualNorm.toExponential(6)}`);\n    }\n\n    solutionVector = cgResult.solutionVector;\n    converged = cgResult.converged;\n    iterations = cgResult.iterations;\n  } else {\n    errorLog(`Unknown solver method: ${solverMethod}`);\n  }\n\n  console.timeEnd(\"systemSolving\");\n  basicLog(\"System solved successfully\");\n\n  return { solutionVector, converged, iterations };\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n/**\n * Function to solve a system of linear equations using the Jacobi iterative method\n * @param {array} jacobianMatrix - The coefficient matrix (must be square)\n * @param {array} residualVector - The right-hand side vector\n * @param {array} initialGuess - Initial guess for solution vector\n * @param {object} [options] - Options for the solver\n * @param {number} [options.maxIterations=1000] - Maximum number of iterations\n * @param {number} [options.tolerance=1e-6] - Convergence tolerance\n * @returns {object} An object containing:\n *  - solutionVector: The solution vector\n *  - iterations: The number of iterations performed\n *  - converged: Boolean indicating whether the method converged\n */\nexport function jacobiSolver(jacobianMatrix, residualVector, initialGuess, options = {}) {\n  const { maxIterations = 1000, tolerance = 1e-6 } = options;\n  const n = jacobianMatrix.length; // Size of the square matrix\n  let x = [...initialGuess]; // Current solution (starts with initial guess)\n  let xNew = new Array(n); // Next iteration's solution\n\n  for (let iteration = 0; iteration < maxIterations; iteration++) {\n    // Perform one iteration\n    for (let i = 0; i < n; i++) {\n      let sum = 0;\n      // Calculate sum of jacobianMatrix[i][j] * x[j] for j â‰  i\n      for (let j = 0; j < n; j++) {\n        if (j !== i) {\n          sum += jacobianMatrix[i][j] * x[j];\n        }\n      }\n      // Update xNew[i] using the Jacobi formula\n      xNew[i] = (residualVector[i] - sum) / jacobianMatrix[i][i];\n    }\n\n    // Check convergence\n    let maxDiff = 0;\n    for (let i = 0; i < n; i++) {\n      maxDiff = Math.max(maxDiff, Math.abs(xNew[i] - x[i]));\n    }\n\n    // Update x for next iteration\n    x = [...xNew];\n\n    // Successfully converged if maxDiff is less than tolerance\n    if (maxDiff < tolerance) {\n      return {\n        solutionVector: x,\n        iterations: iteration + 1,\n        converged: true,\n      };\n    }\n  }\n\n  // maxIterations were reached without convergence\n  return {\n    solutionVector: x,\n    iterations: maxIterations,\n    converged: false,\n  };\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n// Internal imports\nimport { euclideanNorm } from \"../methods/euclideanNormScript.js\";\nimport { solveLinearSystem } from \"./linearSystemSolverScript.js\";\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\nimport { calculateSystemSize } from \"../utilities/helperFunctionsScript.js\";\n\n/**\n * Function to solve a system of nonlinear equations using the Newton-Raphson method\n * @param {number} [maxIterations=100] - Maximum number of iterations\n * @param {number} [tolerance=1e-4] - Convergence tolerance\n * @returns {object} An object containing:\n *  - solutionVector: The solution vector\n *  - iterations: The number of iterations performed\n *  - converged: Boolean indicating whether the method converged\n */\n\nexport async function newtonRaphson(assembleMat, context, maxIterations = 100, tolerance = 1e-4) {\n  let errorNorm = 0;\n  let converged = false;\n  let iterations = 0;\n  let deltaX = [];\n  let solutionVector = [];\n  let jacobianMatrix = [];\n  let residualVector = [];\n  let nodesCoordinates = {};\n\n  // Calculate system size directly from meshConfig\n  let totalNodes = calculateSystemSize(context.meshConfig);\n\n  // Initialize arrays with proper size\n  for (let i = 0; i < totalNodes; i++) {\n    deltaX[i] = 0;\n    solutionVector[i] = 0;\n  }\n\n  // Initialize solution from context if available\n  if (context.initialSolution && context.initialSolution.length === totalNodes) {\n    solutionVector = [...context.initialSolution];\n  }\n\n  while (iterations < maxIterations && !converged) {\n    // Update solution\n    for (let i = 0; i < solutionVector.length; i++) {\n      solutionVector[i] = Number(solutionVector[i]) + Number(deltaX[i]);\n    }\n\n    // Compute Jacobian and residual matrices\n    ({ jacobianMatrix, residualVector, nodesCoordinates } = assembleMat(\n      context.meshConfig,\n      context.boundaryConditions,\n      solutionVector, // The solution vector is required in the case of a non-linear equation\n      context.eikonalActivationFlag\n    ));\n\n    // Solve the linear system based on the specified solver method\n    const linearSystemResult = await solveLinearSystem(context.solverMethod, jacobianMatrix, residualVector);\n    deltaX = linearSystemResult.solutionVector;\n\n    // Check convergence\n    errorNorm = euclideanNorm(deltaX);\n\n    // Norm for each iteration\n    basicLog(`Newton-Raphson iteration ${iterations + 1}: Error norm = ${errorNorm.toExponential(4)}`);\n\n    if (errorNorm <= tolerance) {\n      converged = true;\n    } else if (errorNorm > 1e2) {\n      errorLog(`Solution not converged. Error norm: ${errorNorm}`);\n      break;\n    }\n\n    iterations++;\n  }\n\n  return {\n    solutionVector,\n    converged,\n    iterations,\n    jacobianMatrix,\n    residualVector,\n    nodesCoordinates,\n  };\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n/**\n * Helper function to calculate system size from mesh configuration\n * @param {object} meshConfig - Mesh configuration object\n * @returns {number} Total number of nodes in the system\n */\nexport function calculateSystemSize(meshConfig) {\n  const { meshDimension, numElementsX, numElementsY, elementOrder, parsedMesh } = meshConfig;\n\n  if (parsedMesh && parsedMesh.nodesXCoordinates) {\n    // For parsed meshes (like from GMSH)\n    return parsedMesh.nodesXCoordinates.length;\n  } else {\n    // For geometry-based meshes\n    let nodesX,\n      nodesY = 1;\n\n    if (elementOrder === \"linear\") {\n      nodesX = numElementsX + 1;\n      if (meshDimension === \"2D\") nodesY = numElementsY + 1;\n    } else if (elementOrder === \"quadratic\") {\n      nodesX = 2 * numElementsX + 1;\n      if (meshDimension === \"2D\") nodesY = 2 * numElementsY + 1;\n    }\n\n    return nodesX * nodesY;\n  }\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n// Internal imports\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n// This class is essentially the same with ThermalBoundaryConditions\n// Need to consolidate them in the future\n\n/**\n * Class to handle generic boundary conditions application\n */\nexport class GenericBoundaryConditions {\n  /**\n   * Constructor to initialize the GenericBoundaryConditions class\n   * @param {object} boundaryConditions - Object containing boundary conditions for the finite element analysis\n   * @param {array} boundaryElements - Array containing elements that belong to each boundary\n   * @param {array} nop - Nodal numbering (NOP) array representing the connectivity between elements and nodes\n   * @param {string} meshDimension - The dimension of the mesh (e.g., \"2D\")\n   * @param {string} elementOrder - The order of elements (e.g., \"linear\", \"quadratic\")\n   */\n  constructor(boundaryConditions, boundaryElements, nop, meshDimension, elementOrder) {\n    this.boundaryConditions = boundaryConditions;\n    this.boundaryElements = boundaryElements;\n    this.nop = nop;\n    this.meshDimension = meshDimension;\n    this.elementOrder = elementOrder;\n  }\n\n  /**\n   * Function to impose constant value boundary conditions (Dirichlet type)\n   * @param {array} residualVector - The residual vector to be modified\n   * @param {array} jacobianMatrix - The Jacobian matrix to be modified\n   */\n  imposeConstantValueBoundaryConditions(residualVector, jacobianMatrix) {\n    basicLog(\"Applying constant value boundary conditions (Dirichlet type)\");\n    if (this.meshDimension === \"1D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        if (this.boundaryConditions[boundaryKey][0] === \"constantValue\") {\n          const value = this.boundaryConditions[boundaryKey][1];\n          debugLog(`Boundary ${boundaryKey}: Applying constant value of ${value} (Dirichlet condition)`);\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            if (this.elementOrder === \"linear\") {\n              const boundarySides = {\n                0: [0], // Node at the left side of the reference element\n                1: [1], // Node at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant value to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                // Set the residual vector to the constantValue\n                residualVector[globalNodeIndex] = value;\n                // Set the Jacobian matrix row to zero\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\n                }\n                // Set the diagonal entry of the Jacobian matrix to one\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\n              });\n            } else if (this.elementOrder === \"quadratic\") {\n              const boundarySides = {\n                0: [0], // Node at the left side of the reference element\n                2: [2], // Node at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant value to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                // Set the residual vector to the constantValue\n                residualVector[globalNodeIndex] = value;\n                // Set the Jacobian matrix row to zero\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\n                }\n                // Set the diagonal entry of the Jacobian matrix to one\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\n              });\n            }\n          });\n        }\n      });\n    } else if (this.meshDimension === \"2D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        if (this.boundaryConditions[boundaryKey][0] === \"constantValue\") {\n          const value = this.boundaryConditions[boundaryKey][1];\n          debugLog(`Boundary ${boundaryKey}: Applying constant value of ${value} (Dirichlet condition)`);\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            if (this.elementOrder === \"linear\") {\n              const boundarySides = {\n                0: [0, 2], // Nodes at the bottom side of the reference element\n                1: [0, 1], // Nodes at the left side of the reference element\n                2: [1, 3], // Nodes at the top side of the reference element\n                3: [2, 3], // Nodes at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant value to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                // Set the residual vector to the constantValue\n                residualVector[globalNodeIndex] = value;\n                // Set the Jacobian matrix row to zero\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\n                }\n                // Set the diagonal entry of the Jacobian matrix to one\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\n              });\n            } else if (this.elementOrder === \"quadratic\") {\n              const boundarySides = {\n                0: [0, 3, 6], // Nodes at the bottom side of the reference element\n                1: [0, 1, 2], // Nodes at the left side of the reference element\n                2: [2, 5, 8], // Nodes at the top side of the reference element\n                3: [6, 7, 8], // Nodes at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant value to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                // Set the residual vector to the constantValue\n                residualVector[globalNodeIndex] = value;\n                // Set the Jacobian matrix row to zero\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\n                }\n                // Set the diagonal entry of the Jacobian matrix to one\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\n              });\n            }\n          });\n        }\n      });\n    }\n  }\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n// Internal imports\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Class to handle basis functions and their derivatives based on element configuration\n */\nexport class BasisFunctions {\n  /**\n   * Constructor to initialize the BasisFunctions class\n   * @param {string} meshDimension - The dimension of the mesh\n   * @param {string} elementOrder - The order of elements\n   */\n  constructor({ meshDimension, elementOrder }) {\n    this.meshDimension = meshDimension;\n    this.elementOrder = elementOrder;\n  }\n\n  /**\n   * Function to calculate basis functions and their derivatives based on the dimension and order\n   * @param {number} ksi - Natural coordinate (for both 1D and 2D)\n   * @param {number} [eta] - Second natural coordinate (only for 2D elements)\n   * @returns {object} An object containing:\n   *  - basisFunction: Array of evaluated basis functions\n   *  - basisFunctionDerivKsi: Array of derivatives of basis functions with respect to ksi\n   *  - basisFunctionDerivEta: Array of derivatives of basis functions with respect to eta (only for 2D elements)\n   */\n  getBasisFunctions(ksi, eta = null) {\n    let basisFunction = [];\n    let basisFunctionDerivKsi = [];\n    let basisFunctionDerivEta = [];\n\n    if (this.meshDimension === \"1D\") {\n      if (this.elementOrder === \"linear\") {\n        // Linear basis functions for 1D elements\n        basisFunction[0] = 1 - ksi;\n        basisFunction[1] = ksi;\n\n        // Derivatives of basis functions with respect to ksi\n        basisFunctionDerivKsi[0] = -1;\n        basisFunctionDerivKsi[1] = 1;\n      } else if (this.elementOrder === \"quadratic\") {\n        // Quadratic basis functions for 1D elements\n        basisFunction[0] = 1 - 3 * ksi + 2 * ksi ** 2;\n        basisFunction[1] = 4 * ksi - 4 * ksi ** 2;\n        basisFunction[2] = -ksi + 2 * ksi ** 2;\n\n        // Derivatives of basis functions with respect to ksi\n        basisFunctionDerivKsi[0] = -3 + 4 * ksi;\n        basisFunctionDerivKsi[1] = 4 - 8 * ksi;\n        basisFunctionDerivKsi[2] = -1 + 4 * ksi;\n      }\n    } else if (this.meshDimension === \"2D\") {\n      if (eta === null) {\n        errorLog(\"Eta coordinate is required for 2D elements\");\n        return;\n      }\n\n      if (this.elementOrder === \"linear\") {\n        // Linear basis functions for 2D elements\n        function l1(c) {\n          return 1 - c;\n        }\n        function l2(c) {\n          return c;\n        }\n        function dl1() {\n          return -1;\n        }\n        function dl2() {\n          return 1;\n        }\n\n        // Evaluate basis functions at (ksi, eta)\n        basisFunction[0] = l1(ksi) * l1(eta);\n        basisFunction[1] = l1(ksi) * l2(eta);\n        basisFunction[2] = l2(ksi) * l1(eta);\n        basisFunction[3] = l2(ksi) * l2(eta);\n\n        // Derivatives with respect to ksi\n        basisFunctionDerivKsi[0] = dl1() * l1(eta);\n        basisFunctionDerivKsi[1] = dl1() * l2(eta);\n        basisFunctionDerivKsi[2] = dl2() * l1(eta);\n        basisFunctionDerivKsi[3] = dl2() * l2(eta);\n\n        // Derivatives with respect to eta\n        basisFunctionDerivEta[0] = l1(ksi) * dl1();\n        basisFunctionDerivEta[1] = l1(ksi) * dl2();\n        basisFunctionDerivEta[2] = l2(ksi) * dl1();\n        basisFunctionDerivEta[3] = l2(ksi) * dl2();\n      } else if (this.elementOrder === \"quadratic\") {\n        // Quadratic basis functions for 2D elements\n        function l1(c) {\n          return 2 * c ** 2 - 3 * c + 1;\n        }\n        function l2(c) {\n          return -4 * c ** 2 + 4 * c;\n        }\n        function l3(c) {\n          return 2 * c ** 2 - c;\n        }\n        function dl1(c) {\n          return 4 * c - 3;\n        }\n        function dl2(c) {\n          return -8 * c + 4;\n        }\n        function dl3(c) {\n          return 4 * c - 1;\n        }\n\n        // Evaluate basis functions at (ksi, eta)\n        basisFunction[0] = l1(ksi) * l1(eta);\n        basisFunction[1] = l1(ksi) * l2(eta);\n        basisFunction[2] = l1(ksi) * l3(eta);\n        basisFunction[3] = l2(ksi) * l1(eta);\n        basisFunction[4] = l2(ksi) * l2(eta);\n        basisFunction[5] = l2(ksi) * l3(eta);\n        basisFunction[6] = l3(ksi) * l1(eta);\n        basisFunction[7] = l3(ksi) * l2(eta);\n        basisFunction[8] = l3(ksi) * l3(eta);\n\n        // Derivatives with respect to ksi\n        basisFunctionDerivKsi[0] = dl1(ksi) * l1(eta);\n        basisFunctionDerivKsi[1] = dl1(ksi) * l2(eta);\n        basisFunctionDerivKsi[2] = dl1(ksi) * l3(eta);\n        basisFunctionDerivKsi[3] = dl2(ksi) * l1(eta);\n        basisFunctionDerivKsi[4] = dl2(ksi) * l2(eta);\n        basisFunctionDerivKsi[5] = dl2(ksi) * l3(eta);\n        basisFunctionDerivKsi[6] = dl3(ksi) * l1(eta);\n        basisFunctionDerivKsi[7] = dl3(ksi) * l2(eta);\n        basisFunctionDerivKsi[8] = dl3(ksi) * l3(eta);\n\n        // Derivatives with respect to eta\n        basisFunctionDerivEta[0] = l1(ksi) * dl1(eta);\n        basisFunctionDerivEta[1] = l1(ksi) * dl2(eta);\n        basisFunctionDerivEta[2] = l1(ksi) * dl3(eta);\n        basisFunctionDerivEta[3] = l2(ksi) * dl1(eta);\n        basisFunctionDerivEta[4] = l2(ksi) * dl2(eta);\n        basisFunctionDerivEta[5] = l2(ksi) * dl3(eta);\n        basisFunctionDerivEta[6] = l3(ksi) * dl1(eta);\n        basisFunctionDerivEta[7] = l3(ksi) * dl2(eta);\n        basisFunctionDerivEta[8] = l3(ksi) * dl3(eta);\n      }\n    }\n\n    return { basisFunction, basisFunctionDerivKsi, basisFunctionDerivEta };\n  }\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n// Internal imports\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Basic structure for the mesh\n */\nexport class Mesh {\n  /**\n   * Constructor to initialize the Mesh class\n   * @param {object} config - Configuration object for the mesh\n   * @param {number} [config.numElementsX] - Number of elements along the x-axis (required for geometry-based mesh)\n   * @param {number} [config.maxX] - Maximum x-coordinate of the mesh (required for geometry-based mesh)\n   * @param {number} [config.numElementsY=1] - Number of elements along the y-axis (for 1D meshes)\n   * @param {number} [config.maxY=0] - Maximum y-coordinate of the mesh (for 1D meshes)\n   * @param {string} [config.meshDimension='2D'] - The dimension of the mesh, either 1D or 2D\n   * @param {string} [config.elementOrder='linear'] - The order of elements, either 'linear' or 'quadratic'\n   * @param {object} [config.parsedMesh=null] - Optional pre-parsed mesh data\n   */\n  constructor({\n    numElementsX = null,\n    maxX = null,\n    numElementsY = null,\n    maxY = null,\n    meshDimension = null,\n    elementOrder = \"linear\",\n    parsedMesh = null,\n  }) {\n    this.numElementsX = numElementsX;\n    this.numElementsY = numElementsY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n    this.meshDimension = meshDimension;\n    this.elementOrder = elementOrder;\n    this.parsedMesh = parsedMesh;\n\n    this.boundaryElementsProcessed = false;\n\n    if (this.parsedMesh) {\n      basicLog(\"Using pre-parsed mesh from gmshReader data for mesh generation.\");\n      this.parseMeshFromGmsh();\n    }\n  }\n\n  /**\n   * Method to parse the mesh from the GMSH format to the FEAScript format\n   */\n  parseMeshFromGmsh() {\n    if (!this.parsedMesh.nodalNumbering) {\n      errorLog(\"No valid nodal numbering found in the parsed mesh.\");\n    }\n\n    if (\n      typeof this.parsedMesh.nodalNumbering === \"object\" &&\n      !Array.isArray(this.parsedMesh.nodalNumbering)\n    ) {\n      // Store the nodal numbering structure before converting\n      const quadElements = this.parsedMesh.nodalNumbering.quadElements || [];\n      const triangleElements = this.parsedMesh.nodalNumbering.triangleElements || [];\n\n      debugLog(\n        \"Initial parsed mesh nodal numbering from GMSH format: \" +\n          JSON.stringify(this.parsedMesh.nodalNumbering)\n      );\n\n      // Check if it has quadElements or triangleElements structure from gmshReader\n      if (this.parsedMesh.elementTypes[3] || this.parsedMesh.elementTypes[10]) {\n        // Map nodal numbering from GMSH format to FEAScript format for quad elements\n        const mappedNodalNumbering = [];\n\n        for (let elemIdx = 0; elemIdx < quadElements.length; elemIdx++) {\n          const gmshNodes = quadElements[elemIdx];\n          const feaScriptNodes = new Array(gmshNodes.length);\n\n          // Check for element type based on number of nodes\n          if (gmshNodes.length === 4) {\n            // Simple mapping for linear quad elements (4 nodes)\n            // GMSH:         FEAScript:\n            // 3 --- 2       1 --- 3\n            // |     |  -->  |     |\n            // 0 --- 1       0 --- 2\n\n            feaScriptNodes[0] = gmshNodes[0]; // 0 -> 0\n            feaScriptNodes[1] = gmshNodes[3]; // 3 -> 1\n            feaScriptNodes[2] = gmshNodes[1]; // 1 -> 2\n            feaScriptNodes[3] = gmshNodes[2]; // 2 -> 3\n          } else if (gmshNodes.length === 9) {\n            // Mapping for quadratic quad elements (9 nodes)\n            // GMSH:         FEAScript:\n            // 3--6--2       2--5--8\n            // |     |       |     |\n            // 7  8  5  -->  1  4  7\n            // |     |       |     |\n            // 0--4--1       0--3--6\n\n            feaScriptNodes[0] = gmshNodes[0]; // 0 -> 0\n            feaScriptNodes[1] = gmshNodes[7]; // 7 -> 1\n            feaScriptNodes[2] = gmshNodes[3]; // 3 -> 2\n            feaScriptNodes[3] = gmshNodes[4]; // 4 -> 3\n            feaScriptNodes[4] = gmshNodes[8]; // 8 -> 4\n            feaScriptNodes[5] = gmshNodes[6]; // 6 -> 5\n            feaScriptNodes[6] = gmshNodes[1]; // 1 -> 6\n            feaScriptNodes[7] = gmshNodes[5]; // 5 -> 7\n            feaScriptNodes[8] = gmshNodes[2]; // 2 -> 8\n          }\n\n          mappedNodalNumbering.push(feaScriptNodes);\n        }\n\n        this.parsedMesh.nodalNumbering = mappedNodalNumbering;\n      } else if (this.parsedMesh.elementTypes[2]) {\n        debugLog(\"Element type is neither triangle nor quad; mapping for this type is not implemented yet.\");\n      }\n\n      debugLog(\n        \"Nodal numbering after mapping from GMSH to FEAScript format: \" +\n          JSON.stringify(this.parsedMesh.nodalNumbering)\n      );\n\n      // Process boundary elements if they exist and if physical property mapping exists\n      if (this.parsedMesh.physicalPropMap && this.parsedMesh.boundaryElements) {\n        // Check if boundary elements need to be processed\n        if (\n          Array.isArray(this.parsedMesh.boundaryElements) &&\n          this.parsedMesh.boundaryElements.length > 0 &&\n          this.parsedMesh.boundaryElements[0] === undefined\n        ) {\n          // Create a new array without the empty first element\n          const fixedBoundaryElements = [];\n          for (let i = 1; i < this.parsedMesh.boundaryElements.length; i++) {\n            if (this.parsedMesh.boundaryElements[i]) {\n              fixedBoundaryElements.push(this.parsedMesh.boundaryElements[i]);\n            }\n          }\n          this.parsedMesh.boundaryElements = fixedBoundaryElements;\n        }\n\n        // If boundary node pairs exist but boundary elements haven't been processed\n        if (this.parsedMesh.boundaryNodePairs && !this.parsedMesh.boundaryElementsProcessed) {\n          // Reset boundary elements array\n          this.parsedMesh.boundaryElements = [];\n\n          // Process each physical property from the Gmsh file\n          this.parsedMesh.physicalPropMap.forEach((prop) => {\n            // Only process 1D physical entities (boundary lines)\n            if (prop.dimension === 1) {\n              // Get all node pairs for this boundary\n              const boundaryNodePairs = this.parsedMesh.boundaryNodePairs[prop.tag] || [];\n\n              if (boundaryNodePairs.length > 0) {\n                // Initialize array for this boundary tag\n                if (!this.parsedMesh.boundaryElements[prop.tag]) {\n                  this.parsedMesh.boundaryElements[prop.tag] = [];\n                }\n\n                // For each boundary line segment (defined by a pair of nodes)\n                boundaryNodePairs.forEach((nodesPair) => {\n                  const node1 = nodesPair[0]; // First node in the pair\n                  const node2 = nodesPair[1]; // Second node in the pair\n\n                  debugLog(\n                    `Processing boundary node pair: [${node1}, ${node2}] for boundary ${prop.tag} (${\n                      prop.name || \"unnamed\"\n                    })`\n                  );\n\n                  // Search through all elements to find which one contains both nodes\n                  let foundElement = false;\n\n                  // Loop through all elements in the mesh\n                  for (let elemIdx = 0; elemIdx < this.parsedMesh.nodalNumbering.length; elemIdx++) {\n                    const elemNodes = this.parsedMesh.nodalNumbering[elemIdx];\n\n                    // For linear quadrilateral linear elements (4 nodes)\n                    if (elemNodes.length === 4) {\n                      // Check if both boundary nodes are in this element\n                      if (elemNodes.includes(node1) && elemNodes.includes(node2)) {\n                        // Find which side of the element these nodes form\n                        let side;\n\n                        const node1Index = elemNodes.indexOf(node1);\n                        const node2Index = elemNodes.indexOf(node2);\n\n                        debugLog(\n                          `  Found element ${elemIdx} containing boundary nodes. Element nodes: [${elemNodes.join(\n                            \", \"\n                          )}]`\n                        );\n                        debugLog(\n                          `  Node ${node1} is at index ${node1Index}, Node ${node2} is at index ${node2Index} in the element`\n                        );\n\n                        // Based on FEAScript linear quadrilateral numbering:\n                        // 1 --- 3\n                        // |     |\n                        // 0 --- 2\n\n                        if (\n                          (node1Index === 0 && node2Index === 2) ||\n                          (node1Index === 2 && node2Index === 0)\n                        ) {\n                          side = 0; // Bottom side\n                          debugLog(`  These nodes form the BOTTOM side (${side}) of element ${elemIdx}`);\n                        } else if (\n                          (node1Index === 0 && node2Index === 1) ||\n                          (node1Index === 1 && node2Index === 0)\n                        ) {\n                          side = 1; // Left side\n                          debugLog(`  These nodes form the LEFT side (${side}) of element ${elemIdx}`);\n                        } else if (\n                          (node1Index === 1 && node2Index === 3) ||\n                          (node1Index === 3 && node2Index === 1)\n                        ) {\n                          side = 2; // Top side\n                          debugLog(`  These nodes form the TOP side (${side}) of element ${elemIdx}`);\n                        } else if (\n                          (node1Index === 2 && node2Index === 3) ||\n                          (node1Index === 3 && node2Index === 2)\n                        ) {\n                          side = 3; // Right side\n                          debugLog(`  These nodes form the RIGHT side (${side}) of element ${elemIdx}`);\n                        }\n\n                        // Add the element and side to the boundary elements array\n                        this.parsedMesh.boundaryElements[prop.tag].push([elemIdx, side]);\n                        debugLog(\n                          `  Added element-side pair [${elemIdx}, ${side}] to boundary tag ${prop.tag}`\n                        );\n                        foundElement = true;\n                        break;\n                      }\n                    } else if (elemNodes.length === 9) {\n                      // For quadratic quadrilateral elements (9 nodes)\n                      // Check if both boundary nodes are in this element\n                      if (elemNodes.includes(node1) && elemNodes.includes(node2)) {\n                        // Find which side of the element these nodes form\n                        let side;\n\n                        const node1Index = elemNodes.indexOf(node1);\n                        const node2Index = elemNodes.indexOf(node2);\n\n                        debugLog(\n                          `  Found element ${elemIdx} containing boundary nodes. Element nodes: [${elemNodes.join(\n                            \", \"\n                          )}]`\n                        );\n                        debugLog(\n                          `  Node ${node1} is at index ${node1Index}, Node ${node2} is at index ${node2Index} in the element`\n                        );\n\n                        // Based on FEAScript quadratic quadrilateral numbering:\n                        // 2--5--8\n                        // |     |\n                        // 1  4  7\n                        // |     |\n                        // 0--3--6\n\n                        // TODO: Transform into dictionaries for better readability\n                        if (\n                          (node1Index === 0 && node2Index === 6) ||\n                          (node1Index === 6 && node2Index === 0) ||\n                          (node1Index === 0 && node2Index === 3) ||\n                          (node1Index === 3 && node2Index === 0) ||\n                          (node1Index === 3 && node2Index === 6) ||\n                          (node1Index === 6 && node2Index === 3)\n                        ) {\n                          side = 0; // Bottom side (nodes 0, 3, 6)\n                          debugLog(`  These nodes form the BOTTOM side (${side}) of element ${elemIdx}`);\n                        } else if (\n                          (node1Index === 0 && node2Index === 2) ||\n                          (node1Index === 2 && node2Index === 0) ||\n                          (node1Index === 0 && node2Index === 1) ||\n                          (node1Index === 1 && node2Index === 0) ||\n                          (node1Index === 1 && node2Index === 2) ||\n                          (node1Index === 2 && node2Index === 1)\n                        ) {\n                          side = 1; // Left side (nodes 0, 1, 2)\n                          debugLog(`  These nodes form the LEFT side (${side}) of element ${elemIdx}`);\n                        } else if (\n                          (node1Index === 2 && node2Index === 8) ||\n                          (node1Index === 8 && node2Index === 2) ||\n                          (node1Index === 2 && node2Index === 5) ||\n                          (node1Index === 5 && node2Index === 2) ||\n                          (node1Index === 5 && node2Index === 8) ||\n                          (node1Index === 8 && node2Index === 5)\n                        ) {\n                          side = 2; // Top side (nodes 2, 5, 8)\n                          debugLog(`  These nodes form the TOP side (${side}) of element ${elemIdx}`);\n                        } else if (\n                          (node1Index === 6 && node2Index === 8) ||\n                          (node1Index === 8 && node2Index === 6) ||\n                          (node1Index === 6 && node2Index === 7) ||\n                          (node1Index === 7 && node2Index === 6) ||\n                          (node1Index === 7 && node2Index === 8) ||\n                          (node1Index === 8 && node2Index === 7)\n                        ) {\n                          side = 3; // Right side (nodes 6, 7, 8)\n                          debugLog(`  These nodes form the RIGHT side (${side}) of element ${elemIdx}`);\n                        }\n\n                        // Add the element and side to the boundary elements array\n                        this.parsedMesh.boundaryElements[prop.tag].push([elemIdx, side]);\n                        debugLog(\n                          `  Added element-side pair [${elemIdx}, ${side}] to boundary tag ${prop.tag}`\n                        );\n                        foundElement = true;\n                        break;\n                      }\n                    }\n                  }\n\n                  if (!foundElement) {\n                    errorLog(\n                      `Could not find element containing boundary nodes ${node1} and ${node2}. Boundary may be incomplete.`\n                    );\n                  }\n                });\n              }\n            }\n          });\n\n          // Mark as processed\n          this.boundaryElementsProcessed = true;\n\n          // Fix boundary elements array - remove undefined entries\n          if (\n            this.parsedMesh.boundaryElements.length > 0 &&\n            this.parsedMesh.boundaryElements[0] === undefined\n          ) {\n            const fixedBoundaryElements = [];\n            for (let i = 1; i < this.parsedMesh.boundaryElements.length; i++) {\n              if (this.parsedMesh.boundaryElements[i]) {\n                fixedBoundaryElements.push(this.parsedMesh.boundaryElements[i]);\n              }\n            }\n            this.parsedMesh.boundaryElements = fixedBoundaryElements;\n          }\n        }\n      }\n    }\n\n    return this.parsedMesh;\n  }\n}\n\nexport class Mesh1D extends Mesh {\n  /**\n   * Constructor to initialize the 1D mesh\n   * @param {object} config - Configuration object for the 1D mesh\n   * @param {number} [config.numElementsX] - Number of elements along the x-axis (required for geometry-based mesh)\n   * @param {number} [config.maxX] - Maximum x-coordinate of the mesh (required for geometry-based mesh)\n   * @param {string} [config.elementOrder='linear'] - The order of elements, either 'linear' or 'quadratic'\n   * @param {object} [config.parsedMesh=null] - Optional pre-parsed mesh data\n   */\n  constructor({ numElementsX = null, maxX = null, elementOrder = \"linear\", parsedMesh = null }) {\n    super({\n      numElementsX,\n      maxX,\n      numElementsY: 1,\n      maxY: 0,\n      meshDimension: \"1D\",\n      elementOrder,\n      parsedMesh,\n    });\n\n    if (this.numElementsX === null || this.maxX === null) {\n      errorLog(\"numElementsX and maxX are required parameters when generating a 1D mesh from geometry\");\n    }\n  }\n\n  generateMesh() {\n    let nodesXCoordinates = [];\n    let nodesYCoordinates = [];\n    const xStart = 0;\n    let totalNodesX, deltaX;\n\n    if (this.elementOrder === \"linear\") {\n      totalNodesX = this.numElementsX + 1;\n      deltaX = (this.maxX - xStart) / this.numElementsX;\n\n      nodesXCoordinates[0] = xStart;\n      for (let nodeIndex = 1; nodeIndex < totalNodesX; nodeIndex++) {\n        nodesXCoordinates[nodeIndex] = nodesXCoordinates[nodeIndex - 1] + deltaX;\n      }\n    } else if (this.elementOrder === \"quadratic\") {\n      totalNodesX = 2 * this.numElementsX + 1;\n      deltaX = (this.maxX - xStart) / this.numElementsX;\n\n      nodesXCoordinates[0] = xStart;\n      for (let nodeIndex = 1; nodeIndex < totalNodesX; nodeIndex++) {\n        nodesXCoordinates[nodeIndex] = nodesXCoordinates[nodeIndex - 1] + deltaX / 2;\n      }\n    }\n    // Generate nodal numbering (NOP) array\n    const nodalNumbering = this.generate1DNodalNumbering(this.numElementsX, totalNodesX, this.elementOrder);\n    // Find boundary elements\n    const boundaryElements = this.findBoundaryElements();\n\n    debugLog(\"Generated node X coordinates: \" + JSON.stringify(nodesXCoordinates));\n\n    // Return x coordinates of nodes, total nodes, NOP array, and boundary elements\n    return {\n      nodesXCoordinates,\n      totalNodesX,\n      nodalNumbering,\n      boundaryElements,\n    };\n  }\n\n  /**\n   * Function to generate the nodal numbering (NOP) array for a structured mesh\n   * This array represents the connectivity between elements and their corresponding nodes\n   * @param {number} numElementsX - Number of elements along the x-axis\n   * @param {number} totalNodesX - Total number of nodes along the x-axis\n   * @param {string} elementOrder - The order of elements, either 'linear' or 'quadratic'\n   * @returns {array} NOP - A two-dimensional array which represents the element-to-node connectivity for the entire mesh\n   */\n  generate1DNodalNumbering(numElementsX, totalNodesX, elementOrder) {\n    // TODO: The totalNodesX is not used in the original function. Verify if\n    // there is a multiple calculation on the totalNodes.\n\n    let elementIndex = 0;\n    let nop = [];\n\n    if (elementOrder === \"linear\") {\n      /**\n       * Linear 1D elements with the following nodes representation:\n       *\n       *   1 --- 2\n       *\n       */\n      for (let elementIndex = 0; elementIndex < numElementsX; elementIndex++) {\n        nop[elementIndex] = [];\n        for (let nodeIndex = 1; nodeIndex <= 2; nodeIndex++) {\n          nop[elementIndex][nodeIndex - 1] = elementIndex + nodeIndex;\n        }\n      }\n    } else if (elementOrder === \"quadratic\") {\n      /**\n       * Quadratic 1D elements with the following nodes representation:\n       *\n       *   1--2--3\n       *\n       */\n      let columnCounter = 0;\n      for (let elementIndex = 0; elementIndex < numElementsX; elementIndex++) {\n        nop[elementIndex] = [];\n        for (let nodeIndex = 1; nodeIndex <= 3; nodeIndex++) {\n          nop[elementIndex][nodeIndex - 1] = elementIndex + nodeIndex + columnCounter;\n        }\n        columnCounter += 1;\n      }\n    }\n\n    return nop;\n  }\n\n  /**\n   * Function to find the elements that belong to each boundary of a domain\n   * @returns {array} An array containing arrays of elements and their adjacent boundary side for each boundary\n   * Each element in the array is of the form [elementIndex, side], where 'side' indicates which side\n   * of the reference element is in contact with the physical boundary:\n   *\n   * For 1D domains (line segments):\n   * 0 - Left node of reference element (maps to physical left endpoint)\n   * 1 - Right node of reference element (maps to physical right endpoint)\n   */\n  findBoundaryElements() {\n    const boundaryElements = [];\n    const maxSides = 2; // For 1D, we only have two sides (left and right)\n    for (let sideIndex = 0; sideIndex < maxSides; sideIndex++) {\n      boundaryElements.push([]);\n    }\n\n    // Left boundary (element 0, side 0)\n    boundaryElements[0].push([0, 0]);\n\n    // Right boundary (last element, side 1)\n    boundaryElements[1].push([this.numElementsX - 1, 1]);\n\n    debugLog(\"Identified boundary elements by side: \" + JSON.stringify(boundaryElements));\n    this.boundaryElementsProcessed = true;\n    return boundaryElements;\n  }\n}\n\nexport class Mesh2D extends Mesh {\n  /**\n   * Constructor to initialize the 2D mesh\n   * @param {object} config - Configuration object for the 2D mesh\n   * @param {number} [config.numElementsX] - Number of elements along the x-axis (required for geometry-based mesh)\n   * @param {number} [config.maxX] - Maximum x-coordinate of the mesh (required for geometry-based mesh)\n   * @param {number} [config.numElementsY] - Number of elements along the y-axis (required for geometry-based mesh)\n   * @param {number} [config.maxY] - Maximum y-coordinate of the mesh (required for geometry-based mesh)\n   * @param {string} [config.elementOrder='linear'] - The order of elements, either 'linear' or 'quadratic'\n   * @param {object} [config.parsedMesh=null] - Optional pre-parsed mesh data\n   */\n  constructor({\n    numElementsX = null,\n    maxX = null,\n    numElementsY = null,\n    maxY = null,\n    elementOrder = \"linear\",\n    parsedMesh = null,\n  }) {\n    super({\n      numElementsX,\n      maxX,\n      numElementsY,\n      maxY,\n      meshDimension: \"2D\",\n      elementOrder,\n      parsedMesh,\n    });\n\n    if (\n      this.numElementsX === null ||\n      this.maxX === null ||\n      this.numElementsY === null ||\n      this.maxY === null\n    ) {\n      errorLog(\n        \"numElementsX, maxX, numElementsY, and maxY are required parameters when generating a 2D mesh from geometry\"\n      );\n    }\n  }\n\n  generateMesh() {\n    let nodesXCoordinates = [];\n    let nodesYCoordinates = [];\n    const xStart = 0;\n    const yStart = 0;\n    let totalNodesX, totalNodesY, deltaX, deltaY;\n\n    if (this.elementOrder === \"linear\") {\n      totalNodesX = this.numElementsX + 1;\n      totalNodesY = this.numElementsY + 1;\n      deltaX = (this.maxX - xStart) / this.numElementsX;\n      deltaY = (this.maxY - yStart) / this.numElementsY;\n\n      nodesXCoordinates[0] = xStart;\n      nodesYCoordinates[0] = yStart;\n      for (let nodeIndexY = 1; nodeIndexY < totalNodesY; nodeIndexY++) {\n        nodesXCoordinates[nodeIndexY] = nodesXCoordinates[0];\n        nodesYCoordinates[nodeIndexY] = nodesYCoordinates[0] + nodeIndexY * deltaY;\n      }\n      for (let nodeIndexX = 1; nodeIndexX < totalNodesX; nodeIndexX++) {\n        const nnode = nodeIndexX * totalNodesY;\n        nodesXCoordinates[nnode] = nodesXCoordinates[0] + nodeIndexX * deltaX;\n        nodesYCoordinates[nnode] = nodesYCoordinates[0];\n        for (let nodeIndexY = 1; nodeIndexY < totalNodesY; nodeIndexY++) {\n          nodesXCoordinates[nnode + nodeIndexY] = nodesXCoordinates[nnode];\n          nodesYCoordinates[nnode + nodeIndexY] = nodesYCoordinates[nnode] + nodeIndexY * deltaY;\n        }\n      }\n    } else if (this.elementOrder === \"quadratic\") {\n      totalNodesX = 2 * this.numElementsX + 1;\n      totalNodesY = 2 * this.numElementsY + 1;\n      deltaX = (this.maxX - xStart) / this.numElementsX;\n      deltaY = (this.maxY - yStart) / this.numElementsY;\n\n      nodesXCoordinates[0] = xStart;\n      nodesYCoordinates[0] = yStart;\n      for (let nodeIndexY = 1; nodeIndexY < totalNodesY; nodeIndexY++) {\n        nodesXCoordinates[nodeIndexY] = nodesXCoordinates[0];\n        nodesYCoordinates[nodeIndexY] = nodesYCoordinates[0] + (nodeIndexY * deltaY) / 2;\n      }\n      for (let nodeIndexX = 1; nodeIndexX < totalNodesX; nodeIndexX++) {\n        const nnode = nodeIndexX * totalNodesY;\n        nodesXCoordinates[nnode] = nodesXCoordinates[0] + (nodeIndexX * deltaX) / 2;\n        nodesYCoordinates[nnode] = nodesYCoordinates[0];\n        for (let nodeIndexY = 1; nodeIndexY < totalNodesY; nodeIndexY++) {\n          nodesXCoordinates[nnode + nodeIndexY] = nodesXCoordinates[nnode];\n          nodesYCoordinates[nnode + nodeIndexY] = nodesYCoordinates[nnode] + (nodeIndexY * deltaY) / 2;\n        }\n      }\n    }\n\n    // Generate nodal numbering (NOP) array\n    const nodalNumbering = this.generate2DNodalNumbering(\n      this.numElementsX,\n      this.numElementsY,\n      totalNodesY,\n      this.elementOrder\n    );\n    \n    // Find boundary elements\n    const boundaryElements = this.findBoundaryElements();\n\n    debugLog(\"Generated node X coordinates: \" + JSON.stringify(nodesXCoordinates));\n    debugLog(\"Generated node Y coordinates: \" + JSON.stringify(nodesYCoordinates));\n\n    // Return statement\n    return {\n      nodesXCoordinates,\n      nodesYCoordinates,\n      totalNodesX,\n      totalNodesY,\n      nodalNumbering,\n      boundaryElements,\n    };\n  }\n\n  /**\n   * Function to generate the nodal numbering (NOP) array for a structured mesh\n   * This array represents the connectivity between elements and their corresponding nodes\n   * @param {number} numElementsX - Number of elements along the x-axis\n   * @param {number} [numElementsY] - Number of elements along the y-axis (optional for 1D)\n   * @param {number} totalNodesX - Total number of nodes along the x-axis\n   * @param {number} [totalNodesY] - Total number of nodes along the y-axis (optional for 1D)\n   * @param {string} elementOrder - The order of elements, either 'linear' or 'quadratic'\n   * @returns {array} NOP - A two-dimensional array which represents the element-to-node connectivity for the entire mesh\n   */\n  generate2DNodalNumbering(numElementsX, numElementsY, totalNodesY, elementOrder) {\n    let elementIndex = 0;\n    let nop = [];\n\n    if (elementOrder === \"linear\") {\n      /**\n       * Linear rectangular elements with the following nodes representation:\n       *\n       *   1 --- 3\n       *   |     |\n       *   0 --- 2\n       *\n       */\n      let rowCounter = 0;\n      let columnCounter = 2;\n      for (let elementIndex = 0; elementIndex < numElementsX * numElementsY; elementIndex++) {\n        rowCounter += 1;\n        nop[elementIndex] = [];\n        nop[elementIndex][0] = elementIndex + columnCounter - 1;\n        nop[elementIndex][1] = elementIndex + columnCounter;\n        nop[elementIndex][2] = elementIndex + columnCounter + numElementsY;\n        nop[elementIndex][3] = elementIndex + columnCounter + numElementsY + 1;\n        if (rowCounter === numElementsY) {\n          columnCounter += 1;\n          rowCounter = 0;\n        }\n      }\n    } else if (elementOrder === \"quadratic\") {\n      /**\n       * Quadratic rectangular elements with the following nodes representation:\n       *\n       *   2--5--8\n       *   |     |\n       *   1  4  7\n       *   |     |\n       *   0--3--6\n       *\n       */\n      for (let elementIndexX = 1; elementIndexX <= numElementsX; elementIndexX++) {\n        for (let elementIndexY = 1; elementIndexY <= numElementsY; elementIndexY++) {\n          nop[elementIndex] = [];\n          for (let nodeIndex1 = 1; nodeIndex1 <= 3; nodeIndex1++) {\n            let nodeIndex2 = 3 * nodeIndex1 - 2;\n            nop[elementIndex][nodeIndex2 - 1] =\n              totalNodesY * (2 * elementIndexX + nodeIndex1 - 3) + 2 * elementIndexY - 1;\n            nop[elementIndex][nodeIndex2] = nop[elementIndex][nodeIndex2 - 1] + 1;\n            nop[elementIndex][nodeIndex2 + 1] = nop[elementIndex][nodeIndex2 - 1] + 2;\n          }\n          elementIndex = elementIndex + 1;\n        }\n      }\n    }\n\n    return nop;\n  }\n\n  /**\n   * Function to find the elements that belong to each boundary of a domain\n   * @returns {array} An array containing arrays of elements and their adjacent boundary side for each boundary\n   * Each element in the array is of the form [elementIndex, side], where 'side' indicates which side\n   * of the reference element is in contact with the physical boundary:\n   *\n   * For 2D domains (rectangular):\n   * 0 - Bottom side of reference element (maps to physical bottom boundary)\n   * 1 - Left side of reference element (maps to physical left boundary)\n   * 2 - Top side of reference element (maps to physical top boundary)\n   * 3 - Right side of reference element (maps to physical right boundary)\n   */\n  findBoundaryElements() {\n    const boundaryElements = [];\n    const maxSides = 4; // For 2D, we have four sides (left, right, bottom, top)\n\n    for (let sideIndex = 0; sideIndex < maxSides; sideIndex++) {\n      boundaryElements.push([]);\n    }\n\n    // TODO: Why to loop through all elements? Is it not better to loop over only the\n    // elements that are on the boundary? eg: [0, this.numElementsX - 1] on x and\n    // [0, this.numElementsY - 1] on y\n    for (let elementIndexX = 0; elementIndexX < this.numElementsX; elementIndexX++) {\n      for (let elementIndexY = 0; elementIndexY < this.numElementsY; elementIndexY++) {\n        const elementIndex = elementIndexX * this.numElementsY + elementIndexY;\n\n        // Bottom boundary\n        if (elementIndexY === 0) {\n          boundaryElements[0].push([elementIndex, 0]);\n        }\n\n        // Left boundary\n        if (elementIndexX === 0) {\n          boundaryElements[1].push([elementIndex, 1]);\n        }\n\n        // Top boundary\n        if (elementIndexY === this.numElementsY - 1) {\n          boundaryElements[2].push([elementIndex, 2]);\n        }\n\n        // Right boundary\n        if (elementIndexX === this.numElementsX - 1) {\n          boundaryElements[3].push([elementIndex, 3]);\n        }\n      }\n    }\n\n    debugLog(\"Identified boundary elements by side: \" + JSON.stringify(boundaryElements));\n    this.boundaryElementsProcessed = true;\n    return boundaryElements;\n  }\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n/**\n * Class to handle numerical integration using Gauss quadrature\n */\nexport class NumericalIntegration {\n  /**\n   * Constructor to initialize the NumericalIntegration class\n   * @param {string} meshDimension - The dimension of the mesh\n   * @param {string} elementOrder - The order of elements\n   */\n  constructor({ meshDimension, elementOrder }) {\n    this.meshDimension = meshDimension;\n    this.elementOrder = elementOrder;\n  }\n\n  /**\n   * Function to return Gauss points and weights based on element configuration\n   * @returns {object} An object containing:\n   *  - gaussPoints: Array of Gauss points\n   *  - gaussWeights: Array of Gauss weights\n   */\n  getGaussPointsAndWeights() {\n    let gaussPoints = []; // Gauss points\n    let gaussWeights = []; // Gauss weights\n\n    if (this.elementOrder === \"linear\") {\n      // For linear elements, use 1-point Gauss quadrature\n      gaussPoints[0] = 0.5;\n      gaussWeights[0] = 1;\n    } else if (this.elementOrder === \"quadratic\") {\n      // For quadratic elements, use 3-point Gauss quadrature\n      gaussPoints[0] = (1 - Math.sqrt(3 / 5)) / 2;\n      gaussPoints[1] = 0.5;\n      gaussPoints[2] = (1 + Math.sqrt(3 / 5)) / 2;\n      gaussWeights[0] = 5 / 18;\n      gaussWeights[1] = 8 / 18;\n      gaussWeights[2] = 5 / 18;\n    }\n\n    return { gaussPoints, gaussWeights };\n  }\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n// Internal imports\n\nimport { GenericBoundaryConditions } from \"./genericBoundaryConditionsScript.js\";\nimport { BasisFunctions } from \"../mesh/basisFunctionsScript.js\";\nimport { Mesh1D, Mesh2D } from \"../mesh/meshGenerationScript.js\";\nimport { NumericalIntegration } from \"../methods/numericalIntegrationScript.js\";\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Function to assemble the front propagation matrix\n * @param {object} meshConfig - Object containing computational mesh details\n * @param {object} boundaryConditions - Object containing boundary conditions for the finite element analysis\n * @param {array} solutionVector - The solution vector for non-linear equations\n * @param {number} eikonalActivationFlag - Activation parameter for the eikonal equation (ranges from 0 to 1)\n * @returns {object} An object containing:\n *  - jacobianMatrix: The assembled Jacobian matrix\n *  - residualVector: The assembled residual vector\n *  - nodesCoordinates: Object containing x and y coordinates of nodes\n */\nexport function assembleFrontPropagationMat(\n  meshConfig,\n  boundaryConditions,\n  solutionVector,\n  eikonalActivationFlag\n) {\n  basicLog(\"Starting front propagation matrix assembly...\");\n\n  const baseEikonalViscousTerm = 1e-2; // Base viscous term that remains when eikonal equation is fully activated\n  let eikonalViscousTerm = 1 - eikonalActivationFlag + baseEikonalViscousTerm; // Viscous term for the front propagation (eikonal) equation\n  basicLog(`eikonalViscousTerm: ${eikonalViscousTerm}`);\n  basicLog(`eikonalActivationFlag: ${eikonalActivationFlag}`);\n\n  // Extract mesh details from the configuration object\n  const {\n    meshDimension, // The dimension of the mesh\n    numElementsX, // Number of elements in x-direction\n    numElementsY, // Number of elements in y-direction (only for 2D)\n    maxX, // Max x-coordinate (m) of the domain\n    maxY, // Max y-coordinate (m) of the domain (only for 2D)\n    elementOrder, // The order of elements\n    parsedMesh, // The pre-parsed mesh data (if available)\n  } = meshConfig;\n\n  // Create a new instance of the Mesh class\n  // TODO: The mesh generation step should be moved outside of the assembleFrontPropagationMat function so that not performed in every Newton-Raphson iteration\n  debugLog(\"Generating mesh...\");\n  let mesh;\n  if (meshDimension === \"1D\") {\n    mesh = new Mesh1D({ numElementsX, maxX, elementOrder, parsedMesh });\n  } else if (meshDimension === \"2D\") {\n    mesh = new Mesh2D({ numElementsX, maxX, numElementsY, maxY, elementOrder, parsedMesh });\n  } else {\n    errorLog(\"Mesh dimension must be either '1D' or '2D'.\");\n  }\n\n  // Use the parsed mesh in case it was already passed with Gmsh format\n  const nodesCoordinatesAndNumbering = mesh.boundaryElementsProcessed ? mesh.parsedMesh : mesh.generateMesh();\n\n  // Extract nodes coordinates and nodal numbering (NOP) from the mesh data\n  let nodesXCoordinates = nodesCoordinatesAndNumbering.nodesXCoordinates;\n  let nodesYCoordinates = nodesCoordinatesAndNumbering.nodesYCoordinates;\n  let totalNodesX = nodesCoordinatesAndNumbering.totalNodesX;\n  let totalNodesY = nodesCoordinatesAndNumbering.totalNodesY;\n  let nop = nodesCoordinatesAndNumbering.nodalNumbering;\n  let boundaryElements = nodesCoordinatesAndNumbering.boundaryElements;\n\n  // Check the mesh type\n  const isParsedMesh = parsedMesh !== undefined && parsedMesh !== null;\n\n  // Calculate totalElements and totalNodes based on mesh type\n  let totalElements, totalNodes;\n\n  if (isParsedMesh) {\n    totalElements = nop.length; // Number of elements is the length of the nodal numbering array\n    totalNodes = nodesXCoordinates.length; // Number of nodes is the length of the coordinates array\n\n    // Debug log for mesh size\n    debugLog(`Using parsed mesh with ${totalElements} elements and ${totalNodes} nodes`);\n  } else {\n    // For structured mesh, calculate based on dimensions\n    totalElements = numElementsX * (meshDimension === \"2D\" ? numElementsY : 1);\n    totalNodes = totalNodesX * (meshDimension === \"2D\" ? totalNodesY : 1);\n    // Debug log for mesh size\n    debugLog(`Using mesh generated from geometry with ${totalElements} elements and ${totalNodes} nodes`);\n  }\n\n  // Initialize variables for matrix assembly\n  let localToGlobalMap = []; // Maps local element node indices to global mesh node indices\n  let gaussPoints = []; // Gauss points\n  let gaussWeights = []; // Gauss weights\n  let basisFunction = []; // Basis functions\n  let basisFunctionDerivKsi = []; // Derivatives of basis functions with respect to ksi\n  let basisFunctionDerivEta = []; // Derivatives of basis functions with respect to eta (only for 2D)\n  let basisFunctionDerivX = []; // The x-derivative of the basis function\n  let basisFunctionDerivY = []; // The y-derivative of the basis function (only for 2D)\n  let residualVector = []; // Galerkin residuals\n  let jacobianMatrix = []; // Jacobian matrix\n  let xCoordinates; // x-coordinate (physical coordinates)\n  let yCoordinates; // y-coordinate (physical coordinates) (only for 2D)\n  let ksiDerivX; // ksi-derivative of xCoordinates\n  let etaDerivX; // eta-derivative of xCoordinates (ksi and eta are natural coordinates that vary within a reference element) (only for 2D)\n  let ksiDerivY; // ksi-derivative of yCoordinates (only for 2D)\n  let etaDerivY; // eta-derivative of yCoordinates (only for 2D)\n  let detJacobian; // The Jacobian of the isoparametric mapping\n  let solutionDerivX; // The x-derivative of the solution\n  let solutionDerivY; // The y-derivative of the solution\n\n  // Initialize jacobianMatrix and residualVector arrays\n  for (let nodeIndex = 0; nodeIndex < totalNodes; nodeIndex++) {\n    residualVector[nodeIndex] = 0;\n    jacobianMatrix.push([]);\n    for (let colIndex = 0; colIndex < totalNodes; colIndex++) {\n      jacobianMatrix[nodeIndex][colIndex] = 0;\n    }\n  }\n\n  // Initialize the BasisFunctions class\n  const basisFunctions = new BasisFunctions({\n    meshDimension,\n    elementOrder,\n  });\n\n  // Initialize the NumericalIntegration class\n  const numericalIntegration = new NumericalIntegration({\n    meshDimension,\n    elementOrder,\n  });\n\n  // Calculate Gauss points and weights\n  let gaussPointsAndWeights = numericalIntegration.getGaussPointsAndWeights();\n  gaussPoints = gaussPointsAndWeights.gaussPoints;\n  gaussWeights = gaussPointsAndWeights.gaussWeights;\n\n  // Determine the number of nodes in the reference element based on the first element in the nop array\n  const numNodes = nop[0].length;\n\n  // Matrix assembly\n  for (let elementIndex = 0; elementIndex < totalElements; elementIndex++) {\n    for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n      // Subtract 1 from nop in order to start numbering from 0\n      localToGlobalMap[localNodeIndex] = nop[elementIndex][localNodeIndex] - 1;\n    }\n\n    // Loop over Gauss points\n    for (let gaussPointIndex1 = 0; gaussPointIndex1 < gaussPoints.length; gaussPointIndex1++) {\n      // 1D front propagation (eikonal) equation\n      if (meshDimension === \"1D\") {\n        let basisFunctionsAndDerivatives = basisFunctions.getBasisFunctions(gaussPoints[gaussPointIndex1]);\n        basisFunction = basisFunctionsAndDerivatives.basisFunction;\n        basisFunctionDerivKsi = basisFunctionsAndDerivatives.basisFunctionDerivKsi;\n        xCoordinates = 0;\n        ksiDerivX = 0;\n        detJacobian = 0;\n\n        // Isoparametric mapping\n        for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n          xCoordinates += nodesXCoordinates[localToGlobalMap[localNodeIndex]] * basisFunction[localNodeIndex];\n          ksiDerivX +=\n            nodesXCoordinates[localToGlobalMap[localNodeIndex]] * basisFunctionDerivKsi[localNodeIndex];\n          detJacobian = ksiDerivX;\n        }\n\n        // Compute x-derivative of basis functions\n        for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n          basisFunctionDerivX[localNodeIndex] = basisFunctionDerivKsi[localNodeIndex] / detJacobian; // The x-derivative of the n basis function\n        }\n\n        // Computation of Galerkin's residuals and Jacobian matrix\n        for (let localNodeIndex1 = 0; localNodeIndex1 < numNodes; localNodeIndex1++) {\n          let localToGlobalMap1 = localToGlobalMap[localNodeIndex1];\n          // residualVector\n          // To perform residualVector calculation here\n\n          for (let localNodeIndex2 = 0; localNodeIndex2 < numNodes; localNodeIndex2++) {\n            let localToGlobalMap2 = localToGlobalMap[localNodeIndex2];\n            // jacobianMatrix\n            // To perform jacobianMatrix calculation here\n          }\n        }\n        // 2D front propagation (eikonal) equation\n      } else if (meshDimension === \"2D\") {\n        for (let gaussPointIndex2 = 0; gaussPointIndex2 < gaussPoints.length; gaussPointIndex2++) {\n          // Initialise variables for isoparametric mapping\n          let basisFunctionsAndDerivatives = basisFunctions.getBasisFunctions(\n            gaussPoints[gaussPointIndex1],\n            gaussPoints[gaussPointIndex2]\n          );\n          basisFunction = basisFunctionsAndDerivatives.basisFunction;\n          basisFunctionDerivKsi = basisFunctionsAndDerivatives.basisFunctionDerivKsi;\n          basisFunctionDerivEta = basisFunctionsAndDerivatives.basisFunctionDerivEta;\n          xCoordinates = 0;\n          yCoordinates = 0;\n          ksiDerivX = 0;\n          etaDerivX = 0;\n          ksiDerivY = 0;\n          etaDerivY = 0;\n          solutionDerivX = 0;\n          solutionDerivY = 0;\n\n          // Isoparametric mapping\n          for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n            xCoordinates +=\n              nodesXCoordinates[localToGlobalMap[localNodeIndex]] * basisFunction[localNodeIndex];\n            yCoordinates +=\n              nodesYCoordinates[localToGlobalMap[localNodeIndex]] * basisFunction[localNodeIndex];\n            ksiDerivX +=\n              nodesXCoordinates[localToGlobalMap[localNodeIndex]] * basisFunctionDerivKsi[localNodeIndex];\n            etaDerivX +=\n              nodesXCoordinates[localToGlobalMap[localNodeIndex]] * basisFunctionDerivEta[localNodeIndex];\n            ksiDerivY +=\n              nodesYCoordinates[localToGlobalMap[localNodeIndex]] * basisFunctionDerivKsi[localNodeIndex];\n            etaDerivY +=\n              nodesYCoordinates[localToGlobalMap[localNodeIndex]] * basisFunctionDerivEta[localNodeIndex];\n          }\n          detJacobian = ksiDerivX * etaDerivY - etaDerivX * ksiDerivY;\n\n          // Compute x & y-derivatives of basis functions and x & y-derivatives of the solution\n          for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n            // The x-derivative of the n basis function\n            basisFunctionDerivX[localNodeIndex] =\n              (etaDerivY * basisFunctionDerivKsi[localNodeIndex] -\n                ksiDerivY * basisFunctionDerivEta[localNodeIndex]) /\n              detJacobian;\n            // The y-derivative of the n basis function\n            basisFunctionDerivY[localNodeIndex] =\n              (ksiDerivX * basisFunctionDerivEta[localNodeIndex] -\n                etaDerivX * basisFunctionDerivKsi[localNodeIndex]) /\n              detJacobian;\n            // The x-derivative of the solution\n            solutionDerivX +=\n              solutionVector[localToGlobalMap[localNodeIndex]] * basisFunctionDerivX[localNodeIndex];\n            // The y-derivative of the solution\n            solutionDerivY +=\n              solutionVector[localToGlobalMap[localNodeIndex]] * basisFunctionDerivY[localNodeIndex];\n          }\n\n          // Computation of Galerkin's residuals and Jacobian matrix\n          for (let localNodeIndex1 = 0; localNodeIndex1 < numNodes; localNodeIndex1++) {\n            let localToGlobalMap1 = localToGlobalMap[localNodeIndex1];\n            // residualVector - Viscous term: Add diffusion contribution to stabilize the solution\n            residualVector[localToGlobalMap1] +=\n              eikonalViscousTerm *\n                gaussWeights[gaussPointIndex1] *\n                gaussWeights[gaussPointIndex2] *\n                detJacobian *\n                basisFunctionDerivX[localNodeIndex1] *\n                solutionDerivX +\n              eikonalViscousTerm *\n                gaussWeights[gaussPointIndex1] *\n                gaussWeights[gaussPointIndex2] *\n                detJacobian *\n                basisFunctionDerivY[localNodeIndex1] *\n                solutionDerivY;\n            // residualVector - Eikonal term: Add the eikonal equation contribution\n            if (eikonalActivationFlag !== 0) {\n              residualVector[localToGlobalMap1] +=\n                eikonalActivationFlag *\n                (gaussWeights[gaussPointIndex1] *\n                  gaussWeights[gaussPointIndex2] *\n                  detJacobian *\n                  basisFunction[localNodeIndex1] *\n                  Math.sqrt(solutionDerivX ** 2 + solutionDerivY ** 2) -\n                  gaussWeights[gaussPointIndex1] *\n                    gaussWeights[gaussPointIndex2] *\n                    detJacobian *\n                    basisFunction[localNodeIndex1]);\n            }\n            for (let localNodeIndex2 = 0; localNodeIndex2 < numNodes; localNodeIndex2++) {\n              let localToGlobalMap2 = localToGlobalMap[localNodeIndex2];\n              // jacobianMatrix - Viscous term: Add the Jacobian contribution from the diffusion term\n              jacobianMatrix[localToGlobalMap1][localToGlobalMap2] +=\n                -eikonalViscousTerm *\n                gaussWeights[gaussPointIndex1] *\n                gaussWeights[gaussPointIndex2] *\n                detJacobian *\n                (basisFunctionDerivX[localNodeIndex1] * basisFunctionDerivX[localNodeIndex2] +\n                  basisFunctionDerivY[localNodeIndex1] * basisFunctionDerivY[localNodeIndex2]);\n              // jacobianMatrix - Eikonal term: Add the Jacobian contribution from the eikonal equation\n              if (eikonalActivationFlag !== 0) {\n                jacobianMatrix[localToGlobalMap1][localToGlobalMap2] +=\n                  eikonalActivationFlag *\n                  (-(\n                    (detJacobian *\n                      solutionDerivX *\n                      basisFunction[localNodeIndex1] *\n                      gaussWeights[gaussPointIndex1] *\n                      gaussWeights[gaussPointIndex2]) /\n                    Math.sqrt(solutionDerivX ** 2 + solutionDerivY ** 2 + 1e-8)\n                  ) *\n                    basisFunctionDerivX[localNodeIndex2] -\n                    ((detJacobian *\n                      solutionDerivY *\n                      basisFunction[localNodeIndex1] *\n                      gaussWeights[gaussPointIndex1] *\n                      gaussWeights[gaussPointIndex2]) /\n                      Math.sqrt(solutionDerivX ** 2 + solutionDerivY ** 2 + 1e-8)) *\n                      basisFunctionDerivY[localNodeIndex2]);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Create an instance of GenericBoundaryConditions\n  basicLog(\"Applying generic boundary conditions...\");\n  const genericBoundaryConditions = new GenericBoundaryConditions(\n    boundaryConditions,\n    boundaryElements,\n    nop,\n    meshDimension,\n    elementOrder\n  );\n\n  // Impose ConstantValue boundary conditions\n  genericBoundaryConditions.imposeConstantValueBoundaryConditions(residualVector, jacobianMatrix);\n  basicLog(\"Constant value boundary conditions applied\");\n\n  // Print all residuals\n  debugLog(\"Residuals at each node:\");\n  for (let i = 0; i < residualVector.length; i++) {\n    debugLog(`Node ${i}: ${residualVector[i].toExponential(6)}`);\n  }\n\n  basicLog(\"Front propagation matrix assembly completed\");\n\n  return {\n    jacobianMatrix,\n    residualVector,\n    nodesCoordinates: {\n      nodesXCoordinates,\n      nodesYCoordinates,\n    },\n  };\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n// Internal imports\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Class to handle thermal boundary conditions application\n */\nexport class ThermalBoundaryConditions {\n  /**\n   * Constructor to initialize the ThermalBoundaryConditions class\n   * @param {object} boundaryConditions - Object containing boundary conditions for the finite element analysis\n   * @param {array} boundaryElements - Array containing elements that belong to each boundary\n   * @param {array} nop - Nodal numbering (NOP) array representing the connectivity between elements and nodes\n   * @param {string} meshDimension - The dimension of the mesh (e.g., \"2D\")\n   * @param {string} elementOrder - The order of elements (e.g., \"linear\", \"quadratic\")\n   */\n  constructor(boundaryConditions, boundaryElements, nop, meshDimension, elementOrder) {\n    this.boundaryConditions = boundaryConditions;\n    this.boundaryElements = boundaryElements;\n    this.nop = nop;\n    this.meshDimension = meshDimension;\n    this.elementOrder = elementOrder;\n  }\n\n  /**\n   * Function to impose constant temperature boundary conditions (Dirichlet type)\n   * @param {array} residualVector - The residual vector to be modified\n   * @param {array} jacobianMatrix - The Jacobian matrix to be modified\n   */\n  imposeConstantTempBoundaryConditions(residualVector, jacobianMatrix) {\n    basicLog(\"Applying constant temperature boundary conditions (Dirichlet type)\");\n    if (this.meshDimension === \"1D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        if (this.boundaryConditions[boundaryKey][0] === \"constantTemp\") {\n          const tempValue = this.boundaryConditions[boundaryKey][1];\n          debugLog(\n            `Boundary ${boundaryKey}: Applying constant temperature of ${tempValue} K (Dirichlet condition)`\n          );\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            if (this.elementOrder === \"linear\") {\n              const boundarySides = {\n                0: [0], // Node at the left side of the reference element\n                1: [1], // Node at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant temperature to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                // Set the residual vector to the ConstantTemp value\n                residualVector[globalNodeIndex] = tempValue;\n                // Set the Jacobian matrix row to zero\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\n                }\n                // Set the diagonal entry of the Jacobian matrix to one\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\n              });\n            } else if (this.elementOrder === \"quadratic\") {\n              const boundarySides = {\n                0: [0], // Node at the left side of the reference element\n                2: [2], // Node at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant temperature to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                // Set the residual vector to the ConstantTemp value\n                residualVector[globalNodeIndex] = tempValue;\n                // Set the Jacobian matrix row to zero\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\n                }\n                // Set the diagonal entry of the Jacobian matrix to one\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\n              });\n            }\n          });\n        }\n      });\n    } else if (this.meshDimension === \"2D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        if (this.boundaryConditions[boundaryKey][0] === \"constantTemp\") {\n          const tempValue = this.boundaryConditions[boundaryKey][1];\n          debugLog(\n            `Boundary ${boundaryKey}: Applying constant temperature of ${tempValue} K (Dirichlet condition)`\n          );\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            if (this.elementOrder === \"linear\") {\n              const boundarySides = {\n                0: [0, 2], // Nodes at the bottom side of the reference element\n                1: [0, 1], // Nodes at the left side of the reference element\n                2: [1, 3], // Nodes at the top side of the reference element\n                3: [2, 3], // Nodes at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant temperature to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                // Set the residual vector to the ConstantTemp value\n                residualVector[globalNodeIndex] = tempValue;\n                // Set the Jacobian matrix row to zero\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\n                }\n                // Set the diagonal entry of the Jacobian matrix to one\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\n              });\n            } else if (this.elementOrder === \"quadratic\") {\n              const boundarySides = {\n                0: [0, 3, 6], // Nodes at the bottom side of the reference element\n                1: [0, 1, 2], // Nodes at the left side of the reference element\n                2: [2, 5, 8], // Nodes at the top side of the reference element\n                3: [6, 7, 8], // Nodes at the right side of the reference element\n              };\n              boundarySides[side].forEach((nodeIndex) => {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n                debugLog(\n                  `  - Applied constant temperature to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${nodeIndex + 1})`\n                );\n                // Set the residual vector to the ConstantTemp value\n                residualVector[globalNodeIndex] = tempValue;\n                // Set the Jacobian matrix row to zero\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\n                }\n                // Set the diagonal entry of the Jacobian matrix to one\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\n              });\n            }\n          });\n        }\n      });\n    }\n  }\n\n  /**\n   * Function to impose convection boundary conditions (Robin type)\n   * @param {array} residualVector - The residual vector to be modified\n   * @param {array} jacobianMatrix - The Jacobian matrix to be modified\n   * @param {array} gaussPoints - Array of Gauss points for numerical integration\n   * @param {array} gaussWeights - Array of Gauss weights for numerical integration\n   * @param {array} nodesXCoordinates - Array of x-coordinates of nodes\n   * @param {array} nodesYCoordinates - Array of y-coordinates of nodes\n   * @param {object} basisFunctions - Object containing basis functions and their derivatives\n   */\n  imposeConvectionBoundaryConditions(\n    residualVector,\n    jacobianMatrix,\n    gaussPoints,\n    gaussWeights,\n    nodesXCoordinates,\n    nodesYCoordinates,\n    basisFunctions\n  ) {\n    basicLog(\"Applying convection boundary conditions (Robin type)\");\n    // Extract convection parameters from boundary conditions\n    let convectionHeatTranfCoeff = [];\n    let convectionExtTemp = [];\n    Object.keys(this.boundaryConditions).forEach((key) => {\n      const boundaryCondition = this.boundaryConditions[key];\n      if (boundaryCondition[0] === \"convection\") {\n        convectionHeatTranfCoeff[key] = boundaryCondition[1];\n        convectionExtTemp[key] = boundaryCondition[2];\n      }\n    });\n\n    if (this.meshDimension === \"1D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        if (this.boundaryConditions[boundaryKey][0] === \"convection\") {\n          const convectionCoeff = convectionHeatTranfCoeff[boundaryKey];\n          const extTemp = convectionExtTemp[boundaryKey];\n          debugLog(\n            `Boundary ${boundaryKey}: Applying convection with heat transfer coefficient h=${convectionCoeff} W/(mÂ²Â·K) and external temperature Tâˆž=${extTemp} K`\n          );\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            let nodeIndex;\n            if (this.elementOrder === \"linear\") {\n              if (side === 0) {\n                // Node at the left side of the reference element\n                nodeIndex = 0;\n              } else {\n                // Node at the right side of the reference element\n                nodeIndex = 1;\n              }\n            } else if (this.elementOrder === \"quadratic\") {\n              if (side === 0) {\n                // Node at the left side of the reference element\n                nodeIndex = 0;\n              } else {\n                // Node at the right side of the reference element\n                nodeIndex = 2;\n              }\n            }\n\n            const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n            debugLog(\n              `  - Applied convection boundary condition to node ${globalNodeIndex + 1} (element ${\n                elementIndex + 1\n              }, local node ${nodeIndex + 1})`\n            );\n            residualVector[globalNodeIndex] += -convectionCoeff * extTemp;\n            jacobianMatrix[globalNodeIndex][globalNodeIndex] += convectionCoeff;\n          });\n        }\n      });\n    } else if (this.meshDimension === \"2D\") {\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\n        if (this.boundaryConditions[boundaryKey][0] === \"convection\") {\n          const convectionCoeff = convectionHeatTranfCoeff[boundaryKey];\n          const extTemp = convectionExtTemp[boundaryKey];\n          debugLog(\n            `Boundary ${boundaryKey}: Applying convection with heat transfer coefficient h=${convectionCoeff} W/(mÂ²Â·K) and external temperature Tâˆž=${extTemp} K`\n          );\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\n            if (this.elementOrder === \"linear\") {\n              let gaussPoint1, gaussPoint2, firstNodeIndex, lastNodeIndex, nodeIncrement;\n              if (side === 0) {\n                // Nodes at the bottom side of the reference element\n                gaussPoint1 = gaussPoints[0];\n                gaussPoint2 = 0;\n                firstNodeIndex = 0;\n                lastNodeIndex = 3;\n                nodeIncrement = 2;\n              } else if (side === 1) {\n                // Nodes at the left side of the reference element\n                gaussPoint1 = 0;\n                gaussPoint2 = gaussPoints[0];\n                firstNodeIndex = 0;\n                lastNodeIndex = 2;\n                nodeIncrement = 1;\n              } else if (side === 2) {\n                // Nodes at the top side of the reference element\n                gaussPoint1 = gaussPoints[0];\n                gaussPoint2 = 1;\n                firstNodeIndex = 1;\n                lastNodeIndex = 4;\n                nodeIncrement = 2;\n              } else if (side === 3) {\n                // Nodes at the right side of the reference element\n                gaussPoint1 = 1;\n                gaussPoint2 = gaussPoints[0];\n                firstNodeIndex = 2;\n                lastNodeIndex = 4;\n                nodeIncrement = 1;\n              }\n\n              let basisFunctionsAndDerivatives = basisFunctions.getBasisFunctions(gaussPoint1, gaussPoint2);\n              let basisFunction = basisFunctionsAndDerivatives.basisFunction;\n              let basisFunctionDerivKsi = basisFunctionsAndDerivatives.basisFunctionDerivKsi;\n              let basisFunctionDerivEta = basisFunctionsAndDerivatives.basisFunctionDerivEta;\n\n              let ksiDerivX = 0;\n              let ksiDerivY = 0;\n              let etaDerivX = 0;\n              let etaDerivY = 0;\n              const numNodes = this.nop[elementIndex].length;\n              for (let nodeIndex = 0; nodeIndex < numNodes; nodeIndex++) {\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n\n                // For boundaries along Ksi (horizontal), use Ksi derivatives\n                if (side === 0 || side === 2) {\n                  ksiDerivX += nodesXCoordinates[globalNodeIndex] * basisFunctionDerivKsi[nodeIndex];\n                  ksiDerivY += nodesYCoordinates[globalNodeIndex] * basisFunctionDerivKsi[nodeIndex];\n                }\n                // For boundaries along Eta (vertical), use Eta derivatives\n                else if (side === 1 || side === 3) {\n                  etaDerivX += nodesXCoordinates[globalNodeIndex] * basisFunctionDerivEta[nodeIndex];\n                  etaDerivY += nodesYCoordinates[globalNodeIndex] * basisFunctionDerivEta[nodeIndex];\n                }\n              }\n\n              // Compute the length of tangent vector\n              let tangentVectorLength;\n              if (side === 0 || side === 2) {\n                tangentVectorLength = Math.sqrt(ksiDerivX ** 2 + ksiDerivY ** 2);\n              } else {\n                tangentVectorLength = Math.sqrt(etaDerivX ** 2 + etaDerivY ** 2);\n              }\n\n              for (\n                let localNodeIndex = firstNodeIndex;\n                localNodeIndex < lastNodeIndex;\n                localNodeIndex += nodeIncrement\n              ) {\n                let globalNodeIndex = this.nop[elementIndex][localNodeIndex] - 1;\n                debugLog(\n                  `  - Applied convection boundary condition to node ${globalNodeIndex + 1} (element ${\n                    elementIndex + 1\n                  }, local node ${localNodeIndex + 1})`\n                );\n\n                // Apply boundary condition with proper Jacobian for all sides\n                residualVector[globalNodeIndex] +=\n                  -gaussWeights[0] *\n                  tangentVectorLength *\n                  basisFunction[localNodeIndex] *\n                  convectionCoeff *\n                  extTemp;\n\n                for (\n                  let localNodeIndex2 = firstNodeIndex;\n                  localNodeIndex2 < lastNodeIndex;\n                  localNodeIndex2 += nodeIncrement\n                ) {\n                  let globalNodeIndex2 = this.nop[elementIndex][localNodeIndex2] - 1;\n                  jacobianMatrix[globalNodeIndex][globalNodeIndex2] +=\n                    -gaussWeights[0] *\n                    tangentVectorLength *\n                    basisFunction[localNodeIndex] *\n                    basisFunction[localNodeIndex2] *\n                    convectionCoeff;\n                }\n              }\n            } else if (this.elementOrder === \"quadratic\") {\n              for (let gaussPointIndex = 0; gaussPointIndex < 3; gaussPointIndex++) {\n                let gaussPoint1, gaussPoint2, firstNodeIndex, lastNodeIndex, nodeIncrement;\n                if (side === 0) {\n                  // Nodes at the bottom side of the reference element\n                  gaussPoint1 = gaussPoints[gaussPointIndex];\n                  gaussPoint2 = 0;\n                  firstNodeIndex = 0;\n                  lastNodeIndex = 7;\n                  nodeIncrement = 3;\n                } else if (side === 1) {\n                  // Nodes at the left side of the reference element\n                  gaussPoint1 = 0;\n                  gaussPoint2 = gaussPoints[gaussPointIndex];\n                  firstNodeIndex = 0;\n                  lastNodeIndex = 3;\n                  nodeIncrement = 1;\n                } else if (side === 2) {\n                  // Nodes at the top side of the reference element\n                  gaussPoint1 = gaussPoints[gaussPointIndex];\n                  gaussPoint2 = 1;\n                  firstNodeIndex = 2;\n                  lastNodeIndex = 9;\n                  nodeIncrement = 3;\n                } else if (side === 3) {\n                  // Nodes at the right side of the reference element\n                  gaussPoint1 = 1;\n                  gaussPoint2 = gaussPoints[gaussPointIndex];\n                  firstNodeIndex = 6;\n                  lastNodeIndex = 9;\n                  nodeIncrement = 1;\n                }\n                let basisFunctionsAndDerivatives = basisFunctions.getBasisFunctions(gaussPoint1, gaussPoint2);\n                let basisFunction = basisFunctionsAndDerivatives.basisFunction;\n                let basisFunctionDerivKsi = basisFunctionsAndDerivatives.basisFunctionDerivKsi;\n                let basisFunctionDerivEta = basisFunctionsAndDerivatives.basisFunctionDerivEta;\n\n                let ksiDerivX = 0;\n                let ksiDerivY = 0;\n                let etaDerivX = 0;\n                let etaDerivY = 0;\n                const numNodes = this.nop[elementIndex].length;\n                for (let nodeIndex = 0; nodeIndex < numNodes; nodeIndex++) {\n                  const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\n\n                  // For boundaries along Ksi (horizontal), use Ksi derivatives\n                  if (side === 0 || side === 2) {\n                    ksiDerivX += nodesXCoordinates[globalNodeIndex] * basisFunctionDerivKsi[nodeIndex];\n                    ksiDerivY += nodesYCoordinates[globalNodeIndex] * basisFunctionDerivKsi[nodeIndex];\n                  }\n                  // For boundaries along Eta (vertical), use Eta derivatives\n                  else if (side === 1 || side === 3) {\n                    etaDerivX += nodesXCoordinates[globalNodeIndex] * basisFunctionDerivEta[nodeIndex];\n                    etaDerivY += nodesYCoordinates[globalNodeIndex] * basisFunctionDerivEta[nodeIndex];\n                  }\n                }\n\n                // Compute the length of tangent vector\n                let tangentVectorLength;\n                if (side === 0 || side === 2) {\n                  tangentVectorLength = Math.sqrt(ksiDerivX ** 2 + ksiDerivY ** 2);\n                } else {\n                  tangentVectorLength = Math.sqrt(etaDerivX ** 2 + etaDerivY ** 2);\n                }\n\n                for (\n                  let localNodeIndex = firstNodeIndex;\n                  localNodeIndex < lastNodeIndex;\n                  localNodeIndex += nodeIncrement\n                ) {\n                  let globalNodeIndex = this.nop[elementIndex][localNodeIndex] - 1;\n                  debugLog(\n                    `  - Applied convection boundary condition to node ${globalNodeIndex + 1} (element ${\n                      elementIndex + 1\n                    }, local node ${localNodeIndex + 1})`\n                  );\n\n                  // Apply boundary condition with proper Jacobian for all sides\n                  residualVector[globalNodeIndex] +=\n                    -gaussWeights[gaussPointIndex] *\n                    tangentVectorLength *\n                    basisFunction[localNodeIndex] *\n                    convectionCoeff *\n                    extTemp;\n\n                  for (\n                    let localNodeIndex2 = firstNodeIndex;\n                    localNodeIndex2 < lastNodeIndex;\n                    localNodeIndex2 += nodeIncrement\n                  ) {\n                    let globalNodeIndex2 = this.nop[elementIndex][localNodeIndex2] - 1;\n                    jacobianMatrix[globalNodeIndex][globalNodeIndex2] +=\n                      -gaussWeights[gaussPointIndex] *\n                      tangentVectorLength *\n                      basisFunction[localNodeIndex] *\n                      basisFunction[localNodeIndex2] *\n                      convectionCoeff;\n                  }\n                }\n              }\n            }\n          });\n        }\n      });\n    }\n  }\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n// Internal imports\nimport { newtonRaphson } from \"./methods/newtonRaphsonScript.js\";\nimport { solveLinearSystem } from \"./methods/linearSystemSolverScript.js\";\nimport { assembleFrontPropagationMat } from \"./solvers/frontPropagationScript.js\";\nimport { assembleSolidHeatTransferMat } from \"./solvers/solidHeatTransferScript.js\";\nimport { basicLog, debugLog, errorLog } from \"./utilities/loggingScript.js\";\n\n/**\n * Class to implement finite element analysis in JavaScript\n * @param {string} solverConfig - Parameter specifying the type of solver\n * @param {object} meshConfig - Object containing computational mesh details\n * @param {object} boundaryConditions - Object containing boundary conditions for the finite element analysis\n * @returns {object} An object containing the solution vector and additional mesh information\n */\nexport class FEAScriptModel {\n  constructor() {\n    this.solverConfig = null;\n    this.meshConfig = {};\n    this.boundaryConditions = {};\n    this.solverMethod = \"lusolve\"; // Default solver method\n    basicLog(\"FEAScriptModel instance created\");\n  }\n\n  setSolverConfig(solverConfig) {\n    this.solverConfig = solverConfig;\n    debugLog(`Solver config set to: ${solverConfig}`);\n  }\n\n  setMeshConfig(meshConfig) {\n    this.meshConfig = meshConfig;\n    debugLog(`Mesh config set with dimensions: ${meshConfig.meshDimension}`);\n  }\n\n  addBoundaryCondition(boundaryKey, condition) {\n    this.boundaryConditions[boundaryKey] = condition;\n    debugLog(`Boundary condition added for boundary: ${boundaryKey}, type: ${condition[0]}`);\n  }\n\n  setSolverMethod(solverMethod) {\n    this.solverMethod = solverMethod;\n    debugLog(`Solver method set to: ${solverMethod}`);\n  }\n\n  async solve() {\n    if (!this.solverConfig || !this.meshConfig || !this.boundaryConditions) {\n      const error = \"Solver config, mesh config, and boundary conditions must be set before solving.\";\n      console.error(error);\n      throw new Error(error);\n    }\n\n    let jacobianMatrix = [];\n    let residualVector = [];\n    let solutionVector = [];\n    let initialSolution = [];\n    let nodesCoordinates = {};\n    let eikonalExteralIterations = 5; // Number of incremental steps to gradually activate the eikonal term - Used in frontPropagationScript\n    let newtonRaphsonIterations;\n\n    // Select and execute the appropriate solver based on solverConfig\n    basicLog(\"Beginning solving process...\");\n    console.time(\"totalSolvingTime\");\n    if (this.solverConfig === \"solidHeatTransferScript\") {\n      basicLog(`Using solver: ${this.solverConfig}`);\n      ({ jacobianMatrix, residualVector, nodesCoordinates } = assembleSolidHeatTransferMat(\n        this.meshConfig,\n        this.boundaryConditions\n      ));\n\n      // Solve the assembled linear system\n      const linearSystemResult = await solveLinearSystem(this.solverMethod, jacobianMatrix, residualVector);\n      solutionVector = linearSystemResult.solutionVector;\n    } else if (this.solverConfig === \"frontPropagationScript\") {\n      basicLog(`Using solver: ${this.solverConfig}`);\n\n      // Initialize eikonalActivationFlag\n      let eikonalActivationFlag = 0;\n\n      // Create context object with all necessary properties\n      const context = {\n        meshConfig: this.meshConfig,\n        boundaryConditions: this.boundaryConditions,\n        eikonalActivationFlag: eikonalActivationFlag,\n        solverMethod: this.solverMethod,\n        initialSolution,\n      };\n\n      while (eikonalActivationFlag <= 1) {\n        // Update the context object with current eikonalActivationFlag\n        context.eikonalActivationFlag = eikonalActivationFlag;\n\n        // Pass the previous solution as initial guess\n        if (solutionVector.length > 0) {\n          context.initialSolution = [...solutionVector];\n        }\n\n        const newtonRaphsonResult = await newtonRaphson(assembleFrontPropagationMat, context, 100, 1e-4);\n\n        // Extract results\n        jacobianMatrix = newtonRaphsonResult.jacobianMatrix;\n        residualVector = newtonRaphsonResult.residualVector;\n        nodesCoordinates = newtonRaphsonResult.nodesCoordinates;\n        solutionVector = newtonRaphsonResult.solutionVector;\n        newtonRaphsonIterations = newtonRaphsonResult.iterations;\n\n        // Increment for next iteration\n        eikonalActivationFlag += 1 / eikonalExteralIterations;\n      }\n    }\n    console.timeEnd(\"totalSolvingTime\");\n    basicLog(\"Solving process completed\");\n\n    return { solutionVector, nodesCoordinates };\n  }\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n// Internal imports\nimport { BasisFunctions } from \"../mesh/basisFunctionsScript.js\";\nimport { Mesh1D, Mesh2D } from \"../mesh/meshGenerationScript.js\";\nimport { NumericalIntegration } from \"../methods/numericalIntegrationScript.js\";\nimport { ThermalBoundaryConditions } from \"./thermalBoundaryConditionsScript.js\";\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Function to assemble the solid heat transfer matrix\n * @param {object} meshConfig - Object containing computational mesh details\n * @param {object} boundaryConditions - Object containing boundary conditions for the finite element analysis\n * @returns {object} An object containing:\n *  - jacobianMatrix: The assembled Jacobian matrix\n *  - residualVector: The assembled residual vector\n *  - nodesCoordinates: Object containing x and y coordinates of nodes\n */\nexport function assembleSolidHeatTransferMat(meshConfig, boundaryConditions) {\n  basicLog(\"Starting solid heat transfer matrix assembly...\");\n\n  // Extract mesh details from the configuration object\n  const {\n    meshDimension, // The dimension of the mesh\n    numElementsX, // Number of elements in x-direction\n    numElementsY, // Number of elements in y-direction (only for 2D)\n    maxX, // Max x-coordinate (m) of the domain\n    maxY, // Max y-coordinate (m) of the domain (only for 2D)\n    elementOrder, // The order of elements\n    parsedMesh, // The pre-parsed mesh data (if available)\n  } = meshConfig;\n\n  // Create a new instance of the Mesh class\n  debugLog(\"Generating mesh...\");\n  let mesh;\n  if (meshDimension === \"1D\") {\n    mesh = new Mesh1D({ numElementsX, maxX, elementOrder, parsedMesh });\n  } else if (meshDimension === \"2D\") {\n    mesh = new Mesh2D({ numElementsX, maxX, numElementsY, maxY, elementOrder, parsedMesh });\n  } else {\n    errorLog(\"Mesh dimension must be either '1D' or '2D'.\");\n  }\n\n  // Use the parsed mesh in case it was already passed with Gmsh format\n  const nodesCoordinatesAndNumbering = mesh.boundaryElementsProcessed ? mesh.parsedMesh : mesh.generateMesh();\n\n  // Extract nodes coordinates and nodal numbering (NOP) from the mesh data\n  let nodesXCoordinates = nodesCoordinatesAndNumbering.nodesXCoordinates;\n  let nodesYCoordinates = nodesCoordinatesAndNumbering.nodesYCoordinates;\n  let totalNodesX = nodesCoordinatesAndNumbering.totalNodesX;\n  let totalNodesY = nodesCoordinatesAndNumbering.totalNodesY;\n  let nop = nodesCoordinatesAndNumbering.nodalNumbering;\n  let boundaryElements = nodesCoordinatesAndNumbering.boundaryElements;\n\n  // Check the mesh type\n  const isParsedMesh = parsedMesh !== undefined && parsedMesh !== null;\n\n  // Calculate totalElements and totalNodes based on mesh type\n  let totalElements, totalNodes;\n\n  if (isParsedMesh) {\n    totalElements = nop.length; // Number of elements is the length of the nodal numbering array\n    totalNodes = nodesXCoordinates.length; // Number of nodes is the length of the coordinates array\n\n    // Debug log for mesh size\n    debugLog(`Using parsed mesh with ${totalElements} elements and ${totalNodes} nodes`);\n  } else {\n    // For structured mesh, calculate based on dimensions\n    totalElements = numElementsX * (meshDimension === \"2D\" ? numElementsY : 1);\n    totalNodes = totalNodesX * (meshDimension === \"2D\" ? totalNodesY : 1);\n    // Debug log for mesh size\n    debugLog(`Using mesh generated from geometry with ${totalElements} elements and ${totalNodes} nodes`);\n  }\n\n  // Initialize variables for matrix assembly\n  let localToGlobalMap = []; // Maps local element node indices to global mesh node indices\n  let gaussPoints = []; // Gauss points\n  let gaussWeights = []; // Gauss weights\n  let basisFunction = []; // Basis functions\n  let basisFunctionDerivKsi = []; // Derivatives of basis functions with respect to ksi\n  let basisFunctionDerivEta = []; // Derivatives of basis functions with respect to eta (only for 2D)\n  let basisFunctionDerivX = []; // The x-derivative of the basis function\n  let basisFunctionDerivY = []; // The y-derivative of the basis function (only for 2D)\n  let residualVector = []; // Galerkin residuals\n  let jacobianMatrix = []; // Jacobian matrix\n  let xCoordinates; // x-coordinate (physical coordinates)\n  let yCoordinates; // y-coordinate (physical coordinates) (only for 2D)\n  let ksiDerivX; // ksi-derivative of xCoordinates\n  let etaDerivX; // eta-derivative of xCoordinates (ksi and eta are natural coordinates that vary within a reference element) (only for 2D)\n  let ksiDerivY; // ksi-derivative of yCoordinates (only for 2D)\n  let etaDerivY; // eta-derivative of yCoordinates (only for 2D)\n  let detJacobian; // The Jacobian of the isoparametric mapping\n\n  // Initialize jacobianMatrix and residualVector arrays\n  for (let nodeIndex = 0; nodeIndex < totalNodes; nodeIndex++) {\n    residualVector[nodeIndex] = 0;\n    jacobianMatrix.push([]);\n    for (let colIndex = 0; colIndex < totalNodes; colIndex++) {\n      jacobianMatrix[nodeIndex][colIndex] = 0;\n    }\n  }\n\n  // Initialize the BasisFunctions class\n  const basisFunctions = new BasisFunctions({\n    meshDimension,\n    elementOrder,\n  });\n\n  // Initialize the NumericalIntegration class\n  const numericalIntegration = new NumericalIntegration({\n    meshDimension,\n    elementOrder,\n  });\n\n  // Calculate Gauss points and weights\n  let gaussPointsAndWeights = numericalIntegration.getGaussPointsAndWeights();\n  gaussPoints = gaussPointsAndWeights.gaussPoints;\n  gaussWeights = gaussPointsAndWeights.gaussWeights;\n\n  // Determine the number of nodes in the reference element based on the first element in the nop array\n  const numNodes = nop[0].length;\n\n  // Matrix assembly\n  for (let elementIndex = 0; elementIndex < totalElements; elementIndex++) {\n    for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n      // Subtract 1 from nop in order to start numbering from 0\n      localToGlobalMap[localNodeIndex] = nop[elementIndex][localNodeIndex] - 1;\n    }\n\n    // Loop over Gauss points\n    for (let gaussPointIndex1 = 0; gaussPointIndex1 < gaussPoints.length; gaussPointIndex1++) {\n      // 1D solid heat transfer\n      if (meshDimension === \"1D\") {\n        let basisFunctionsAndDerivatives = basisFunctions.getBasisFunctions(gaussPoints[gaussPointIndex1]);\n        basisFunction = basisFunctionsAndDerivatives.basisFunction;\n        basisFunctionDerivKsi = basisFunctionsAndDerivatives.basisFunctionDerivKsi;\n        xCoordinates = 0;\n        ksiDerivX = 0;\n\n        // Isoparametric mapping\n        for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n          xCoordinates += nodesXCoordinates[localToGlobalMap[localNodeIndex]] * basisFunction[localNodeIndex];\n          ksiDerivX +=\n            nodesXCoordinates[localToGlobalMap[localNodeIndex]] * basisFunctionDerivKsi[localNodeIndex];\n        }\n        detJacobian = ksiDerivX;\n\n        // Compute x-derivative of basis functions\n        for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n          basisFunctionDerivX[localNodeIndex] = basisFunctionDerivKsi[localNodeIndex] / detJacobian; // The x-derivative of the n basis function\n        }\n\n        // Computation of Galerkin's residuals and Jacobian matrix\n        for (let localNodeIndex1 = 0; localNodeIndex1 < numNodes; localNodeIndex1++) {\n          let localToGlobalMap1 = localToGlobalMap[localNodeIndex1];\n          // residualVector is zero for this case\n\n          for (let localNodeIndex2 = 0; localNodeIndex2 < numNodes; localNodeIndex2++) {\n            let localToGlobalMap2 = localToGlobalMap[localNodeIndex2];\n            jacobianMatrix[localToGlobalMap1][localToGlobalMap2] +=\n              -gaussWeights[gaussPointIndex1] *\n              detJacobian *\n              (basisFunctionDerivX[localNodeIndex1] * basisFunctionDerivX[localNodeIndex2]);\n          }\n        }\n        // 2D solid heat transfer\n      } else if (meshDimension === \"2D\") {\n        for (let gaussPointIndex2 = 0; gaussPointIndex2 < gaussPoints.length; gaussPointIndex2++) {\n          // Initialise variables for isoparametric mapping\n          let basisFunctionsAndDerivatives = basisFunctions.getBasisFunctions(\n            gaussPoints[gaussPointIndex1],\n            gaussPoints[gaussPointIndex2]\n          );\n          basisFunction = basisFunctionsAndDerivatives.basisFunction;\n          basisFunctionDerivKsi = basisFunctionsAndDerivatives.basisFunctionDerivKsi;\n          basisFunctionDerivEta = basisFunctionsAndDerivatives.basisFunctionDerivEta;\n          xCoordinates = 0;\n          yCoordinates = 0;\n          ksiDerivX = 0;\n          etaDerivX = 0;\n          ksiDerivY = 0;\n          etaDerivY = 0;\n\n          // Isoparametric mapping\n          for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n            xCoordinates +=\n              nodesXCoordinates[localToGlobalMap[localNodeIndex]] * basisFunction[localNodeIndex];\n            yCoordinates +=\n              nodesYCoordinates[localToGlobalMap[localNodeIndex]] * basisFunction[localNodeIndex];\n            ksiDerivX +=\n              nodesXCoordinates[localToGlobalMap[localNodeIndex]] * basisFunctionDerivKsi[localNodeIndex];\n            etaDerivX +=\n              nodesXCoordinates[localToGlobalMap[localNodeIndex]] * basisFunctionDerivEta[localNodeIndex];\n            ksiDerivY +=\n              nodesYCoordinates[localToGlobalMap[localNodeIndex]] * basisFunctionDerivKsi[localNodeIndex];\n            etaDerivY +=\n              nodesYCoordinates[localToGlobalMap[localNodeIndex]] * basisFunctionDerivEta[localNodeIndex];\n          }\n          detJacobian = ksiDerivX * etaDerivY - etaDerivX * ksiDerivY;\n\n          // Compute x-derivative and y-derivative of basis functions\n          for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\n            // The x-derivative of the n basis function\n            basisFunctionDerivX[localNodeIndex] =\n              (etaDerivY * basisFunctionDerivKsi[localNodeIndex] -\n                ksiDerivY * basisFunctionDerivEta[localNodeIndex]) /\n              detJacobian;\n            // The y-derivative of the n basis function\n            basisFunctionDerivY[localNodeIndex] =\n              (ksiDerivX * basisFunctionDerivEta[localNodeIndex] -\n                etaDerivX * basisFunctionDerivKsi[localNodeIndex]) /\n              detJacobian;\n          }\n\n          // Computation of Galerkin's residuals and Jacobian matrix\n          for (let localNodeIndex1 = 0; localNodeIndex1 < numNodes; localNodeIndex1++) {\n            let localToGlobalMap1 = localToGlobalMap[localNodeIndex1];\n            // residualVector is zero for this case\n\n            for (let localNodeIndex2 = 0; localNodeIndex2 < numNodes; localNodeIndex2++) {\n              let localToGlobalMap2 = localToGlobalMap[localNodeIndex2];\n              jacobianMatrix[localToGlobalMap1][localToGlobalMap2] +=\n                -gaussWeights[gaussPointIndex1] *\n                gaussWeights[gaussPointIndex2] *\n                detJacobian *\n                (basisFunctionDerivX[localNodeIndex1] * basisFunctionDerivX[localNodeIndex2] +\n                  basisFunctionDerivY[localNodeIndex1] * basisFunctionDerivY[localNodeIndex2]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Create an instance of ThermalBoundaryConditions\n  basicLog(\"Applying thermal boundary conditions...\");\n  const thermalBoundaryConditions = new ThermalBoundaryConditions(\n    boundaryConditions,\n    boundaryElements,\n    nop,\n    meshDimension,\n    elementOrder\n  );\n\n  // Impose Convection boundary conditions\n  thermalBoundaryConditions.imposeConvectionBoundaryConditions(\n    residualVector,\n    jacobianMatrix,\n    gaussPoints,\n    gaussWeights,\n    nodesXCoordinates,\n    nodesYCoordinates,\n    basisFunctions\n  );\n  basicLog(\"Convection boundary conditions applied\");\n\n  // Impose ConstantTemp boundary conditions\n  thermalBoundaryConditions.imposeConstantTempBoundaryConditions(residualVector, jacobianMatrix);\n  basicLog(\"Constant temperature boundary conditions applied\");\n\n  basicLog(\"Solid heat transfer matrix assembly completed\");\n\n  return {\n    jacobianMatrix,\n    residualVector,\n    nodesCoordinates: {\n      nodesXCoordinates,\n      nodesYCoordinates,\n    },\n  };\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n// Internal imports\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Function to import mesh data from Gmsh format containing quadrilateral and triangular elements\n * @param {File} file - The Gmsh file to be parsed (.msh version 4.1)\n * @returns {object} The parsed mesh data including node coordinates, element connectivity, and boundary conditions\n */\nconst importGmshQuadTri = async (file) => {\n  let result = {\n    nodesXCoordinates: [],\n    nodesYCoordinates: [],\n    nodalNumbering: {\n      quadElements: [],\n      triangleElements: [],\n    },\n    boundaryElements: [],\n    boundaryConditions: [],\n    boundaryNodePairs: {}, // Store boundary node pairs for processing in meshGenerationScript\n    gmshV: 0,\n    ascii: false,\n    fltBytes: \"8\",\n    totalNodesX: 0,\n    totalNodesY: 0,\n    physicalPropMap: [],\n    elementTypes: {},\n  };\n\n  let content = await file.text();\n  let lines = content\n    .split(\"\\n\")\n    .map((line) => line.trim())\n    .filter((line) => line !== \"\" && line !== \" \");\n\n  let section = \"\";\n  let lineIndex = 0;\n\n  let nodeEntityBlocks = 0;\n  let totalNodes = 0;\n  let nodeBlocksProcessed = 0;\n  let currentNodeBlock = { numNodes: 0 };\n  let nodeTagsCollected = 0;\n  let nodeTags = [];\n  let nodeCoordinatesCollected = 0;\n\n  let elementEntityBlocks = 0;\n  let totalElements = 0;\n  let elementBlocksProcessed = 0;\n  let currentElementBlock = {\n    dim: 0,\n    tag: 0,\n    elementType: 0,\n    numElements: 0,\n  };\n  let elementsProcessedInBlock = 0;\n\n  let boundaryElementsByTag = {};\n\n  while (lineIndex < lines.length) {\n    const line = lines[lineIndex];\n\n    if (line === \"$MeshFormat\") {\n      section = \"meshFormat\";\n      lineIndex++;\n      continue;\n    } else if (line === \"$EndMeshFormat\") {\n      section = \"\";\n      lineIndex++;\n      continue;\n    } else if (line === \"$PhysicalNames\") {\n      section = \"physicalNames\";\n      lineIndex++;\n      continue;\n    } else if (line === \"$EndPhysicalNames\") {\n      section = \"\";\n      lineIndex++;\n      continue;\n    } else if (line === \"$Entities\") {\n      section = \"entities\";\n      lineIndex++;\n      continue;\n    } else if (line === \"$EndEntities\") {\n      section = \"\";\n      lineIndex++;\n      continue;\n    } else if (line === \"$Nodes\") {\n      section = \"nodes\";\n      lineIndex++;\n      continue;\n    } else if (line === \"$EndNodes\") {\n      section = \"\";\n      lineIndex++;\n      continue;\n    } else if (line === \"$Elements\") {\n      section = \"elements\";\n      lineIndex++;\n      continue;\n    } else if (line === \"$EndElements\") {\n      section = \"\";\n      lineIndex++;\n      continue;\n    }\n\n    const parts = line.split(/\\s+/).filter((part) => part !== \"\");\n\n    if (section === \"meshFormat\") {\n      result.gmshV = parseFloat(parts[0]);\n      result.ascii = parts[1] === \"0\";\n      result.fltBytes = parts[2];\n    } else if (section === \"physicalNames\") {\n      if (parts.length >= 3) {\n        if (!/^\\d+$/.test(parts[0])) {\n          lineIndex++;\n          continue;\n        }\n\n        const dimension = parseInt(parts[0], 10);\n        const tag = parseInt(parts[1], 10);\n        let name = parts.slice(2).join(\" \");\n        name = name.replace(/^\"|\"$/g, \"\");\n\n        result.physicalPropMap.push({\n          tag,\n          dimension,\n          name,\n        });\n      }\n    } else if (section === \"nodes\") {\n      if (nodeEntityBlocks === 0) {\n        nodeEntityBlocks = parseInt(parts[0], 10);\n        totalNodes = parseInt(parts[1], 10);\n        result.nodesXCoordinates = new Array(totalNodes).fill(0);\n        result.nodesYCoordinates = new Array(totalNodes).fill(0);\n        lineIndex++;\n        continue;\n      }\n\n      if (nodeBlocksProcessed < nodeEntityBlocks && currentNodeBlock.numNodes === 0) {\n        currentNodeBlock = {\n          dim: parseInt(parts[0], 10),\n          tag: parseInt(parts[1], 10),\n          parametric: parseInt(parts[2], 10),\n          numNodes: parseInt(parts[3], 10),\n        };\n\n        nodeTags = [];\n        nodeTagsCollected = 0;\n        nodeCoordinatesCollected = 0;\n\n        lineIndex++;\n        continue;\n      }\n\n      if (nodeTagsCollected < currentNodeBlock.numNodes) {\n        for (let i = 0; i < parts.length && nodeTagsCollected < currentNodeBlock.numNodes; i++) {\n          nodeTags.push(parseInt(parts[i], 10));\n          nodeTagsCollected++;\n        }\n\n        if (nodeTagsCollected < currentNodeBlock.numNodes) {\n          lineIndex++;\n          continue;\n        }\n\n        lineIndex++;\n        continue;\n      }\n\n      if (nodeCoordinatesCollected < currentNodeBlock.numNodes) {\n        const nodeTag = nodeTags[nodeCoordinatesCollected] - 1;\n        const x = parseFloat(parts[0]);\n        const y = parseFloat(parts[1]);\n\n        result.nodesXCoordinates[nodeTag] = x;\n        result.nodesYCoordinates[nodeTag] = y;\n        result.totalNodesX++;\n        result.totalNodesY++;\n\n        nodeCoordinatesCollected++;\n\n        if (nodeCoordinatesCollected === currentNodeBlock.numNodes) {\n          nodeBlocksProcessed++;\n          currentNodeBlock = { numNodes: 0 };\n        }\n      }\n    } else if (section === \"elements\") {\n      if (elementEntityBlocks === 0) {\n        elementEntityBlocks = parseInt(parts[0], 10);\n        totalElements = parseInt(parts[1], 10);\n        lineIndex++;\n        continue;\n      }\n\n      if (elementBlocksProcessed < elementEntityBlocks && currentElementBlock.numElements === 0) {\n        currentElementBlock = {\n          dim: parseInt(parts[0], 10),\n          tag: parseInt(parts[1], 10),\n          elementType: parseInt(parts[2], 10),\n          numElements: parseInt(parts[3], 10),\n        };\n\n        result.elementTypes[currentElementBlock.elementType] =\n          (result.elementTypes[currentElementBlock.elementType] || 0) + currentElementBlock.numElements;\n\n        elementsProcessedInBlock = 0;\n        lineIndex++;\n        continue;\n      }\n\n      if (elementsProcessedInBlock < currentElementBlock.numElements) {\n        const elementTag = parseInt(parts[0], 10);\n        const nodeIndices = parts.slice(1).map((idx) => parseInt(idx, 10));\n\n        if (currentElementBlock.elementType === 1 || currentElementBlock.elementType === 8) {\n          const physicalTag = currentElementBlock.tag;\n\n          if (!boundaryElementsByTag[physicalTag]) {\n            boundaryElementsByTag[physicalTag] = [];\n          }\n\n          boundaryElementsByTag[physicalTag].push(nodeIndices);\n\n          // Store boundary node pairs for later processing in meshGenerationScript\n          if (!result.boundaryNodePairs[physicalTag]) {\n            result.boundaryNodePairs[physicalTag] = [];\n          }\n          result.boundaryNodePairs[physicalTag].push(nodeIndices);\n        } else if (currentElementBlock.elementType === 2) {\n          // Linear triangle elements (3 nodes)\n          result.nodalNumbering.triangleElements.push(nodeIndices);\n        } else if (currentElementBlock.elementType === 3) {\n          // Linear quadrilateral elements (4 nodes)\n          result.nodalNumbering.quadElements.push(nodeIndices);\n        } else if (currentElementBlock.elementType === 10) {\n          // Quadratic quadrilateral elements (9 nodes)\n          result.nodalNumbering.quadElements.push(nodeIndices);\n        }\n\n        elementsProcessedInBlock++;\n\n        if (elementsProcessedInBlock === currentElementBlock.numElements) {\n          elementBlocksProcessed++;\n          currentElementBlock = { numElements: 0 };\n        }\n      }\n    }\n\n    lineIndex++;\n  }\n\n  // Store boundary conditions information\n  result.physicalPropMap.forEach((prop) => {\n    if (prop.dimension === 1) {\n      const boundaryNodes = boundaryElementsByTag[prop.tag] || [];\n\n      if (boundaryNodes.length > 0) {\n        result.boundaryConditions.push({\n          name: prop.name,\n          tag: prop.tag,\n          nodes: boundaryNodes,\n        });\n      }\n    }\n  });\n\n  debugLog(\n    `Parsed boundary node pairs by physical tag: ${JSON.stringify(\n      result.boundaryNodePairs\n    )}. These pairs will be used to identify boundary elements in the mesh.`\n  );\n\n  return result;\n};\n\nexport { importGmshQuadTri };\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n/**\n * Function to create plots of the solution vector\n * @param {*} solutionVector - The computed solution vector\n * @param {*} nodesCoordinates - Object containing x and y coordinates for the nodes\n * @param {string} solverConfig - Parameter specifying the type of solver\n * @param {string} meshDimension - The dimension of the solution\n * @param {string} plotType - The type of plot\n * @param {string} plotDivId - The id of the div where the plot will be rendered\n * @param {string} [meshType=\"structured\"] - Type of mesh: \"structured\" or \"unstructured\"\n */\nexport function plotSolution(\n  solutionVector,\n  nodesCoordinates,\n  solverConfig,\n  meshDimension,\n  plotType,\n  plotDivId,\n  meshType = \"structured\"\n) {\n  const { nodesXCoordinates, nodesYCoordinates } = nodesCoordinates;\n\n  if (meshDimension === \"1D\" && plotType === \"line\") {\n    // Check if solutionVector is a nested array\n    let yData;\n    if (solutionVector.length > 0 && Array.isArray(solutionVector[0])) {\n      yData = solutionVector.map((arr) => arr[0]);\n    } else {\n      yData = solutionVector;\n    }\n    let xData = Array.from(nodesXCoordinates);\n\n    let lineData = {\n      x: xData,\n      y: yData,\n      mode: \"lines\",\n      type: \"scatter\",\n      line: { color: \"rgb(219, 64, 82)\", width: 2 },\n      name: \"Solution\",\n    };\n\n    let maxWindowWidth = Math.min(window.innerWidth, 700);\n    let maxPlotWidth = Math.max(...xData);\n    let zoomFactor = maxWindowWidth / maxPlotWidth;\n    let plotWidth = Math.max(zoomFactor * maxPlotWidth, 400);\n    let plotHeight = 350;\n\n    let layout = {\n      title: `line plot - ${solverConfig}`,\n      width: plotWidth,\n      height: plotHeight,\n      xaxis: { title: \"x\" },\n      yaxis: { title: \"Solution\" },\n      margin: { l: 70, r: 40, t: 50, b: 50 },\n    };\n\n    Plotly.newPlot(plotDivId, [lineData], layout, { responsive: true });\n  } else if (meshDimension === \"2D\" && plotType === \"contour\") {\n    // Use the user-provided mesh type\n    const isStructured = meshType === \"structured\";\n    \n    // For auto-detection (if needed)\n    const uniqueXCoords = new Set(nodesXCoordinates).size;\n    const uniqueYCoords = new Set(nodesYCoordinates).size;\n    \n    // Extract scalar values from solution vector\n    let zValues;\n    if (Array.isArray(solutionVector[0])) {\n      zValues = solutionVector.map(val => val[0]);\n    } else {\n      zValues = solutionVector;\n    }\n    \n    // Common sizing parameters for both plot types\n    let maxWindowWidth = Math.min(window.innerWidth, 700);\n    let maxX = Math.max(...nodesXCoordinates);\n    let maxY = Math.max(...nodesYCoordinates);\n    let aspectRatio = maxY / maxX;\n    let plotWidth = Math.min(maxWindowWidth, 600);\n    let plotHeight = plotWidth * aspectRatio * 0.8; // Slightly reduce height for better appearance\n    \n    // Common layout properties\n    let layout = {\n      title: `${plotType} plot - ${solverConfig}`,\n      width: plotWidth,\n      height: plotHeight,\n      xaxis: { title: \"x\" },\n      yaxis: { title: \"y\" },\n      margin: { l: 50, r: 50, t: 50, b: 50 },\n      hovermode: 'closest'\n    };\n    \n    if (isStructured) {\n      // Calculate the number of nodes along the x-axis and y-axis\n      const numNodesX = uniqueXCoords;\n      const numNodesY = uniqueYCoords;\n\n      // Reshape the nodesXCoordinates and nodesYCoordinates arrays to match the grid dimensions\n      let reshapedXCoordinates = math.reshape(Array.from(nodesXCoordinates), [numNodesX, numNodesY]);\n      let reshapedYCoordinates = math.reshape(Array.from(nodesYCoordinates), [numNodesX, numNodesY]);\n\n      // Reshape the solution array to match the grid dimensions\n      let reshapedSolution = math.reshape(Array.from(solutionVector), [numNodesX, numNodesY]);\n\n      // Transpose the reshapedSolution array to get column-wise data\n      let transposedSolution = math.transpose(reshapedSolution);\n\n      // Create an array for x-coordinates used in the contour plot\n      let reshapedXForPlot = [];\n      for (let i = 0; i < numNodesX * numNodesY; i += numNodesY) {\n        let xValue = nodesXCoordinates[i];\n        reshapedXForPlot.push(xValue);\n      }\n\n      // Create the data structure for the contour plot\n      let contourData = {\n        z: transposedSolution,\n        type: \"contour\",\n        contours: {\n          coloring: \"heatmap\",\n          showlabels: false\n        },\n        //colorscale: 'Viridis',\n        colorbar: {\n          title: 'Solution'\n        },\n        x: reshapedXForPlot,\n        y: reshapedYCoordinates[0],\n        name: 'Solution Field'\n      };\n\n      // Create the plot using Plotly\n      Plotly.newPlot(plotDivId, [contourData], layout, { responsive: true });\n    } else {\n      // Create an interpolated contour plot for the unstructured mesh\n      let contourData = {\n        x: nodesXCoordinates,\n        y: nodesYCoordinates,\n        z: zValues,\n        type: 'contour',\n        contours: {\n          coloring: 'heatmap',\n          showlabels: false\n        },\n        //colorscale: 'Viridis',\n        colorbar: {\n          title: 'Solution'\n        },\n        name: 'Solution Field'\n      };\n      \n      // Create the plot using only the contour fill\n      Plotly.newPlot(plotDivId, [contourData], layout, { responsive: true });\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    [\"proxy\", proxyTransferHandler],\n    [\"throw\", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case \"GET\" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction wrap(ep, target) {\n    const pendingListeners = new Map();\n    ep.addEventListener(\"message\", function handleMessage(ev) {\n        const { data } = ev;\n        if (!data || !data.id) {\n            return;\n        }\n        const resolver = pendingListeners.get(data.id);\n        if (!resolver) {\n            return;\n        }\n        try {\n            resolver(data);\n        }\n        finally {\n            pendingListeners.delete(data.id);\n        }\n    });\n    return createProxy(ep, pendingListeners, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, new Map(), {\n        type: \"RELEASE\" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, pendingListeners, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    pendingListeners.clear();\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, pendingListeners, {\n                    type: \"GET\" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, pendingListeners, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously Â¯\\_(ãƒ„)_/Â¯\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"SET\" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, pendingListeners, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didnâ€™t happen.\n            if (last === \"bind\") {\n                return createProxy(ep, pendingListeners, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"APPLY\" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, pendingListeners, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case \"HANDLER\" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, pendingListeners, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        pendingListeners.set(id, resolve);\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join(\"-\");\n}\n\nexport { createEndpoint, expose, finalizer, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\n// External imports\nimport * as Comlink from \"../vendor/comlink.mjs\";\n\n// Internal imports\nimport { basicLog } from \"../utilities/loggingScript.js\";\n\n/**\n * Class to facilitate communication with web workers for FEAScript operations\n */\nexport class FEAScriptWorker {\n  /**\n   * Constructor to initialize the FEAScriptWorker class\n   * Sets up the worker and initializes the workerWrapper.\n   */\n  constructor() {\n    this.worker = null;\n    this.feaWorker = null;\n    this.isReady = false;\n\n    this._initWorker();\n  }\n\n  /**\n   * Function to initialize the web worker and wrap it using Comlink.\n   * @private\n   * @throws Will throw an error if the worker fails to initialize.\n   */\n  async _initWorker() {\n    try {\n      this.worker = new Worker(new URL(\"./wrapperScript.js\", import.meta.url), {\n        type: \"module\",\n      });\n\n      this.worker.onerror = (event) => {\n        console.error(\"FEAScriptWorker: Worker error:\", event);\n      };\n      const workerWrapper = Comlink.wrap(this.worker);\n\n      this.feaWorker = await new workerWrapper();\n\n      this.isReady = true;\n    } catch (error) {\n      console.error(\"Failed to initialize worker\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Function to ensure that the worker is ready before performing any operations.\n   * @private\n   * @returns {Promise<void>} Resolves when the worker is ready.\n   * @throws Will throw an error if the worker is not ready within the timeout period.\n   */\n  async _ensureReady() {\n    if (this.isReady) return Promise.resolve();\n\n    return new Promise((resolve, reject) => {\n      let attempts = 0;\n      const maxAttempts = 50; // 5 seconds max\n\n      const checkReady = () => {\n        attempts++;\n        if (this.isReady) {\n          resolve();\n        } else if (attempts >= maxAttempts) {\n          reject(new Error(\"Timeout waiting for worker to be ready\"));\n        } else {\n          setTimeout(checkReady, 1000);\n        }\n      };\n      checkReady();\n    });\n  }\n\n  /**\n   * Function to set the solver configuration in the worker.\n   * @param {string} solverConfig - The solver configuration to set.\n   * @returns {Promise<boolean>} Resolves when the configuration is set.\n   */\n  async setSolverConfig(solverConfig) {\n    await this._ensureReady();\n    basicLog(`FEAScriptWorker: Setting solver config to: ${solverConfig}`);\n    return this.feaWorker.setSolverConfig(solverConfig);\n  }\n\n  /**\n   * Sets the mesh configuration in the worker.\n   * @param {object} meshConfig - The mesh configuration to set.\n   * @returns {Promise<boolean>} Resolves when the configuration is set.\n   */\n  async setMeshConfig(meshConfig) {\n    await this._ensureReady();\n    basicLog(`FEAScriptWorker: Setting mesh config`);\n    return this.feaWorker.setMeshConfig(meshConfig);\n  }\n\n  /**\n   * Adds a boundary condition to the worker.\n   * @param {string} boundaryKey - The key identifying the boundary.\n   * @param {array} condition - The boundary condition to add.\n   * @returns {Promise<boolean>} Resolves when the boundary condition is added.\n   */\n  async addBoundaryCondition(boundaryKey, condition) {\n    await this._ensureReady();\n    basicLog(`FEAScriptWorker: Adding boundary condition for boundary: ${boundaryKey}`);\n    return this.feaWorker.addBoundaryCondition(boundaryKey, condition);\n  }\n\n  /**\n   * Sets the solver method in the worker.\n   * @param {string} solverMethod - The solver method to set.\n   * @returns {Promise<boolean>} Resolves when the solver method is set.\n   */\n  async setSolverMethod(solverMethod) {\n    await this._ensureReady();\n    basicLog(`FEAScriptWorker: Setting solver method to: ${solverMethod}`);\n    return this.feaWorker.setSolverMethod(solverMethod);\n  }\n\n  /**\n   * Requests the worker to solve the problem.\n   * @returns {Promise<object>} Resolves with the solution result.\n   */\n  async solve() {\n    await this._ensureReady();\n    basicLog(\"FEAScriptWorker: Requesting solution from worker...\");\n\n    const startTime = performance.now();\n    const result = await this.feaWorker.solve();\n    const endTime = performance.now();\n\n    basicLog(`FEAScriptWorker: Solution completed in ${((endTime - startTime) / 1000).toFixed(2)}s`);\n    return result;\n  }\n\n  /**\n   * Retrieves model information from the worker.\n   * @returns {Promise<object>} Resolves with the model information.\n   */\n  async getModelInfo() {\n    await this._ensureReady();\n    return this.feaWorker.getModelInfo();\n  }\n\n  /**\n   * Sends a ping request to the worker to check its availability.\n   * @returns {Promise<boolean>} Resolves if the worker responds.\n   */\n  async ping() {\n    await this._ensureReady();\n    return this.feaWorker.ping();\n  }\n\n  /**\n   * Terminates the worker and cleans up resources.\n   */\n  terminate() {\n    if (this.worker) {\n      this.worker.terminate();\n      this.worker = null;\n      this.feaWorker = null;\n      this.isReady = false;\n    }\n  }\n}\n","//   ______ ______           _____           _       _     //\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\n//                                            | |   | |    //\n//                                            |_|   | |_   //\n//       Website: https://feascript.com/             \\__|  //\n\nexport { FEAScriptModel } from \"./FEAScript.js\";\nexport { importGmshQuadTri } from \"./readers/gmshReaderScript.js\";\nexport { logSystem, printVersion } from \"./utilities/loggingScript.js\";\nexport { plotSolution } from \"./visualization/plotSolutionScript.js\";\nexport { FEAScriptWorker } from \"./workers/workerScript.js\";\nexport const VERSION = \"0.1.3\";"],"names":["euclideanNorm","vector","norm","i","length","Math","sqrt","currentLogLevel","logSystem","level","console","log","basicLog","debugLog","message","errorLog","async","printVersion","commitResponse","fetch","commitData","json","latestCommitDate","Date","commit","committer","date","toLocaleString","error","conjugateGradientCPU","jacobianMatrix","residualVector","initialGuess","options","maxIterations","tolerance","n","x","r","computeResidual","p","rsold","dotProduct","iteration","converged","Ap","matrixVectorProduct","pAp","abs","alpha","Number","rsnew","residualNorm","toExponential","beta","finalResidualNorm","solutionVector","iterations","A","b","Array","sum","j","v","result","u","solveLinearSystem","solverMethod","time","math","lusolve","jacobiSolverResult","xNew","maxDiff","max","jacobiSolver","fill","cgTolerance","min","cgResult","enablePrecision","navigator","gpu","adapter","requestAdapter","requestDevice","conjugateGradientWebGPU","timeEnd","newtonRaphson","assembleMat","context","errorNorm","deltaX","nodesCoordinates","totalNodes","meshConfig","meshDimension","numElementsX","numElementsY","elementOrder","parsedMesh","nodesXCoordinates","nodesX","nodesY","calculateSystemSize","initialSolution","boundaryConditions","eikonalActivationFlag","GenericBoundaryConditions","constructor","boundaryElements","nop","this","imposeConstantValueBoundaryConditions","Object","keys","forEach","boundaryKey","value","elementIndex","side","nodeIndex","globalNodeIndex","colIndex","BasisFunctions","getBasisFunctions","ksi","eta","basisFunction","basisFunctionDerivKsi","basisFunctionDerivEta","l1","c","l2","l3","dl1","dl2","dl3","Mesh","maxX","maxY","boundaryElementsProcessed","parseMeshFromGmsh","nodalNumbering","isArray","quadElements","triangleElements","JSON","stringify","elementTypes","mappedNodalNumbering","elemIdx","gmshNodes","feaScriptNodes","push","physicalPropMap","undefined","fixedBoundaryElements","boundaryNodePairs","prop","dimension","tag","nodesPair","node1","node2","name","foundElement","elemNodes","includes","node1Index","indexOf","node2Index","join","Mesh1D","super","generateMesh","totalNodesX","generate1DNodalNumbering","findBoundaryElements","columnCounter","sideIndex","Mesh2D","nodesYCoordinates","totalNodesY","deltaY","nodeIndexY","nodeIndexX","nnode","generate2DNodalNumbering","rowCounter","elementIndexX","elementIndexY","nodeIndex1","nodeIndex2","NumericalIntegration","getGaussPointsAndWeights","gaussPoints","gaussWeights","assembleFrontPropagationMat","eikonalViscousTerm","mesh","nodesCoordinatesAndNumbering","totalElements","xCoordinates","yCoordinates","ksiDerivX","etaDerivX","ksiDerivY","etaDerivY","detJacobian","solutionDerivX","solutionDerivY","localToGlobalMap","basisFunctionDerivX","basisFunctionDerivY","basisFunctions","gaussPointsAndWeights","numNodes","localNodeIndex","gaussPointIndex1","basisFunctionsAndDerivatives","gaussPointIndex2","localNodeIndex1","localToGlobalMap1","localNodeIndex2","localToGlobalMap2","ThermalBoundaryConditions","imposeConstantTempBoundaryConditions","tempValue","imposeConvectionBoundaryConditions","convectionHeatTranfCoeff","convectionExtTemp","key","boundaryCondition","convectionCoeff","extTemp","gaussPoint1","gaussPoint2","firstNodeIndex","lastNodeIndex","nodeIncrement","tangentVectorLength","globalNodeIndex2","gaussPointIndex","FEAScriptModel","solverConfig","setSolverConfig","setMeshConfig","addBoundaryCondition","condition","setSolverMethod","solve","Error","thermalBoundaryConditions","assembleSolidHeatTransferMat","newtonRaphsonResult","importGmshQuadTri","file","gmshV","ascii","fltBytes","lines","text","split","map","line","trim","filter","section","lineIndex","nodeEntityBlocks","nodeBlocksProcessed","currentNodeBlock","nodeTagsCollected","nodeTags","nodeCoordinatesCollected","elementEntityBlocks","elementBlocksProcessed","currentElementBlock","dim","elementType","numElements","elementsProcessedInBlock","boundaryElementsByTag","parts","part","parseFloat","test","parseInt","slice","replace","parametric","nodeTag","y","nodeIndices","idx","physicalTag","boundaryNodes","nodes","plotSolution","plotType","plotDivId","meshType","yData","arr","xData","from","lineData","mode","type","color","width","maxWindowWidth","window","innerWidth","maxPlotWidth","zoomFactor","layout","title","height","xaxis","yaxis","margin","l","t","Plotly","newPlot","responsive","isStructured","uniqueXCoords","Set","size","uniqueYCoords","zValues","val","aspectRatio","plotWidth","hovermode","numNodesX","numNodesY","reshape","reshapedYCoordinates","reshapedSolution","transposedSolution","transpose","reshapedXForPlot","xValue","contourData","z","contours","coloring","showlabels","colorbar","proxyMarker","Symbol","createEndpoint","releaseProxy","finalizer","throwMarker","isObject","transferHandlers","Map","canHandle","serialize","obj","port1","port2","MessageChannel","expose","deserialize","port","start","wrap","serialized","isError","stack","assign","ep","globalThis","allowedOrigins","addEventListener","callback","ev","data","origin","allowedOrigin","RegExp","isAllowedOrigin","warn","id","path","argumentList","fromWireValue","returnValue","parent","reduce","rawValue","apply","proxy","transfers","transferCache","set","transfer","Promise","resolve","catch","then","wireValue","transferables","toWireValue","postMessage","removeEventListener","closeEndPoint","TypeError","endpoint","isMessagePort","close","target","pendingListeners","resolver","get","delete","createProxy","throwIfProxyReleased","isReleased","releaseEndpoint","requestResponseMessage","proxyCounter","WeakMap","proxyFinalizers","FinalizationRegistry","newCount","isProxyReleased","Proxy","_target","unregister","unregisterProxy","clear","toString","bind","_thisArg","rawArgumentList","last","processArguments","construct","register","registerProxy","processed","prototype","concat","handler","serializedValue","msg","floor","random","MAX_SAFE_INTEGER","FEAScriptWorker","worker","feaWorker","isReady","_initWorker","Worker","URL","url","onerror","event","workerWrapper","Comlink.wrap","_ensureReady","reject","attempts","checkReady","setTimeout","startTime","performance","now","toFixed","getModelInfo","ping","terminate","VERSION"],"mappings":"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"}