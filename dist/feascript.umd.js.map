{"version":3,"file":"feascript.umd.js","sources":["../src/methods/numericalIntegrationScript.js","../src/utilities/loggingScript.js","../src/mesh/basisFunctionsScript.js","../src/mesh/meshGenerationScript.js","../src/solvers/thermalBoundaryConditionsScript.js","../src/vendor/comlink.mjs","../src/FEAScript.js","../src/solvers/solidHeatTransferScript.js","../src/methods/jacobiMethodScript.js","../src/workers/workerScript.js","../src/readers/gmshReaderScript.js","../src/visualization/plotSolutionScript.js"],"sourcesContent":["//   ______ ______           _____           _       _     //\r\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\r\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\r\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\r\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\r\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\r\n//                                            | |   | |    //\r\n//                                            |_|   | |_   //\r\n//       Website: https://feascript.com/             \\__|  //\r\n\r\n/**\r\n * Class to handle numerical integration using Gauss quadrature\r\n */\r\nexport class numericalIntegration {\r\n  /**\r\n   * Constructor to initialize the numericalIntegration class\r\n   * @param {string} meshDimension - The dimension of the mesh\r\n   * @param {string} elementOrder - The order of elements\r\n   */\r\n  constructor({ meshDimension, elementOrder }) {\r\n    this.meshDimension = meshDimension;\r\n    this.elementOrder = elementOrder;\r\n  }\r\n\r\n  /**\r\n   * Function to return Gauss points and weights based on element configuration\r\n   * @returns {object} An object containing:\r\n   *  - gaussPoints: Array of Gauss points\r\n   *  - gaussWeights: Array of Gauss weights\r\n   */\r\n  getGaussPointsAndWeights() {\r\n    let gaussPoints = []; // Gauss points\r\n    let gaussWeights = []; // Gauss weights\r\n\r\n    if (this.elementOrder === \"linear\") {\r\n      // For linear elements, use 1-point Gauss quadrature\r\n      gaussPoints[0] = 0.5;\r\n      gaussWeights[0] = 1;\r\n    } else if (this.elementOrder === \"quadratic\") {\r\n      // For quadratic elements, use 3-point Gauss quadrature\r\n      gaussPoints[0] = (1 - Math.sqrt(3 / 5)) / 2;\r\n      gaussPoints[1] = 0.5;\r\n      gaussPoints[2] = (1 + Math.sqrt(3 / 5)) / 2;\r\n      gaussWeights[0] = 5 / 18;\r\n      gaussWeights[1] = 8 / 18;\r\n      gaussWeights[2] = 5 / 18;\r\n    }\r\n\r\n    return { gaussPoints, gaussWeights };\r\n  }\r\n}\r\n","//   ______ ______           _____           _       _     //\r\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\r\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\r\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\r\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\r\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\r\n//                                            | |   | |    //\r\n//                                            |_|   | |_   //\r\n//       Website: https://feascript.com/             \\__|  //\r\n\r\n// Global logging level\r\nlet currentLogLevel = \"basic\";\r\n\r\n/**\r\n * Function to set the logging system level\r\n * @param {string} level - Logging level (basic, debug)\r\n */\r\nexport function logSystem(level) {\r\n  if (level !== \"basic\" && level !== \"debug\") {\r\n    console.log(\r\n      \"%c[WARN] Invalid log level: \" + level + \". Using basic instead.\",\r\n      \"color: #FFC107; font-weight: bold;\"\r\n    ); // Yellow for warnings\r\n    currentLogLevel = \"basic\";\r\n  } else {\r\n    currentLogLevel = level;\r\n    basicLog(`Log level set to: ${level}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Function to log debug messages - only logs if level is 'debug'\r\n * @param {string} message - Message to log\r\n */\r\nexport function debugLog(message) {\r\n  if (currentLogLevel === \"debug\") {\r\n    console.log(\"%c[DEBUG] \" + message, \"color: #2196F3; font-weight: bold;\"); // Blue color for debug\r\n  }\r\n}\r\n\r\n/**\r\n * Function to log basic information - always logs\r\n * @param {string} message - Message to log\r\n */\r\nexport function basicLog(message) {\r\n  console.log(\"%c[INFO] \" + message, \"color: #4CAF50; font-weight: bold;\"); // Green color for basic info\r\n}\r\n\r\n/**\r\n * Function to log error messages\r\n * @param {string} message - Message to log\r\n */\r\nexport function errorLog(message) {\r\n  console.log(\"%c[ERROR] \" + message, \"color: #F44336; font-weight: bold;\"); // Red color for errors\r\n}\r\n\r\n/**\r\n * Function to handle version information and fetch the latest update date and release from GitHub\r\n */\r\nexport async function printVersion() {\r\n  basicLog(\"Fetching latest FEAScript version information...\");\r\n  try {\r\n    const commitResponse = await fetch(\"https://api.github.com/repos/FEAScript/FEAScript/commits/main\");\r\n    const commitData = await commitResponse.json();\r\n    const latestCommitDate = new Date(commitData.commit.committer.date).toLocaleString();\r\n    basicLog(`Latest FEAScript update: ${latestCommitDate}`);\r\n    return latestCommitDate;\r\n  } catch (error) {\r\n    errorLog(\"Failed to fetch version information: \" + error);\r\n    return \"Version information unavailable\";\r\n  }\r\n}\r\n","//   ______ ______           _____           _       _     //\r\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\r\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\r\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\r\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\r\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\r\n//                                            | |   | |    //\r\n//                                            |_|   | |_   //\r\n//       Website: https://feascript.com/             \\__|  //\r\n\r\n// Internal imports\r\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\r\n\r\n/**\r\n * Class to handle basis functions and their derivatives based on element configuration\r\n */\r\nexport class basisFunctions {\r\n  /**\r\n   * Constructor to initialize the basisFunctions class\r\n   * @param {string} meshDimension - The dimension of the mesh\r\n   * @param {string} elementOrder - The order of elements\r\n   */\r\n  constructor({ meshDimension, elementOrder }) {\r\n    this.meshDimension = meshDimension;\r\n    this.elementOrder = elementOrder;\r\n  }\r\n\r\n  /**\r\n   * Function to calculate basis functions and their derivatives based on the dimension and order\r\n   * @param {number} ksi - Natural coordinate (for both 1D and 2D)\r\n   * @param {number} [eta] - Second natural coordinate (only for 2D elements)\r\n   * @returns {object} An object containing:\r\n   *  - basisFunction: Array of evaluated basis functions\r\n   *  - basisFunctionDerivKsi: Array of derivatives of basis functions with respect to ksi\r\n   *  - basisFunctionDerivEta: Array of derivatives of basis functions with respect to eta (only for 2D elements)\r\n   */\r\n  getBasisFunctions(ksi, eta = null) {\r\n    let basisFunction = [];\r\n    let basisFunctionDerivKsi = [];\r\n    let basisFunctionDerivEta = [];\r\n\r\n    if (this.meshDimension === \"1D\") {\r\n      if (this.elementOrder === \"linear\") {\r\n        // Linear basis functions for 1D elements\r\n        basisFunction[0] = 1 - ksi;\r\n        basisFunction[1] = ksi;\r\n\r\n        // Derivatives of basis functions with respect to ksi\r\n        basisFunctionDerivKsi[0] = -1;\r\n        basisFunctionDerivKsi[1] = 1;\r\n      } else if (this.elementOrder === \"quadratic\") {\r\n        // Quadratic basis functions for 1D elements\r\n        basisFunction[0] = 1 - 3 * ksi + 2 * ksi ** 2;\r\n        basisFunction[1] = 4 * ksi - 4 * ksi ** 2;\r\n        basisFunction[2] = -ksi + 2 * ksi ** 2;\r\n\r\n        // Derivatives of basis functions with respect to ksi\r\n        basisFunctionDerivKsi[0] = -3 + 4 * ksi;\r\n        basisFunctionDerivKsi[1] = 4 - 8 * ksi;\r\n        basisFunctionDerivKsi[2] = -1 + 4 * ksi;\r\n      }\r\n    } else if (this.meshDimension === \"2D\") {\r\n      if (eta === null) {\r\n        errorLog(\"Eta coordinate is required for 2D elements\");\r\n        return;\r\n      }\r\n\r\n      if (this.elementOrder === \"linear\") {\r\n        // Linear basis functions for 2D elements\r\n        function l1(c) {\r\n          return 1 - c;\r\n        }\r\n        function l2(c) {\r\n          return c;\r\n        }\r\n        function dl1() {\r\n          return -1;\r\n        }\r\n        function dl2() {\r\n          return 1;\r\n        }\r\n\r\n        // Evaluate basis functions at (ksi, eta)\r\n        basisFunction[0] = l1(ksi) * l1(eta);\r\n        basisFunction[1] = l1(ksi) * l2(eta);\r\n        basisFunction[2] = l2(ksi) * l1(eta);\r\n        basisFunction[3] = l2(ksi) * l2(eta);\r\n\r\n        // Derivatives with respect to ksi\r\n        basisFunctionDerivKsi[0] = dl1() * l1(eta);\r\n        basisFunctionDerivKsi[1] = dl1() * l2(eta);\r\n        basisFunctionDerivKsi[2] = dl2() * l1(eta);\r\n        basisFunctionDerivKsi[3] = dl2() * l2(eta);\r\n\r\n        // Derivatives with respect to eta\r\n        basisFunctionDerivEta[0] = l1(ksi) * dl1();\r\n        basisFunctionDerivEta[1] = l1(ksi) * dl2();\r\n        basisFunctionDerivEta[2] = l2(ksi) * dl1();\r\n        basisFunctionDerivEta[3] = l2(ksi) * dl2();\r\n      } else if (this.elementOrder === \"quadratic\") {\r\n        // Quadratic basis functions for 2D elements\r\n        function l1(c) {\r\n          return 2 * c ** 2 - 3 * c + 1;\r\n        }\r\n        function l2(c) {\r\n          return -4 * c ** 2 + 4 * c;\r\n        }\r\n        function l3(c) {\r\n          return 2 * c ** 2 - c;\r\n        }\r\n        function dl1(c) {\r\n          return 4 * c - 3;\r\n        }\r\n        function dl2(c) {\r\n          return -8 * c + 4;\r\n        }\r\n        function dl3(c) {\r\n          return 4 * c - 1;\r\n        }\r\n\r\n        // Evaluate basis functions at (ksi, eta)\r\n        basisFunction[0] = l1(ksi) * l1(eta);\r\n        basisFunction[1] = l1(ksi) * l2(eta);\r\n        basisFunction[2] = l1(ksi) * l3(eta);\r\n        basisFunction[3] = l2(ksi) * l1(eta);\r\n        basisFunction[4] = l2(ksi) * l2(eta);\r\n        basisFunction[5] = l2(ksi) * l3(eta);\r\n        basisFunction[6] = l3(ksi) * l1(eta);\r\n        basisFunction[7] = l3(ksi) * l2(eta);\r\n        basisFunction[8] = l3(ksi) * l3(eta);\r\n\r\n        // Derivatives with respect to ksi\r\n        basisFunctionDerivKsi[0] = dl1(ksi) * l1(eta);\r\n        basisFunctionDerivKsi[1] = dl1(ksi) * l2(eta);\r\n        basisFunctionDerivKsi[2] = dl1(ksi) * l3(eta);\r\n        basisFunctionDerivKsi[3] = dl2(ksi) * l1(eta);\r\n        basisFunctionDerivKsi[4] = dl2(ksi) * l2(eta);\r\n        basisFunctionDerivKsi[5] = dl2(ksi) * l3(eta);\r\n        basisFunctionDerivKsi[6] = dl3(ksi) * l1(eta);\r\n        basisFunctionDerivKsi[7] = dl3(ksi) * l2(eta);\r\n        basisFunctionDerivKsi[8] = dl3(ksi) * l3(eta);\r\n\r\n        // Derivatives with respect to eta\r\n        basisFunctionDerivEta[0] = l1(ksi) * dl1(eta);\r\n        basisFunctionDerivEta[1] = l1(ksi) * dl2(eta);\r\n        basisFunctionDerivEta[2] = l1(ksi) * dl3(eta);\r\n        basisFunctionDerivEta[3] = l2(ksi) * dl1(eta);\r\n        basisFunctionDerivEta[4] = l2(ksi) * dl2(eta);\r\n        basisFunctionDerivEta[5] = l2(ksi) * dl3(eta);\r\n        basisFunctionDerivEta[6] = l3(ksi) * dl1(eta);\r\n        basisFunctionDerivEta[7] = l3(ksi) * dl2(eta);\r\n        basisFunctionDerivEta[8] = l3(ksi) * dl3(eta);\r\n      }\r\n    }\r\n\r\n    return { basisFunction, basisFunctionDerivKsi, basisFunctionDerivEta };\r\n  }\r\n}\r\n","//   ______ ______           _____           _       _     //\r\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\r\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\r\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\r\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\r\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\r\n//                                            | |   | |    //\r\n//                                            |_|   | |_   //\r\n//       Website: https://feascript.com/             \\__|  //\r\n\r\n// Internal imports\r\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\r\n\r\n/**\r\n * Class to handle the generation of structured finite element meshes\r\n */\r\nexport class meshGeneration {\r\n  /**\r\n   * Constructor to initialize the meshGeneration class\r\n   * @param {object} config - Configuration object for the mesh\r\n   * @param {number} [config.numElementsX] - Number of elements along the x-axis (required for geometry-based mesh)\r\n   * @param {number} [config.maxX] - Maximum x-coordinate of the mesh (required for geometry-based mesh)\r\n   * @param {number} [config.numElementsY=1] - Number of elements along the y-axis (for 1D meshes)\r\n   * @param {number} [config.maxY=0] - Maximum y-coordinate of the mesh (for 1D meshes)\r\n   * @param {string} [config.meshDimension='2D'] - The dimension of the mesh, either 1D or 2D\r\n   * @param {string} [config.elementOrder='linear'] - The order of elements, either 'linear' or 'quadratic'\r\n   * @param {object} [config.parsedMesh=null] - Optional pre-parsed mesh data\r\n   */\r\n  constructor({\r\n    numElementsX = null,\r\n    maxX = null,\r\n    numElementsY = null,\r\n    maxY = null,\r\n    meshDimension = null,\r\n    elementOrder = \"linear\",\r\n    parsedMesh = null,\r\n  }) {\r\n    this.numElementsX = numElementsX;\r\n    this.numElementsY = numElementsY;\r\n    this.maxX = maxX;\r\n    this.maxY = maxY;\r\n    this.meshDimension = meshDimension;\r\n    this.elementOrder = elementOrder;\r\n    this.parsedMesh = parsedMesh;\r\n  }\r\n\r\n  /**\r\n   * Function to generate the mesh based on the dimension or use a pre-parsed mesh\r\n   * @returns {object} The generated mesh containing node coordinates and total nodes\r\n   */\r\n  generateMesh() {\r\n    // If pre-parsed mesh data is provided, use it directly\r\n    if (this.parsedMesh) {\r\n      // Process the nodalNumbering from gmshReader format to the format expected by the solver\r\n      if (this.parsedMesh.nodalNumbering) {\r\n        if (\r\n          typeof this.parsedMesh.nodalNumbering === \"object\" &&\r\n          !Array.isArray(this.parsedMesh.nodalNumbering)\r\n        ) {\r\n          // Store the nodal numbering structure before converting\r\n          const quadElements = this.parsedMesh.nodalNumbering.quadElements || [];\r\n          const triangleElements = this.parsedMesh.nodalNumbering.triangleElements || [];\r\n\r\n          debugLog(\r\n            \"Initial parsed mesh nodal numbering from GMSH format: \" +\r\n              JSON.stringify(this.parsedMesh.nodalNumbering)\r\n          );\r\n\r\n          // Check if it has quadElements or triangleElements structure from gmshReader\r\n          if (this.parsedMesh.elementTypes[3] || this.parsedMesh.elementTypes[10]) {\r\n            // Map nodal numbering from GMSH format to FEAScript format for quad elements\r\n            const mappedNodalNumbering = [];\r\n\r\n            for (let elemIdx = 0; elemIdx < quadElements.length; elemIdx++) {\r\n              const gmshNodes = quadElements[elemIdx];\r\n              const feaScriptNodes = new Array(gmshNodes.length);\r\n\r\n              // Check for element type based on number of nodes\r\n              if (gmshNodes.length === 4) {\r\n                // Simple mapping for linear quad elements (4 nodes)\r\n                // GMSH:         FEAScript:\r\n                // 3 --- 2       1 --- 3\r\n                // |     |  -->  |     |\r\n                // 0 --- 1       0 --- 2\r\n\r\n                feaScriptNodes[0] = gmshNodes[0]; // 0 -> 0\r\n                feaScriptNodes[1] = gmshNodes[3]; // 3 -> 1\r\n                feaScriptNodes[2] = gmshNodes[1]; // 1 -> 2\r\n                feaScriptNodes[3] = gmshNodes[2]; // 2 -> 3\r\n              } else if (gmshNodes.length === 9) {\r\n                // Mapping for quadratic quad elements (9 nodes)\r\n                // GMSH:         FEAScript:\r\n                // 3--6--2       2--5--8\r\n                // |     |       |     |\r\n                // 7  8  5  -->  1  4  7\r\n                // |     |       |     |\r\n                // 0--4--1       0--3--6\r\n\r\n                feaScriptNodes[0] = gmshNodes[0]; // 0 -> 0\r\n                feaScriptNodes[1] = gmshNodes[7]; // 7 -> 1\r\n                feaScriptNodes[2] = gmshNodes[3]; // 3 -> 2\r\n                feaScriptNodes[3] = gmshNodes[4]; // 4 -> 3\r\n                feaScriptNodes[4] = gmshNodes[8]; // 8 -> 4\r\n                feaScriptNodes[5] = gmshNodes[6]; // 6 -> 5\r\n                feaScriptNodes[6] = gmshNodes[1]; // 1 -> 6\r\n                feaScriptNodes[7] = gmshNodes[5]; // 5 -> 7\r\n                feaScriptNodes[8] = gmshNodes[2]; // 2 -> 8\r\n              }\r\n\r\n              mappedNodalNumbering.push(feaScriptNodes);\r\n            }\r\n\r\n            this.parsedMesh.nodalNumbering = mappedNodalNumbering;\r\n          } else if (this.parsedMesh.elementTypes[2]) {\r\n          }\r\n\r\n          debugLog(\r\n            \"Nodal numbering after mapping from GMSH to FEAScript format: \" +\r\n              JSON.stringify(this.parsedMesh.nodalNumbering)\r\n          );\r\n\r\n          // Process boundary elements if they exist and if physical property mapping exists\r\n          if (this.parsedMesh.physicalPropMap && this.parsedMesh.boundaryElements) {\r\n            // Check if boundary elements need to be processed\r\n            if (\r\n              Array.isArray(this.parsedMesh.boundaryElements) &&\r\n              this.parsedMesh.boundaryElements.length > 0 &&\r\n              this.parsedMesh.boundaryElements[0] === undefined\r\n            ) {\r\n              // Create a new array without the empty first element\r\n              const fixedBoundaryElements = [];\r\n              for (let i = 1; i < this.parsedMesh.boundaryElements.length; i++) {\r\n                if (this.parsedMesh.boundaryElements[i]) {\r\n                  fixedBoundaryElements.push(this.parsedMesh.boundaryElements[i]);\r\n                }\r\n              }\r\n              this.parsedMesh.boundaryElements = fixedBoundaryElements;\r\n            }\r\n\r\n            // If boundary node pairs exist but boundary elements haven't been processed\r\n            if (this.parsedMesh.boundaryNodePairs && !this.parsedMesh.boundaryElementsProcessed) {\r\n              // Reset boundary elements array\r\n              this.parsedMesh.boundaryElements = [];\r\n\r\n              // Process each physical property from the Gmsh file\r\n              this.parsedMesh.physicalPropMap.forEach((prop) => {\r\n                // Only process 1D physical entities (boundary lines)\r\n                if (prop.dimension === 1) {\r\n                  // Get all node pairs for this boundary\r\n                  const boundaryNodePairs = this.parsedMesh.boundaryNodePairs[prop.tag] || [];\r\n\r\n                  if (boundaryNodePairs.length > 0) {\r\n                    // Initialize array for this boundary tag\r\n                    if (!this.parsedMesh.boundaryElements[prop.tag]) {\r\n                      this.parsedMesh.boundaryElements[prop.tag] = [];\r\n                    }\r\n\r\n                    // For each boundary line segment (defined by a pair of nodes)\r\n                    boundaryNodePairs.forEach((nodesPair) => {\r\n                      const node1 = nodesPair[0]; // First node in the pair\r\n                      const node2 = nodesPair[1]; // Second node in the pair\r\n\r\n                      debugLog(\r\n                        `Processing boundary node pair: [${node1}, ${node2}] for boundary ${prop.tag} (${\r\n                          prop.name || \"unnamed\"\r\n                        })`\r\n                      );\r\n\r\n                      // Search through all elements to find which one contains both nodes\r\n                      let foundElement = false;\r\n\r\n                      // Loop through all elements in the mesh\r\n                      for (let elemIdx = 0; elemIdx < this.parsedMesh.nodalNumbering.length; elemIdx++) {\r\n                        const elemNodes = this.parsedMesh.nodalNumbering[elemIdx];\r\n\r\n                        // For linear quadrilateral linear elements (4 nodes)\r\n                        if (elemNodes.length === 4) {\r\n                          // Check if both boundary nodes are in this element\r\n                          if (elemNodes.includes(node1) && elemNodes.includes(node2)) {\r\n                            // Find which side of the element these nodes form\r\n                            let side;\r\n\r\n                            const node1Index = elemNodes.indexOf(node1);\r\n                            const node2Index = elemNodes.indexOf(node2);\r\n\r\n                            debugLog(\r\n                              `  Found element ${elemIdx} containing boundary nodes. Element nodes: [${elemNodes.join(\r\n                                \", \"\r\n                              )}]`\r\n                            );\r\n                            debugLog(\r\n                              `  Node ${node1} is at index ${node1Index}, Node ${node2} is at index ${node2Index} in the element`\r\n                            );\r\n\r\n                            // Based on FEAScript linear quadrilateral numbering:\r\n                            // 1 --- 3\r\n                            // |     |\r\n                            // 0 --- 2\r\n\r\n                            if (\r\n                              (node1Index === 0 && node2Index === 2) ||\r\n                              (node1Index === 2 && node2Index === 0)\r\n                            ) {\r\n                              side = 0; // Bottom side\r\n                              debugLog(`  These nodes form the BOTTOM side (${side}) of element ${elemIdx}`);\r\n                            } else if (\r\n                              (node1Index === 0 && node2Index === 1) ||\r\n                              (node1Index === 1 && node2Index === 0)\r\n                            ) {\r\n                              side = 1; // Left side\r\n                              debugLog(`  These nodes form the LEFT side (${side}) of element ${elemIdx}`);\r\n                            } else if (\r\n                              (node1Index === 1 && node2Index === 3) ||\r\n                              (node1Index === 3 && node2Index === 1)\r\n                            ) {\r\n                              side = 2; // Top side\r\n                              debugLog(`  These nodes form the TOP side (${side}) of element ${elemIdx}`);\r\n                            } else if (\r\n                              (node1Index === 2 && node2Index === 3) ||\r\n                              (node1Index === 3 && node2Index === 2)\r\n                            ) {\r\n                              side = 3; // Right side\r\n                              debugLog(`  These nodes form the RIGHT side (${side}) of element ${elemIdx}`);\r\n                            }\r\n\r\n                            // Add the element and side to the boundary elements array\r\n                            this.parsedMesh.boundaryElements[prop.tag].push([elemIdx, side]);\r\n                            debugLog(\r\n                              `  Added element-side pair [${elemIdx}, ${side}] to boundary tag ${prop.tag}`\r\n                            );\r\n                            foundElement = true;\r\n                            break;\r\n                          }\r\n                        } else if (elemNodes.length === 9) {\r\n                          // For quadratic quadrilateral elements (9 nodes)\r\n                          // Check if both boundary nodes are in this element\r\n                          if (elemNodes.includes(node1) && elemNodes.includes(node2)) {\r\n                            // Find which side of the element these nodes form\r\n                            let side;\r\n\r\n                            const node1Index = elemNodes.indexOf(node1);\r\n                            const node2Index = elemNodes.indexOf(node2);\r\n\r\n                            debugLog(\r\n                              `  Found element ${elemIdx} containing boundary nodes. Element nodes: [${elemNodes.join(\r\n                                \", \"\r\n                              )}]`\r\n                            );\r\n                            debugLog(\r\n                              `  Node ${node1} is at index ${node1Index}, Node ${node2} is at index ${node2Index} in the element`\r\n                            );\r\n\r\n                            // Based on FEAScript quadratic quadrilateral numbering:\r\n                            // 2--5--8\r\n                            // |     |\r\n                            // 1  4  7\r\n                            // |     |\r\n                            // 0--3--6\r\n\r\n                            if (\r\n                              (node1Index === 0 && node2Index === 6) ||\r\n                              (node1Index === 6 && node2Index === 0) ||\r\n                              (node1Index === 0 && node2Index === 3) ||\r\n                              (node1Index === 3 && node2Index === 0) ||\r\n                              (node1Index === 3 && node2Index === 6) ||\r\n                              (node1Index === 6 && node2Index === 3)\r\n                            ) {\r\n                              side = 0; // Bottom side (nodes 0, 3, 6)\r\n                              debugLog(`  These nodes form the BOTTOM side (${side}) of element ${elemIdx}`);\r\n                            } else if (\r\n                              (node1Index === 0 && node2Index === 2) ||\r\n                              (node1Index === 2 && node2Index === 0) ||\r\n                              (node1Index === 0 && node2Index === 1) ||\r\n                              (node1Index === 1 && node2Index === 0) ||\r\n                              (node1Index === 1 && node2Index === 2) ||\r\n                              (node1Index === 2 && node2Index === 1)\r\n                            ) {\r\n                              side = 1; // Left side (nodes 0, 1, 2)\r\n                              debugLog(`  These nodes form the LEFT side (${side}) of element ${elemIdx}`);\r\n                            } else if (\r\n                              (node1Index === 2 && node2Index === 8) ||\r\n                              (node1Index === 8 && node2Index === 2) ||\r\n                              (node1Index === 2 && node2Index === 5) ||\r\n                              (node1Index === 5 && node2Index === 2) ||\r\n                              (node1Index === 5 && node2Index === 8) ||\r\n                              (node1Index === 8 && node2Index === 5)\r\n                            ) {\r\n                              side = 2; // Top side (nodes 2, 5, 8)\r\n                              debugLog(`  These nodes form the TOP side (${side}) of element ${elemIdx}`);\r\n                            } else if (\r\n                              (node1Index === 6 && node2Index === 8) ||\r\n                              (node1Index === 8 && node2Index === 6) ||\r\n                              (node1Index === 6 && node2Index === 7) ||\r\n                              (node1Index === 7 && node2Index === 6) ||\r\n                              (node1Index === 7 && node2Index === 8) ||\r\n                              (node1Index === 8 && node2Index === 7)\r\n                            ) {\r\n                              side = 3; // Right side (nodes 6, 7, 8)\r\n                              debugLog(`  These nodes form the RIGHT side (${side}) of element ${elemIdx}`);\r\n                            }\r\n\r\n                            // Add the element and side to the boundary elements array\r\n                            this.parsedMesh.boundaryElements[prop.tag].push([elemIdx, side]);\r\n                            debugLog(\r\n                              `  Added element-side pair [${elemIdx}, ${side}] to boundary tag ${prop.tag}`\r\n                            );\r\n                            foundElement = true;\r\n                            break;\r\n                          }\r\n                        }\r\n                      }\r\n\r\n                      if (!foundElement) {\r\n                        errorLog(\r\n                          `Could not find element containing boundary nodes ${node1} and ${node2}. Boundary may be incomplete.`\r\n                        );\r\n                      }\r\n                    });\r\n                  }\r\n                }\r\n              });\r\n\r\n              // Mark as processed\r\n              this.parsedMesh.boundaryElementsProcessed = true;\r\n\r\n              // Fix boundary elements array - remove undefined entries\r\n              if (\r\n                this.parsedMesh.boundaryElements.length > 0 &&\r\n                this.parsedMesh.boundaryElements[0] === undefined\r\n              ) {\r\n                const fixedBoundaryElements = [];\r\n                for (let i = 1; i < this.parsedMesh.boundaryElements.length; i++) {\r\n                  if (this.parsedMesh.boundaryElements[i]) {\r\n                    fixedBoundaryElements.push(this.parsedMesh.boundaryElements[i]);\r\n                  }\r\n                }\r\n                this.parsedMesh.boundaryElements = fixedBoundaryElements;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      debugLog(\"Processed boundary elements by tag: \" + JSON.stringify(this.parsedMesh.boundaryElements));\r\n\r\n      return this.parsedMesh;\r\n    } else {\r\n      // Validate required geometry parameters based on mesh dimension\r\n      if (this.meshDimension === \"1D\") {\r\n        if (this.numElementsX === null || this.maxX === null) {\r\n          errorLog(\"numElementsX and maxX are required parameters when generating a 1D mesh from geometry\");\r\n        }\r\n      } else if (this.meshDimension === \"2D\") {\r\n        if (\r\n          this.numElementsX === null ||\r\n          this.maxX === null ||\r\n          this.numElementsY === null ||\r\n          this.maxY === null\r\n        ) {\r\n          errorLog(\r\n            \"numElementsX, maxX, numElementsY, and maxY are required parameters when generating a 2D mesh from geometry\"\r\n          );\r\n        }\r\n      }\r\n\r\n      // Generate mesh based on dimension\r\n      return this.generateMeshFromGeometry();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Function to generate a structured mesh based on the geometry configuration\r\n   * @returns {object} An object containing the coordinates of nodes,\r\n   * total number of nodes, nodal numbering (NOP) array, and boundary elements\r\n   */\r\n  generateMeshFromGeometry() {\r\n    let nodesXCoordinates = [];\r\n    let nodesYCoordinates = [];\r\n    const xStart = 0;\r\n    const yStart = 0;\r\n    let totalNodesX, totalNodesY, deltaX, deltaY;\r\n\r\n    if (this.meshDimension === \"1D\") {\r\n      if (this.elementOrder === \"linear\") {\r\n        totalNodesX = this.numElementsX + 1;\r\n        deltaX = (this.maxX - xStart) / this.numElementsX;\r\n\r\n        nodesXCoordinates[0] = xStart;\r\n        for (let nodeIndex = 1; nodeIndex < totalNodesX; nodeIndex++) {\r\n          nodesXCoordinates[nodeIndex] = nodesXCoordinates[nodeIndex - 1] + deltaX;\r\n        }\r\n      } else if (this.elementOrder === \"quadratic\") {\r\n        totalNodesX = 2 * this.numElementsX + 1;\r\n        deltaX = (this.maxX - xStart) / this.numElementsX;\r\n\r\n        nodesXCoordinates[0] = xStart;\r\n        for (let nodeIndex = 1; nodeIndex < totalNodesX; nodeIndex++) {\r\n          nodesXCoordinates[nodeIndex] = nodesXCoordinates[nodeIndex - 1] + deltaX / 2;\r\n        }\r\n      }\r\n      // Generate nodal numbering (NOP) array\r\n      const nodalNumbering = this.generateNodalNumbering(\r\n        this.numElementsX,\r\n        null, // numElementsY (not used in 1D)\r\n        totalNodesX,\r\n        null, // totalNodesY (not used in 1D)\r\n        this.elementOrder\r\n      );\r\n      // Find boundary elements\r\n      const boundaryElements = this.findBoundaryElements();\r\n\r\n      debugLog(\"Generated node X coordinates: \" + JSON.stringify(nodesXCoordinates));\r\n\r\n      // Return x coordinates of nodes, total nodes, NOP array, and boundary elements\r\n      return {\r\n        nodesXCoordinates,\r\n        totalNodesX,\r\n        nodalNumbering,\r\n        boundaryElements,\r\n      };\r\n    } else if (this.meshDimension === \"2D\") {\r\n      if (this.elementOrder === \"linear\") {\r\n        totalNodesX = this.numElementsX + 1;\r\n        totalNodesY = this.numElementsY + 1;\r\n        deltaX = (this.maxX - xStart) / this.numElementsX;\r\n        deltaY = (this.maxY - yStart) / this.numElementsY;\r\n\r\n        nodesXCoordinates[0] = xStart;\r\n        nodesYCoordinates[0] = yStart;\r\n        for (let nodeIndexY = 1; nodeIndexY < totalNodesY; nodeIndexY++) {\r\n          nodesXCoordinates[nodeIndexY] = nodesXCoordinates[0];\r\n          nodesYCoordinates[nodeIndexY] = nodesYCoordinates[0] + nodeIndexY * deltaY;\r\n        }\r\n        for (let nodeIndexX = 1; nodeIndexX < totalNodesX; nodeIndexX++) {\r\n          const nnode = nodeIndexX * totalNodesY;\r\n          nodesXCoordinates[nnode] = nodesXCoordinates[0] + nodeIndexX * deltaX;\r\n          nodesYCoordinates[nnode] = nodesYCoordinates[0];\r\n          for (let nodeIndexY = 1; nodeIndexY < totalNodesY; nodeIndexY++) {\r\n            nodesXCoordinates[nnode + nodeIndexY] = nodesXCoordinates[nnode];\r\n            nodesYCoordinates[nnode + nodeIndexY] = nodesYCoordinates[nnode] + nodeIndexY * deltaY;\r\n          }\r\n        }\r\n      } else if (this.elementOrder === \"quadratic\") {\r\n        totalNodesX = 2 * this.numElementsX + 1;\r\n        totalNodesY = 2 * this.numElementsY + 1;\r\n        deltaX = (this.maxX - xStart) / this.numElementsX;\r\n        deltaY = (this.maxY - yStart) / this.numElementsY;\r\n\r\n        nodesXCoordinates[0] = xStart;\r\n        nodesYCoordinates[0] = yStart;\r\n        for (let nodeIndexY = 1; nodeIndexY < totalNodesY; nodeIndexY++) {\r\n          nodesXCoordinates[nodeIndexY] = nodesXCoordinates[0];\r\n          nodesYCoordinates[nodeIndexY] = nodesYCoordinates[0] + (nodeIndexY * deltaY) / 2;\r\n        }\r\n        for (let nodeIndexX = 1; nodeIndexX < totalNodesX; nodeIndexX++) {\r\n          const nnode = nodeIndexX * totalNodesY;\r\n          nodesXCoordinates[nnode] = nodesXCoordinates[0] + (nodeIndexX * deltaX) / 2;\r\n          nodesYCoordinates[nnode] = nodesYCoordinates[0];\r\n          for (let nodeIndexY = 1; nodeIndexY < totalNodesY; nodeIndexY++) {\r\n            nodesXCoordinates[nnode + nodeIndexY] = nodesXCoordinates[nnode];\r\n            nodesYCoordinates[nnode + nodeIndexY] = nodesYCoordinates[nnode] + (nodeIndexY * deltaY) / 2;\r\n          }\r\n        }\r\n      }\r\n      // Generate nodal numbering (NOP) array\r\n      const nodalNumbering = this.generateNodalNumbering(\r\n        this.numElementsX,\r\n        this.numElementsY,\r\n        totalNodesX,\r\n        totalNodesY,\r\n        this.elementOrder\r\n      );\r\n      // Find boundary elements\r\n      const boundaryElements = this.findBoundaryElements();\r\n\r\n      debugLog(\"Generated node X coordinates: \" + JSON.stringify(nodesXCoordinates));\r\n      debugLog(\"Generated node Y coordinates: \" + JSON.stringify(nodesYCoordinates));\r\n\r\n      // Return x and y coordinates of nodes, total nodes, NOP array, and boundary elements\r\n      return {\r\n        nodesXCoordinates,\r\n        nodesYCoordinates,\r\n        totalNodesX,\r\n        totalNodesY,\r\n        nodalNumbering,\r\n        boundaryElements,\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Function to find the elements that belong to each boundary of a domain\r\n   * @returns {array} An array containing arrays of elements and their adjacent boundary side for each boundary\r\n   * Each element in the array is of the form [elementIndex, side], where 'side' indicates which side\r\n   * of the reference element is in contact with the physical boundary:\r\n   *\r\n   * For 1D domains (line segments):\r\n   * 0 - Left node of reference element (maps to physical left endpoint)\r\n   * 1 - Right node of reference element (maps to physical right endpoint)\r\n   *\r\n   * For 2D domains (rectangular):\r\n   * 0 - Bottom side of reference element (maps to physical bottom boundary)\r\n   * 1 - Left side of reference element (maps to physical left boundary)\r\n   * 2 - Top side of reference element (maps to physical top boundary)\r\n   * 3 - Right side of reference element (maps to physical right boundary)\r\n   */\r\n  findBoundaryElements() {\r\n    const boundaryElements = [];\r\n    const maxSides = this.meshDimension === \"1D\" ? 2 : 4; // Number of element sides based on mesh dimension\r\n    for (let sideIndex = 0; sideIndex < maxSides; sideIndex++) {\r\n      boundaryElements.push([]);\r\n    }\r\n\r\n    if (this.meshDimension === \"1D\") {\r\n      // Left boundary (element 0, side 0)\r\n      boundaryElements[0].push([0, 0]);\r\n\r\n      // Right boundary (last element, side 1)\r\n      boundaryElements[1].push([this.numElementsX - 1, 1]);\r\n    } else if (this.meshDimension === \"2D\") {\r\n      for (let elementIndexX = 0; elementIndexX < this.numElementsX; elementIndexX++) {\r\n        for (let elementIndexY = 0; elementIndexY < this.numElementsY; elementIndexY++) {\r\n          const elementIndex = elementIndexX * this.numElementsY + elementIndexY;\r\n\r\n          // Bottom boundary\r\n          if (elementIndexY === 0) {\r\n            boundaryElements[0].push([elementIndex, 0]);\r\n          }\r\n\r\n          // Left boundary\r\n          if (elementIndexX === 0) {\r\n            boundaryElements[1].push([elementIndex, 1]);\r\n          }\r\n\r\n          // Top boundary\r\n          if (elementIndexY === this.numElementsY - 1) {\r\n            boundaryElements[2].push([elementIndex, 2]);\r\n          }\r\n\r\n          // Right boundary\r\n          if (elementIndexX === this.numElementsX - 1) {\r\n            boundaryElements[3].push([elementIndex, 3]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    debugLog(\"Identified boundary elements by side: \" + JSON.stringify(boundaryElements));\r\n    return boundaryElements;\r\n  }\r\n\r\n  /**\r\n   * Function to generate the nodal numbering (NOP) array for a structured mesh\r\n   * This array represents the connectivity between elements and their corresponding nodes\r\n   * @param {number} numElementsX - Number of elements along the x-axis\r\n   * @param {number} [numElementsY] - Number of elements along the y-axis (optional for 1D)\r\n   * @param {number} totalNodesX - Total number of nodes along the x-axis\r\n   * @param {number} [totalNodesY] - Total number of nodes along the y-axis (optional for 1D)\r\n   * @param {string} elementOrder - The order of elements, either 'linear' or 'quadratic'\r\n   * @returns {array} NOP - A two-dimensional array which represents the element-to-node connectivity for the entire mesh\r\n   */\r\n  generateNodalNumbering(numElementsX, numElementsY, totalNodesX, totalNodesY, elementOrder) {\r\n    let elementIndex = 0;\r\n    let nop = [];\r\n\r\n    if (this.meshDimension === \"1D\") {\r\n      if (elementOrder === \"linear\") {\r\n        /**\r\n         * Linear 1D elements with the following nodes representation:\r\n         *\r\n         *   1 --- 2\r\n         *\r\n         */\r\n        for (let elementIndex = 0; elementIndex < numElementsX; elementIndex++) {\r\n          nop[elementIndex] = [];\r\n          for (let nodeIndex = 1; nodeIndex <= 2; nodeIndex++) {\r\n            nop[elementIndex][nodeIndex - 1] = elementIndex + nodeIndex;\r\n          }\r\n        }\r\n      } else if (elementOrder === \"quadratic\") {\r\n        /**\r\n         * Quadratic 1D elements with the following nodes representation:\r\n         *\r\n         *   1--2--3\r\n         *\r\n         */\r\n        let columnCounter = 0;\r\n        for (let elementIndex = 0; elementIndex < numElementsX; elementIndex++) {\r\n          nop[elementIndex] = [];\r\n          for (let nodeIndex = 1; nodeIndex <= 3; nodeIndex++) {\r\n            nop[elementIndex][nodeIndex - 1] = elementIndex + nodeIndex + columnCounter;\r\n          }\r\n          columnCounter += 1;\r\n        }\r\n      }\r\n    } else if (this.meshDimension === \"2D\") {\r\n      if (elementOrder === \"linear\") {\r\n        /**\r\n         * Linear rectangular elements with the following nodes representation:\r\n         *\r\n         *   1 --- 3\r\n         *   |     |\r\n         *   0 --- 2\r\n         *\r\n         */\r\n        let rowCounter = 0;\r\n        let columnCounter = 2;\r\n        for (let elementIndex = 0; elementIndex < numElementsX * numElementsY; elementIndex++) {\r\n          rowCounter += 1;\r\n          nop[elementIndex] = [];\r\n          nop[elementIndex][0] = elementIndex + columnCounter - 1;\r\n          nop[elementIndex][1] = elementIndex + columnCounter;\r\n          nop[elementIndex][2] = elementIndex + columnCounter + numElementsY;\r\n          nop[elementIndex][3] = elementIndex + columnCounter + numElementsY + 1;\r\n          if (rowCounter === numElementsY) {\r\n            columnCounter += 1;\r\n            rowCounter = 0;\r\n          }\r\n        }\r\n      } else if (elementOrder === \"quadratic\") {\r\n        /**\r\n         * Quadratic rectangular elements with the following nodes representation:\r\n         *\r\n         *   2--5--8\r\n         *   |     |\r\n         *   1  4  7\r\n         *   |     |\r\n         *   0--3--6\r\n         *\r\n         */\r\n        for (let elementIndexX = 1; elementIndexX <= numElementsX; elementIndexX++) {\r\n          for (let elementIndexY = 1; elementIndexY <= numElementsY; elementIndexY++) {\r\n            nop[elementIndex] = [];\r\n            for (let nodeIndex1 = 1; nodeIndex1 <= 3; nodeIndex1++) {\r\n              let nodeIndex2 = 3 * nodeIndex1 - 2;\r\n              nop[elementIndex][nodeIndex2 - 1] =\r\n                totalNodesY * (2 * elementIndexX + nodeIndex1 - 3) + 2 * elementIndexY - 1;\r\n              nop[elementIndex][nodeIndex2] = nop[elementIndex][nodeIndex2 - 1] + 1;\r\n              nop[elementIndex][nodeIndex2 + 1] = nop[elementIndex][nodeIndex2 - 1] + 2;\r\n            }\r\n            elementIndex = elementIndex + 1;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return nop;\r\n  }\r\n}\r\n","//   ______ ______           _____           _       _     //\r\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\r\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\r\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\r\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\r\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\r\n//                                            | |   | |    //\r\n//                                            |_|   | |_   //\r\n//       Website: https://feascript.com/             \\__|  //\r\n\r\n// Internal imports\r\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\r\n\r\n/**\r\n * Class to handle thermal boundary conditions application\r\n */\r\nexport class ThermalBoundaryConditions {\r\n  /**\r\n   * Constructor to initialize the ThermalBoundaryConditions class\r\n   * @param {object} boundaryConditions - Object containing boundary conditions for the finite element analysis\r\n   * @param {array} boundaryElements - Array containing elements that belong to each boundary\r\n   * @param {array} nop - Nodal numbering (NOP) array representing the connectivity between elements and nodes\r\n   * @param {string} meshDimension - The dimension of the mesh (e.g., \"2D\")\r\n   * @param {string} elementOrder - The order of elements (e.g., \"linear\", \"quadratic\")\r\n   */\r\n  constructor(boundaryConditions, boundaryElements, nop, meshDimension, elementOrder) {\r\n    this.boundaryConditions = boundaryConditions;\r\n    this.boundaryElements = boundaryElements;\r\n    this.nop = nop;\r\n    this.meshDimension = meshDimension;\r\n    this.elementOrder = elementOrder;\r\n  }\r\n\r\n  /**\r\n   * Function to impose constant temperature boundary conditions (Dirichlet type)\r\n   * @param {array} residualVector - The residual vector to be modified\r\n   * @param {array} jacobianMatrix - The Jacobian matrix to be modified\r\n   */\r\n  imposeConstantTempBoundaryConditions(residualVector, jacobianMatrix) {\r\n    basicLog(\"Applying constant temperature boundary conditions (Dirichlet type)\");\r\n    if (this.meshDimension === \"1D\") {\r\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\r\n        if (this.boundaryConditions[boundaryKey][0] === \"constantTemp\") {\r\n          const tempValue = this.boundaryConditions[boundaryKey][1];\r\n          debugLog(\r\n            `Boundary ${boundaryKey}: Applying constant temperature of ${tempValue} K (Dirichlet condition)`\r\n          );\r\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\r\n            if (this.elementOrder === \"linear\") {\r\n              const boundarySides = {\r\n                0: [0], // Node at the left side of the reference element\r\n                1: [1], // Node at the right side of the reference element\r\n              };\r\n              boundarySides[side].forEach((nodeIndex) => {\r\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\r\n                debugLog(\r\n                  `  - Applied fixed temperature to node ${globalNodeIndex + 1} (element ${\r\n                    elementIndex + 1\r\n                  }, local node ${nodeIndex + 1})`\r\n                );\r\n                // Set the residual vector to the ConstantTemp value\r\n                residualVector[globalNodeIndex] = tempValue;\r\n                // Set the Jacobian matrix row to zero\r\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\r\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\r\n                }\r\n                // Set the diagonal entry of the Jacobian matrix to one\r\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\r\n              });\r\n            } else if (this.elementOrder === \"quadratic\") {\r\n              const boundarySides = {\r\n                0: [0], // Node at the left side of the reference element\r\n                2: [2], // Node at the right side of the reference element\r\n              };\r\n              boundarySides[side].forEach((nodeIndex) => {\r\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\r\n                debugLog(\r\n                  `  - Applied fixed temperature to node ${globalNodeIndex + 1} (element ${\r\n                    elementIndex + 1\r\n                  }, local node ${nodeIndex + 1})`\r\n                );\r\n                // Set the residual vector to the ConstantTemp value\r\n                residualVector[globalNodeIndex] = tempValue;\r\n                // Set the Jacobian matrix row to zero\r\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\r\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\r\n                }\r\n                // Set the diagonal entry of the Jacobian matrix to one\r\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\r\n              });\r\n            }\r\n          });\r\n        }\r\n      });\r\n    } else if (this.meshDimension === \"2D\") {\r\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\r\n        if (this.boundaryConditions[boundaryKey][0] === \"constantTemp\") {\r\n          const tempValue = this.boundaryConditions[boundaryKey][1];\r\n          debugLog(\r\n            `Boundary ${boundaryKey}: Applying constant temperature of ${tempValue} K (Dirichlet condition)`\r\n          );\r\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\r\n            if (this.elementOrder === \"linear\") {\r\n              const boundarySides = {\r\n                0: [0, 2], // Nodes at the bottom side of the reference element\r\n                1: [0, 1], // Nodes at the left side of the reference element\r\n                2: [1, 3], // Nodes at the top side of the reference element\r\n                3: [2, 3], // Nodes at the right side of the reference element\r\n              };\r\n              boundarySides[side].forEach((nodeIndex) => {\r\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\r\n                debugLog(\r\n                  `  - Applied fixed temperature to node ${globalNodeIndex + 1} (element ${\r\n                    elementIndex + 1\r\n                  }, local node ${nodeIndex + 1})`\r\n                );\r\n                // Set the residual vector to the ConstantTemp value\r\n                residualVector[globalNodeIndex] = tempValue;\r\n                // Set the Jacobian matrix row to zero\r\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\r\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\r\n                }\r\n                // Set the diagonal entry of the Jacobian matrix to one\r\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\r\n              });\r\n            } else if (this.elementOrder === \"quadratic\") {\r\n              const boundarySides = {\r\n                0: [0, 3, 6], // Nodes at the bottom side of the reference element\r\n                1: [0, 1, 2], // Nodes at the left side of the reference element\r\n                2: [2, 5, 8], // Nodes at the top side of the reference element\r\n                3: [6, 7, 8], // Nodes at the right side of the reference element\r\n              };\r\n              boundarySides[side].forEach((nodeIndex) => {\r\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\r\n                debugLog(\r\n                  `  - Applied fixed temperature to node ${globalNodeIndex + 1} (element ${\r\n                    elementIndex + 1\r\n                  }, local node ${nodeIndex + 1})`\r\n                );\r\n                // Set the residual vector to the ConstantTemp value\r\n                residualVector[globalNodeIndex] = tempValue;\r\n                // Set the Jacobian matrix row to zero\r\n                for (let colIndex = 0; colIndex < residualVector.length; colIndex++) {\r\n                  jacobianMatrix[globalNodeIndex][colIndex] = 0;\r\n                }\r\n                // Set the diagonal entry of the Jacobian matrix to one\r\n                jacobianMatrix[globalNodeIndex][globalNodeIndex] = 1;\r\n              });\r\n            }\r\n          });\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Function to impose convection boundary conditions (Robin type)\r\n   * @param {array} residualVector - The residual vector to be modified\r\n   * @param {array} jacobianMatrix - The Jacobian matrix to be modified\r\n   * @param {array} gaussPoints - Array of Gauss points for numerical integration\r\n   * @param {array} gaussWeights - Array of Gauss weights for numerical integration\r\n   * @param {array} nodesXCoordinates - Array of x-coordinates of nodes\r\n   * @param {array} nodesYCoordinates - Array of y-coordinates of nodes\r\n   * @param {object} basisFunctionsData - Object containing basis functions and their derivatives\r\n   */\r\n  imposeConvectionBoundaryConditions(\r\n    residualVector,\r\n    jacobianMatrix,\r\n    gaussPoints,\r\n    gaussWeights,\r\n    nodesXCoordinates,\r\n    nodesYCoordinates,\r\n    basisFunctionsData\r\n  ) {\r\n    basicLog(\"Applying convection boundary conditions (Robin type)\");\r\n    // Extract convection parameters from boundary conditions\r\n    let convectionHeatTranfCoeff = [];\r\n    let convectionExtTemp = [];\r\n    Object.keys(this.boundaryConditions).forEach((key) => {\r\n      const boundaryCondition = this.boundaryConditions[key];\r\n      if (boundaryCondition[0] === \"convection\") {\r\n        convectionHeatTranfCoeff[key] = boundaryCondition[1];\r\n        convectionExtTemp[key] = boundaryCondition[2];\r\n      }\r\n    });\r\n\r\n    if (this.meshDimension === \"1D\") {\r\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\r\n        if (this.boundaryConditions[boundaryKey][0] === \"convection\") {\r\n          const convectionCoeff = convectionHeatTranfCoeff[boundaryKey];\r\n          const extTemp = convectionExtTemp[boundaryKey];\r\n          debugLog(\r\n            `Boundary ${boundaryKey}: Applying convection with heat transfer coefficient h=${convectionCoeff} W/(mK) and external temperature T=${extTemp} K`\r\n          );\r\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\r\n            let nodeIndex;\r\n            if (this.elementOrder === \"linear\") {\r\n              if (side === 0) {\r\n                // Node at the left side of the reference element\r\n                nodeIndex = 0;\r\n              } else {\r\n                // Node at the right side of the reference element\r\n                nodeIndex = 1;\r\n              }\r\n            } else if (this.elementOrder === \"quadratic\") {\r\n              if (side === 0) {\r\n                // Node at the left side of the reference element\r\n                nodeIndex = 0;\r\n              } else {\r\n                // Node at the right side of the reference element\r\n                nodeIndex = 2;\r\n              }\r\n            }\r\n\r\n            const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\r\n            debugLog(\r\n              `  - Applied convection boundary condition to node ${globalNodeIndex + 1} (element ${\r\n                elementIndex + 1\r\n              }, local node ${nodeIndex + 1})`\r\n            );\r\n            residualVector[globalNodeIndex] += -convectionCoeff * extTemp;\r\n            jacobianMatrix[globalNodeIndex][globalNodeIndex] += convectionCoeff;\r\n          });\r\n        }\r\n      });\r\n    } else if (this.meshDimension === \"2D\") {\r\n      Object.keys(this.boundaryConditions).forEach((boundaryKey) => {\r\n        if (this.boundaryConditions[boundaryKey][0] === \"convection\") {\r\n          const convectionCoeff = convectionHeatTranfCoeff[boundaryKey];\r\n          const extTemp = convectionExtTemp[boundaryKey];\r\n          debugLog(\r\n            `Boundary ${boundaryKey}: Applying convection with heat transfer coefficient h=${convectionCoeff} W/(mK) and external temperature T=${extTemp} K`\r\n          );\r\n          this.boundaryElements[boundaryKey].forEach(([elementIndex, side]) => {\r\n            if (this.elementOrder === \"linear\") {\r\n              let gaussPoint1, gaussPoint2, firstNodeIndex, lastNodeIndex, nodeIncrement;\r\n              if (side === 0) {\r\n                // Nodes at the bottom side of the reference element\r\n                gaussPoint1 = gaussPoints[0];\r\n                gaussPoint2 = 0;\r\n                firstNodeIndex = 0;\r\n                lastNodeIndex = 3;\r\n                nodeIncrement = 2;\r\n              } else if (side === 1) {\r\n                // Nodes at the left side of the reference element\r\n                gaussPoint1 = 0;\r\n                gaussPoint2 = gaussPoints[0];\r\n                firstNodeIndex = 0;\r\n                lastNodeIndex = 2;\r\n                nodeIncrement = 1;\r\n              } else if (side === 2) {\r\n                // Nodes at the top side of the reference element\r\n                gaussPoint1 = gaussPoints[0];\r\n                gaussPoint2 = 1;\r\n                firstNodeIndex = 1;\r\n                lastNodeIndex = 4;\r\n                nodeIncrement = 2;\r\n              } else if (side === 3) {\r\n                // Nodes at the right side of the reference element\r\n                gaussPoint1 = 1;\r\n                gaussPoint2 = gaussPoints[0];\r\n                firstNodeIndex = 2;\r\n                lastNodeIndex = 4;\r\n                nodeIncrement = 1;\r\n              }\r\n\r\n              let basisFunctionsAndDerivatives = basisFunctionsData.getBasisFunctions(\r\n                gaussPoint1,\r\n                gaussPoint2\r\n              );\r\n              let basisFunction = basisFunctionsAndDerivatives.basisFunction;\r\n              let basisFunctionDerivKsi = basisFunctionsAndDerivatives.basisFunctionDerivKsi;\r\n              let basisFunctionDerivEta = basisFunctionsAndDerivatives.basisFunctionDerivEta;\r\n\r\n              let ksiDerivX = 0;\r\n              let ksiDerivY = 0;\r\n              let etaDerivX = 0;\r\n              let etaDerivY = 0;\r\n              const numNodes = this.nop[elementIndex].length;\r\n              for (let nodeIndex = 0; nodeIndex < numNodes; nodeIndex++) {\r\n                const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\r\n\r\n                // For boundaries along Ksi (horizontal), use Ksi derivatives\r\n                if (side === 0 || side === 2) {\r\n                  ksiDerivX += nodesXCoordinates[globalNodeIndex] * basisFunctionDerivKsi[nodeIndex];\r\n                  ksiDerivY += nodesYCoordinates[globalNodeIndex] * basisFunctionDerivKsi[nodeIndex];\r\n                }\r\n                // For boundaries along Eta (vertical), use Eta derivatives\r\n                else if (side === 1 || side === 3) {\r\n                  etaDerivX += nodesXCoordinates[globalNodeIndex] * basisFunctionDerivEta[nodeIndex];\r\n                  etaDerivY += nodesYCoordinates[globalNodeIndex] * basisFunctionDerivEta[nodeIndex];\r\n                }\r\n              }\r\n\r\n              // Compute the length of tangent vector\r\n              const tangentVectorLength =\r\n                side === 0 || side === 2\r\n                  ? Math.sqrt(ksiDerivX ** 2 + ksiDerivY ** 2)\r\n                  : Math.sqrt(etaDerivX ** 2 + etaDerivY ** 2);\r\n\r\n              for (\r\n                let localNodeIndex = firstNodeIndex;\r\n                localNodeIndex < lastNodeIndex;\r\n                localNodeIndex += nodeIncrement\r\n              ) {\r\n                let globalNodeIndex = this.nop[elementIndex][localNodeIndex] - 1;\r\n                debugLog(\r\n                  `  - Applied convection boundary condition to node ${globalNodeIndex + 1} (element ${\r\n                    elementIndex + 1\r\n                  }, local node ${localNodeIndex + 1})`\r\n                );\r\n\r\n                // Apply boundary condition with proper Jacobian for all sides\r\n                residualVector[globalNodeIndex] +=\r\n                  -gaussWeights[0] * tangentVectorLength * basisFunction[localNodeIndex] * convectionCoeff * extTemp;\r\n\r\n                for (\r\n                  let localNodeIndex2 = firstNodeIndex;\r\n                  localNodeIndex2 < lastNodeIndex;\r\n                  localNodeIndex2 += nodeIncrement\r\n                ) {\r\n                  let globalNodeIndex2 = this.nop[elementIndex][localNodeIndex2] - 1;\r\n                  jacobianMatrix[globalNodeIndex][globalNodeIndex2] +=\r\n                    -gaussWeights[0] *\r\n                    tangentVectorLength *\r\n                    basisFunction[localNodeIndex] *\r\n                    basisFunction[localNodeIndex2] *\r\n                    convectionCoeff;\r\n                }\r\n              }\r\n            } else if (this.elementOrder === \"quadratic\") {\r\n              for (let gaussPointIndex = 0; gaussPointIndex < 3; gaussPointIndex++) {\r\n                let gaussPoint1, gaussPoint2, firstNodeIndex, lastNodeIndex, nodeIncrement;\r\n                if (side === 0) {\r\n                  // Nodes at the bottom side of the reference element\r\n                  gaussPoint1 = gaussPoints[gaussPointIndex];\r\n                  gaussPoint2 = 0;\r\n                  firstNodeIndex = 0;\r\n                  lastNodeIndex = 7;\r\n                  nodeIncrement = 3;\r\n                } else if (side === 1) {\r\n                  // Nodes at the left side of the reference element\r\n                  gaussPoint1 = 0;\r\n                  gaussPoint2 = gaussPoints[gaussPointIndex];\r\n                  firstNodeIndex = 0;\r\n                  lastNodeIndex = 3;\r\n                  nodeIncrement = 1;\r\n                } else if (side === 2) {\r\n                  // Nodes at the top side of the reference element\r\n                  gaussPoint1 = gaussPoints[gaussPointIndex];\r\n                  gaussPoint2 = 1;\r\n                  firstNodeIndex = 2;\r\n                  lastNodeIndex = 9;\r\n                  nodeIncrement = 3;\r\n                } else if (side === 3) {\r\n                  // Nodes at the right side of the reference element\r\n                  gaussPoint1 = 1;\r\n                  gaussPoint2 = gaussPoints[gaussPointIndex];\r\n                  firstNodeIndex = 6;\r\n                  lastNodeIndex = 9;\r\n                  nodeIncrement = 1;\r\n                }\r\n                let basisFunctionsAndDerivatives = basisFunctionsData.getBasisFunctions(\r\n                  gaussPoint1,\r\n                  gaussPoint2\r\n                );\r\n                let basisFunction = basisFunctionsAndDerivatives.basisFunction;\r\n                let basisFunctionDerivKsi = basisFunctionsAndDerivatives.basisFunctionDerivKsi;\r\n                let basisFunctionDerivEta = basisFunctionsAndDerivatives.basisFunctionDerivEta;\r\n\r\n                let ksiDerivX = 0;\r\n                let ksiDerivY = 0;\r\n                let etaDerivX = 0;\r\n                let etaDerivY = 0;\r\n                const numNodes = this.nop[elementIndex].length;\r\n                for (let nodeIndex = 0; nodeIndex < numNodes; nodeIndex++) {\r\n                  const globalNodeIndex = this.nop[elementIndex][nodeIndex] - 1;\r\n\r\n                  // For boundaries along Ksi (horizontal), use Ksi derivatives\r\n                  if (side === 0 || side === 2) {\r\n                    ksiDerivX += nodesXCoordinates[globalNodeIndex] * basisFunctionDerivKsi[nodeIndex];\r\n                    ksiDerivY += nodesYCoordinates[globalNodeIndex] * basisFunctionDerivKsi[nodeIndex];\r\n                  }\r\n                  // For boundaries along Eta (vertical), use Eta derivatives\r\n                  else if (side === 1 || side === 3) {\r\n                    etaDerivX += nodesXCoordinates[globalNodeIndex] * basisFunctionDerivEta[nodeIndex];\r\n                    etaDerivY += nodesYCoordinates[globalNodeIndex] * basisFunctionDerivEta[nodeIndex];\r\n                  }\r\n                }\r\n\r\n                // Compute the length of tangent vector\r\n                const tangentVectorLength =\r\n                  side === 0 || side === 2\r\n                    ? Math.sqrt(ksiDerivX ** 2 + ksiDerivY ** 2)\r\n                    : Math.sqrt(etaDerivX ** 2 + etaDerivY ** 2);\r\n\r\n                for (\r\n                  let localNodeIndex = firstNodeIndex;\r\n                  localNodeIndex < lastNodeIndex;\r\n                  localNodeIndex += nodeIncrement\r\n                ) {\r\n                  let globalNodeIndex = this.nop[elementIndex][localNodeIndex] - 1;\r\n                  debugLog(\r\n                    `  - Applied convection boundary condition to node ${globalNodeIndex + 1} (element ${\r\n                      elementIndex + 1\r\n                    }, local node ${localNodeIndex + 1})`\r\n                  );\r\n\r\n                  // Apply boundary condition with proper Jacobian for all sides\r\n                  residualVector[globalNodeIndex] +=\r\n                    -gaussWeights[gaussPointIndex] *\r\n                    tangentVectorLength *\r\n                    basisFunction[localNodeIndex] *\r\n                    convectionCoeff *\r\n                    extTemp;\r\n\r\n                  for (\r\n                    let localNodeIndex2 = firstNodeIndex;\r\n                    localNodeIndex2 < lastNodeIndex;\r\n                    localNodeIndex2 += nodeIncrement\r\n                  ) {\r\n                    let globalNodeIndex2 = this.nop[elementIndex][localNodeIndex2] - 1;\r\n                    jacobianMatrix[globalNodeIndex][globalNodeIndex2] +=\r\n                      -gaussWeights[gaussPointIndex] *\r\n                      tangentVectorLength *\r\n                      basisFunction[localNodeIndex] *\r\n                      basisFunction[localNodeIndex2] *\r\n                      convectionCoeff;\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          });\r\n        }\r\n      });\r\n    }\r\n  }\r\n}\r\n","/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n * SPDX-License-Identifier: Apache-2.0\r\n */\r\nconst proxyMarker = Symbol(\"Comlink.proxy\");\r\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\r\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\r\nconst finalizer = Symbol(\"Comlink.finalizer\");\r\nconst throwMarker = Symbol(\"Comlink.thrown\");\r\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\r\n/**\r\n * Internal transfer handle to handle objects marked to proxy.\r\n */\r\nconst proxyTransferHandler = {\r\n    canHandle: (val) => isObject(val) && val[proxyMarker],\r\n    serialize(obj) {\r\n        const { port1, port2 } = new MessageChannel();\r\n        expose(obj, port1);\r\n        return [port2, [port2]];\r\n    },\r\n    deserialize(port) {\r\n        port.start();\r\n        return wrap(port);\r\n    },\r\n};\r\n/**\r\n * Internal transfer handler to handle thrown exceptions.\r\n */\r\nconst throwTransferHandler = {\r\n    canHandle: (value) => isObject(value) && throwMarker in value,\r\n    serialize({ value }) {\r\n        let serialized;\r\n        if (value instanceof Error) {\r\n            serialized = {\r\n                isError: true,\r\n                value: {\r\n                    message: value.message,\r\n                    name: value.name,\r\n                    stack: value.stack,\r\n                },\r\n            };\r\n        }\r\n        else {\r\n            serialized = { isError: false, value };\r\n        }\r\n        return [serialized, []];\r\n    },\r\n    deserialize(serialized) {\r\n        if (serialized.isError) {\r\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\r\n        }\r\n        throw serialized.value;\r\n    },\r\n};\r\n/**\r\n * Allows customizing the serialization of certain values.\r\n */\r\nconst transferHandlers = new Map([\r\n    [\"proxy\", proxyTransferHandler],\r\n    [\"throw\", throwTransferHandler],\r\n]);\r\nfunction isAllowedOrigin(allowedOrigins, origin) {\r\n    for (const allowedOrigin of allowedOrigins) {\r\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\r\n            return true;\r\n        }\r\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\r\n    ep.addEventListener(\"message\", function callback(ev) {\r\n        if (!ev || !ev.data) {\r\n            return;\r\n        }\r\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\r\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\r\n            return;\r\n        }\r\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\r\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\r\n        let returnValue;\r\n        try {\r\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\r\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\r\n            switch (type) {\r\n                case \"GET\" /* MessageType.GET */:\r\n                    {\r\n                        returnValue = rawValue;\r\n                    }\r\n                    break;\r\n                case \"SET\" /* MessageType.SET */:\r\n                    {\r\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\r\n                        returnValue = true;\r\n                    }\r\n                    break;\r\n                case \"APPLY\" /* MessageType.APPLY */:\r\n                    {\r\n                        returnValue = rawValue.apply(parent, argumentList);\r\n                    }\r\n                    break;\r\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\r\n                    {\r\n                        const value = new rawValue(...argumentList);\r\n                        returnValue = proxy(value);\r\n                    }\r\n                    break;\r\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\r\n                    {\r\n                        const { port1, port2 } = new MessageChannel();\r\n                        expose(obj, port2);\r\n                        returnValue = transfer(port1, [port1]);\r\n                    }\r\n                    break;\r\n                case \"RELEASE\" /* MessageType.RELEASE */:\r\n                    {\r\n                        returnValue = undefined;\r\n                    }\r\n                    break;\r\n                default:\r\n                    return;\r\n            }\r\n        }\r\n        catch (value) {\r\n            returnValue = { value, [throwMarker]: 0 };\r\n        }\r\n        Promise.resolve(returnValue)\r\n            .catch((value) => {\r\n            return { value, [throwMarker]: 0 };\r\n        })\r\n            .then((returnValue) => {\r\n            const [wireValue, transferables] = toWireValue(returnValue);\r\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\r\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\r\n                // detach and deactive after sending release response above.\r\n                ep.removeEventListener(\"message\", callback);\r\n                closeEndPoint(ep);\r\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\r\n                    obj[finalizer]();\r\n                }\r\n            }\r\n        })\r\n            .catch((error) => {\r\n            // Send Serialization Error To Caller\r\n            const [wireValue, transferables] = toWireValue({\r\n                value: new TypeError(\"Unserializable return value\"),\r\n                [throwMarker]: 0,\r\n            });\r\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\r\n        });\r\n    });\r\n    if (ep.start) {\r\n        ep.start();\r\n    }\r\n}\r\nfunction isMessagePort(endpoint) {\r\n    return endpoint.constructor.name === \"MessagePort\";\r\n}\r\nfunction closeEndPoint(endpoint) {\r\n    if (isMessagePort(endpoint))\r\n        endpoint.close();\r\n}\r\nfunction wrap(ep, target) {\r\n    const pendingListeners = new Map();\r\n    ep.addEventListener(\"message\", function handleMessage(ev) {\r\n        const { data } = ev;\r\n        if (!data || !data.id) {\r\n            return;\r\n        }\r\n        const resolver = pendingListeners.get(data.id);\r\n        if (!resolver) {\r\n            return;\r\n        }\r\n        try {\r\n            resolver(data);\r\n        }\r\n        finally {\r\n            pendingListeners.delete(data.id);\r\n        }\r\n    });\r\n    return createProxy(ep, pendingListeners, [], target);\r\n}\r\nfunction throwIfProxyReleased(isReleased) {\r\n    if (isReleased) {\r\n        throw new Error(\"Proxy has been released and is not useable\");\r\n    }\r\n}\r\nfunction releaseEndpoint(ep) {\r\n    return requestResponseMessage(ep, new Map(), {\r\n        type: \"RELEASE\" /* MessageType.RELEASE */,\r\n    }).then(() => {\r\n        closeEndPoint(ep);\r\n    });\r\n}\r\nconst proxyCounter = new WeakMap();\r\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\r\n    new FinalizationRegistry((ep) => {\r\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\r\n        proxyCounter.set(ep, newCount);\r\n        if (newCount === 0) {\r\n            releaseEndpoint(ep);\r\n        }\r\n    });\r\nfunction registerProxy(proxy, ep) {\r\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\r\n    proxyCounter.set(ep, newCount);\r\n    if (proxyFinalizers) {\r\n        proxyFinalizers.register(proxy, ep, proxy);\r\n    }\r\n}\r\nfunction unregisterProxy(proxy) {\r\n    if (proxyFinalizers) {\r\n        proxyFinalizers.unregister(proxy);\r\n    }\r\n}\r\nfunction createProxy(ep, pendingListeners, path = [], target = function () { }) {\r\n    let isProxyReleased = false;\r\n    const proxy = new Proxy(target, {\r\n        get(_target, prop) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            if (prop === releaseProxy) {\r\n                return () => {\r\n                    unregisterProxy(proxy);\r\n                    releaseEndpoint(ep);\r\n                    pendingListeners.clear();\r\n                    isProxyReleased = true;\r\n                };\r\n            }\r\n            if (prop === \"then\") {\r\n                if (path.length === 0) {\r\n                    return { then: () => proxy };\r\n                }\r\n                const r = requestResponseMessage(ep, pendingListeners, {\r\n                    type: \"GET\" /* MessageType.GET */,\r\n                    path: path.map((p) => p.toString()),\r\n                }).then(fromWireValue);\r\n                return r.then.bind(r);\r\n            }\r\n            return createProxy(ep, pendingListeners, [...path, prop]);\r\n        },\r\n        set(_target, prop, rawValue) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\r\n            // boolean. To show good will, we return true asynchronously \\_()_/\r\n            const [value, transferables] = toWireValue(rawValue);\r\n            return requestResponseMessage(ep, pendingListeners, {\r\n                type: \"SET\" /* MessageType.SET */,\r\n                path: [...path, prop].map((p) => p.toString()),\r\n                value,\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n        apply(_target, _thisArg, rawArgumentList) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            const last = path[path.length - 1];\r\n            if (last === createEndpoint) {\r\n                return requestResponseMessage(ep, pendingListeners, {\r\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\r\n                }).then(fromWireValue);\r\n            }\r\n            // We just pretend that `bind()` didnt happen.\r\n            if (last === \"bind\") {\r\n                return createProxy(ep, pendingListeners, path.slice(0, -1));\r\n            }\r\n            const [argumentList, transferables] = processArguments(rawArgumentList);\r\n            return requestResponseMessage(ep, pendingListeners, {\r\n                type: \"APPLY\" /* MessageType.APPLY */,\r\n                path: path.map((p) => p.toString()),\r\n                argumentList,\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n        construct(_target, rawArgumentList) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            const [argumentList, transferables] = processArguments(rawArgumentList);\r\n            return requestResponseMessage(ep, pendingListeners, {\r\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\r\n                path: path.map((p) => p.toString()),\r\n                argumentList,\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n    });\r\n    registerProxy(proxy, ep);\r\n    return proxy;\r\n}\r\nfunction myFlat(arr) {\r\n    return Array.prototype.concat.apply([], arr);\r\n}\r\nfunction processArguments(argumentList) {\r\n    const processed = argumentList.map(toWireValue);\r\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\r\n}\r\nconst transferCache = new WeakMap();\r\nfunction transfer(obj, transfers) {\r\n    transferCache.set(obj, transfers);\r\n    return obj;\r\n}\r\nfunction proxy(obj) {\r\n    return Object.assign(obj, { [proxyMarker]: true });\r\n}\r\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\r\n    return {\r\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\r\n        addEventListener: context.addEventListener.bind(context),\r\n        removeEventListener: context.removeEventListener.bind(context),\r\n    };\r\n}\r\nfunction toWireValue(value) {\r\n    for (const [name, handler] of transferHandlers) {\r\n        if (handler.canHandle(value)) {\r\n            const [serializedValue, transferables] = handler.serialize(value);\r\n            return [\r\n                {\r\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\r\n                    name,\r\n                    value: serializedValue,\r\n                },\r\n                transferables,\r\n            ];\r\n        }\r\n    }\r\n    return [\r\n        {\r\n            type: \"RAW\" /* WireValueType.RAW */,\r\n            value,\r\n        },\r\n        transferCache.get(value) || [],\r\n    ];\r\n}\r\nfunction fromWireValue(value) {\r\n    switch (value.type) {\r\n        case \"HANDLER\" /* WireValueType.HANDLER */:\r\n            return transferHandlers.get(value.name).deserialize(value.value);\r\n        case \"RAW\" /* WireValueType.RAW */:\r\n            return value.value;\r\n    }\r\n}\r\nfunction requestResponseMessage(ep, pendingListeners, msg, transfers) {\r\n    return new Promise((resolve) => {\r\n        const id = generateUUID();\r\n        pendingListeners.set(id, resolve);\r\n        if (ep.start) {\r\n            ep.start();\r\n        }\r\n        ep.postMessage(Object.assign({ id }, msg), transfers);\r\n    });\r\n}\r\nfunction generateUUID() {\r\n    return new Array(4)\r\n        .fill(0)\r\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\r\n        .join(\"-\");\r\n}\r\n\r\nexport { createEndpoint, expose, finalizer, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\r\n//# sourceMappingURL=comlink.mjs.map\r\n","//   ______ ______           _____           _       _     //\r\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\r\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\r\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\r\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\r\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\r\n//                                            | |   | |    //\r\n//                                            |_|   | |_   //\r\n//       Website: https://feascript.com/             \\__|  //\r\n\r\n// Internal imports\r\nimport { jacobiMethod } from \"./methods/jacobiMethodScript.js\";\r\nimport { assembleSolidHeatTransferMat } from \"./solvers/solidHeatTransferScript.js\";\r\nimport { basicLog, debugLog, errorLog } from \"./utilities/loggingScript.js\";\r\n\r\n/**\r\n * Class to implement finite element analysis in JavaScript\r\n * @param {string} solverConfig - Parameter specifying the type of solver\r\n * @param {object} meshConfig - Object containing computational mesh details\r\n * @param {object} boundaryConditions - Object containing boundary conditions for the finite element analysis\r\n * @returns {object} An object containing the solution vector and additional mesh information\r\n */\r\nexport class FEAScriptModel {\r\n  constructor() {\r\n    this.solverConfig = null;\r\n    this.meshConfig = {};\r\n    this.boundaryConditions = {};\r\n    this.solverMethod = \"lusolve\"; // Default solver method\r\n    basicLog(\"FEAScriptModel instance created\");\r\n  }\r\n\r\n  setSolverConfig(solverConfig) {\r\n    this.solverConfig = solverConfig;\r\n    debugLog(`Solver config set to: ${solverConfig}`);\r\n  }\r\n\r\n  setMeshConfig(meshConfig) {\r\n    this.meshConfig = meshConfig;\r\n    debugLog(\r\n      `Mesh config set with dimensions: ${meshConfig.meshDimension}`\r\n    );\r\n  }\r\n\r\n  addBoundaryCondition(boundaryKey, condition) {\r\n    this.boundaryConditions[boundaryKey] = condition;\r\n    debugLog(`Boundary condition added for boundary: ${boundaryKey}, type: ${condition[0]}`);\r\n  }\r\n\r\n  setSolverMethod(solverMethod) {\r\n    this.solverMethod = solverMethod;\r\n    debugLog(`Solver method set to: ${solverMethod}`);\r\n  }\r\n\r\n  solve() {\r\n    if (!this.solverConfig || !this.meshConfig || !this.boundaryConditions) {\r\n      const error = \"Solver config, mesh config, and boundary conditions must be set before solving.\";\r\n      console.error(error);\r\n      throw new Error(error);\r\n    }\r\n\r\n    let jacobianMatrix = [];\r\n    let residualVector = [];\r\n    let solutionVector = [];\r\n    let nodesCoordinates = {};\r\n\r\n    // Assembly matrices\r\n    basicLog(\"Beginning matrix assembly...\");\r\n    console.time(\"assemblyMatrices\");\r\n    if (this.solverConfig === \"solidHeatTransferScript\") {\r\n      basicLog(`Using solver: ${this.solverConfig}`);\r\n      ({ jacobianMatrix, residualVector, nodesCoordinates } = assembleSolidHeatTransferMat(\r\n        this.meshConfig,\r\n        this.boundaryConditions\r\n      ));\r\n    }\r\n    console.timeEnd(\"assemblyMatrices\");\r\n    basicLog(\"Matrix assembly completed\");\r\n\r\n    // System solving\r\n    basicLog(`Solving system using ${this.solverMethod}...`);\r\n    console.time(\"systemSolving\");\r\n    if (this.solverMethod === \"lusolve\") {\r\n      solutionVector = math.lusolve(jacobianMatrix, residualVector);\r\n    } else if (this.solverMethod === \"jacobi\") {\r\n      // Create initial guess of zeros\r\n      const initialGuess = new Array(residualVector.length).fill(0);\r\n      // Call Jacobi method with desired max iterations and tolerance\r\n      const jacobiResult = jacobiMethod(jacobianMatrix, residualVector, initialGuess, 1000, 1e-6);\r\n\r\n      // Log convergence information\r\n      if (jacobiResult.converged) {\r\n        debugLog(`Jacobi method converged in ${jacobiResult.iterations} iterations`);\r\n      } else {\r\n        debugLog(`Jacobi method did not converge after ${jacobiResult.iterations} iterations`);\r\n      }\r\n\r\n      solutionVector = jacobiResult.solution;\r\n    }\r\n    console.timeEnd(\"systemSolving\");\r\n    basicLog(\"System solved successfully\");\r\n\r\n    return { solutionVector, nodesCoordinates };\r\n  }\r\n}\r\n","//   ______ ______           _____           _       _     //\r\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\r\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\r\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\r\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\r\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\r\n//                                            | |   | |    //\r\n//                                            |_|   | |_   //\r\n//       Website: https://feascript.com/             \\__|  //\r\n\r\n// Internal imports\r\nimport { numericalIntegration } from \"../methods/numericalIntegrationScript.js\";\r\nimport { basisFunctions } from \"../mesh/basisFunctionsScript.js\";\r\nimport { meshGeneration } from \"../mesh/meshGenerationScript.js\";\r\nimport { ThermalBoundaryConditions } from \"./thermalBoundaryConditionsScript.js\";\r\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\r\n\r\n/**\r\n * Function to assemble the solid heat transfer matrix\r\n * @param {object} meshConfig - Object containing computational mesh details\r\n * @param {object} boundaryConditions - Object containing boundary conditions for the finite element analysis\r\n * @returns {object} An object containing:\r\n *  - jacobianMatrix: The assembled Jacobian matrix\r\n *  - residualVector: The assembled residual vector\r\n *  - nodesCoordinates: Object containing x and y coordinates of nodes\r\n */\r\nexport function assembleSolidHeatTransferMat(meshConfig, boundaryConditions) {\r\n  basicLog(\"Starting solid heat transfer matrix assembly...\");\r\n\r\n  // Extract mesh details from the configuration object\r\n  const {\r\n    meshDimension, // The dimension of the mesh\r\n    numElementsX, // Number of elements in x-direction\r\n    numElementsY, // Number of elements in y-direction (only for 2D)\r\n    maxX, // Max x-coordinate (m) of the domain\r\n    maxY, // Max y-coordinate (m) of the domain (only for 2D)\r\n    elementOrder, // The order of elements\r\n    parsedMesh, // The pre-parsed mesh data (if available)\r\n  } = meshConfig;\r\n\r\n  // Create a new instance of the meshGeneration class\r\n  debugLog(\"Generating mesh...\");\r\n  const meshGenerationData = new meshGeneration({\r\n    numElementsX,\r\n    numElementsY,\r\n    maxX,\r\n    maxY,\r\n    meshDimension,\r\n    elementOrder,\r\n    parsedMesh, // Pass the parsed mesh to the mesh generator\r\n  });\r\n\r\n  // Generate the mesh\r\n  const nodesCoordinatesAndNumbering = meshGenerationData.generateMesh();\r\n\r\n  // Extract nodes coordinates and nodal numbering (NOP) from the mesh data\r\n  let nodesXCoordinates = nodesCoordinatesAndNumbering.nodesXCoordinates;\r\n  let nodesYCoordinates = nodesCoordinatesAndNumbering.nodesYCoordinates;\r\n  let totalNodesX = nodesCoordinatesAndNumbering.totalNodesX;\r\n  let totalNodesY = nodesCoordinatesAndNumbering.totalNodesY;\r\n  let nop = nodesCoordinatesAndNumbering.nodalNumbering;\r\n  let boundaryElements = nodesCoordinatesAndNumbering.boundaryElements;\r\n\r\n  // Check the mesh type\r\n  const isParsedMesh = parsedMesh !== undefined && parsedMesh !== null;\r\n\r\n  // Calculate totalElements and totalNodes based on mesh type\r\n  let totalElements, totalNodes;\r\n\r\n  if (isParsedMesh) {\r\n    totalElements = nop.length; // Number of elements is the length of the nodal numbering array\r\n    totalNodes = nodesXCoordinates.length; // Number of nodes is the length of the coordinates array\r\n\r\n    // Debug log for mesh size\r\n    debugLog(`Using parsed mesh with ${totalElements} elements and ${totalNodes} nodes`);\r\n  } else {\r\n    // For structured mesh, calculate based on dimensions\r\n    totalElements = numElementsX * (meshDimension === \"2D\" ? numElementsY : 1);\r\n    totalNodes = totalNodesX * (meshDimension === \"2D\" ? totalNodesY : 1);\r\n    // Debug log for mesh size\r\n    debugLog(`Using mesh generated from geometry with ${totalElements} elements and ${totalNodes} nodes`);\r\n  }\r\n\r\n  // Initialize variables for matrix assembly\r\n  let localToGlobalMap = []; // Maps local element node indices to global mesh node indices\r\n  let gaussPoints = []; // Gauss points\r\n  let gaussWeights = []; // Gauss weights\r\n  let basisFunction = []; // Basis functions\r\n  let basisFunctionDerivKsi = []; // Derivatives of basis functions with respect to ksi\r\n  let basisFunctionDerivEta = []; // Derivatives of basis functions with respect to eta (only for 2D)\r\n  let basisFunctionDerivX = []; // The x-derivative of the basis function\r\n  let basisFunctionDerivY = []; // The y-derivative of the basis function (only for 2D)\r\n  let residualVector = []; // Galerkin residuals\r\n  let jacobianMatrix = []; // Jacobian matrix\r\n  let xCoordinates; // x-coordinate (physical coordinates)\r\n  let yCoordinates; // y-coordinate (physical coordinates) (only for 2D)\r\n  let ksiDerivX; // ksi-derivative of xCoordinates\r\n  let etaDerivX; // eta-derivative of xCoordinates (ksi and eta are natural coordinates that vary within a reference element) (only for 2D)\r\n  let ksiDerivY; // ksi-derivative of yCoordinates (only for 2D)\r\n  let etaDerivY; // eta-derivative of yCoordinates (only for 2D)\r\n  let detJacobian; // The jacobian of the isoparametric mapping\r\n\r\n  // Initialize jacobianMatrix and residualVector arrays\r\n  for (let nodeIndex = 0; nodeIndex < totalNodes; nodeIndex++) {\r\n    residualVector[nodeIndex] = 0;\r\n    jacobianMatrix.push([]);\r\n    for (let colIndex = 0; colIndex < totalNodes; colIndex++) {\r\n      jacobianMatrix[nodeIndex][colIndex] = 0;\r\n    }\r\n  }\r\n\r\n  // Initialize the basisFunctions class\r\n  const basisFunctionsData = new basisFunctions({\r\n    meshDimension,\r\n    elementOrder,\r\n  });\r\n\r\n  // Initialize the numericalIntegration class\r\n  const numIntegrationData = new numericalIntegration({\r\n    meshDimension,\r\n    elementOrder,\r\n  });\r\n\r\n  // Calculate Gauss points and weights\r\n  let gaussPointsAndWeights = numIntegrationData.getGaussPointsAndWeights();\r\n  gaussPoints = gaussPointsAndWeights.gaussPoints;\r\n  gaussWeights = gaussPointsAndWeights.gaussWeights;\r\n\r\n  // Determine the number of nodes in the reference element based on the first element in the nop array\r\n  const numNodes = nop[0].length;\r\n\r\n  // Matrix assembly\r\n  for (let elementIndex = 0; elementIndex < totalElements; elementIndex++) {\r\n    for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\r\n      // Subtract 1 from nop in order to start numbering from 0\r\n      localToGlobalMap[localNodeIndex] = nop[elementIndex][localNodeIndex] - 1;\r\n    }\r\n\r\n    // Loop over Gauss points\r\n    for (let gaussPointIndex1 = 0; gaussPointIndex1 < gaussPoints.length; gaussPointIndex1++) {\r\n      // 1D solid heat transfer\r\n      if (meshDimension === \"1D\") {\r\n        let basisFunctionsAndDerivatives = basisFunctionsData.getBasisFunctions(\r\n          gaussPoints[gaussPointIndex1]\r\n        );\r\n        basisFunction = basisFunctionsAndDerivatives.basisFunction;\r\n        basisFunctionDerivKsi = basisFunctionsAndDerivatives.basisFunctionDerivKsi;\r\n        xCoordinates = 0;\r\n        ksiDerivX = 0;\r\n        detJacobian = 0;\r\n\r\n        // Isoparametric mapping\r\n        for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\r\n          xCoordinates += nodesXCoordinates[localToGlobalMap[localNodeIndex]] * basisFunction[localNodeIndex];\r\n          ksiDerivX +=\r\n            nodesXCoordinates[localToGlobalMap[localNodeIndex]] * basisFunctionDerivKsi[localNodeIndex];\r\n          detJacobian = ksiDerivX;\r\n        }\r\n\r\n        // Compute x-derivative of basis functions\r\n        for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\r\n          basisFunctionDerivX[localNodeIndex] = basisFunctionDerivKsi[localNodeIndex] / detJacobian; // The x-derivative of the n basis function\r\n        }\r\n\r\n        // Computation of Galerkin's residuals and Jacobian matrix\r\n        for (let localNodeIndex1 = 0; localNodeIndex1 < numNodes; localNodeIndex1++) {\r\n          let localToGlobalMap1 = localToGlobalMap[localNodeIndex1];\r\n          // residualVector is zero for this case\r\n\r\n          for (let localNodeIndex2 = 0; localNodeIndex2 < numNodes; localNodeIndex2++) {\r\n            let localToGlobalMap2 = localToGlobalMap[localNodeIndex2];\r\n            jacobianMatrix[localToGlobalMap1][localToGlobalMap2] +=\r\n              -gaussWeights[gaussPointIndex1] *\r\n              detJacobian *\r\n              (basisFunctionDerivX[localNodeIndex1] * basisFunctionDerivX[localNodeIndex2]);\r\n          }\r\n        }\r\n        // 2D solid heat transfer\r\n      } else if (meshDimension === \"2D\") {\r\n        for (let gaussPointIndex2 = 0; gaussPointIndex2 < gaussPoints.length; gaussPointIndex2++) {\r\n          // Initialise variables for isoparametric mapping\r\n          let basisFunctionsAndDerivatives = basisFunctionsData.getBasisFunctions(\r\n            gaussPoints[gaussPointIndex1],\r\n            gaussPoints[gaussPointIndex2]\r\n          );\r\n          basisFunction = basisFunctionsAndDerivatives.basisFunction;\r\n          basisFunctionDerivKsi = basisFunctionsAndDerivatives.basisFunctionDerivKsi;\r\n          basisFunctionDerivEta = basisFunctionsAndDerivatives.basisFunctionDerivEta;\r\n          xCoordinates = 0;\r\n          yCoordinates = 0;\r\n          ksiDerivX = 0;\r\n          etaDerivX = 0;\r\n          ksiDerivY = 0;\r\n          etaDerivY = 0;\r\n          detJacobian = 0;\r\n\r\n          // Isoparametric mapping\r\n          for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\r\n            xCoordinates +=\r\n              nodesXCoordinates[localToGlobalMap[localNodeIndex]] * basisFunction[localNodeIndex];\r\n            yCoordinates +=\r\n              nodesYCoordinates[localToGlobalMap[localNodeIndex]] * basisFunction[localNodeIndex];\r\n            ksiDerivX +=\r\n              nodesXCoordinates[localToGlobalMap[localNodeIndex]] * basisFunctionDerivKsi[localNodeIndex];\r\n            etaDerivX +=\r\n              nodesXCoordinates[localToGlobalMap[localNodeIndex]] * basisFunctionDerivEta[localNodeIndex];\r\n            ksiDerivY +=\r\n              nodesYCoordinates[localToGlobalMap[localNodeIndex]] * basisFunctionDerivKsi[localNodeIndex];\r\n            etaDerivY +=\r\n              nodesYCoordinates[localToGlobalMap[localNodeIndex]] * basisFunctionDerivEta[localNodeIndex];\r\n            detJacobian = meshDimension === \"2D\" ? ksiDerivX * etaDerivY - etaDerivX * ksiDerivY : ksiDerivX;\r\n          }\r\n\r\n          // Compute x-derivative and y-derivative of basis functions\r\n          for (let localNodeIndex = 0; localNodeIndex < numNodes; localNodeIndex++) {\r\n            basisFunctionDerivX[localNodeIndex] =\r\n              (etaDerivY * basisFunctionDerivKsi[localNodeIndex] -\r\n                ksiDerivY * basisFunctionDerivEta[localNodeIndex]) /\r\n              detJacobian; // The x-derivative of the n basis function\r\n            basisFunctionDerivY[localNodeIndex] =\r\n              (ksiDerivX * basisFunctionDerivEta[localNodeIndex] -\r\n                etaDerivX * basisFunctionDerivKsi[localNodeIndex]) /\r\n              detJacobian; // The y-derivative of the n basis function\r\n          }\r\n\r\n          // Computation of Galerkin's residuals and Jacobian matrix\r\n          for (let localNodeIndex1 = 0; localNodeIndex1 < numNodes; localNodeIndex1++) {\r\n            let localToGlobalMap1 = localToGlobalMap[localNodeIndex1];\r\n            // residualVector is zero for this case\r\n\r\n            for (let localNodeIndex2 = 0; localNodeIndex2 < numNodes; localNodeIndex2++) {\r\n              let localToGlobalMap2 = localToGlobalMap[localNodeIndex2];\r\n              jacobianMatrix[localToGlobalMap1][localToGlobalMap2] +=\r\n                -gaussWeights[gaussPointIndex1] *\r\n                gaussWeights[gaussPointIndex2] *\r\n                detJacobian *\r\n                (basisFunctionDerivX[localNodeIndex1] * basisFunctionDerivX[localNodeIndex2] +\r\n                  basisFunctionDerivY[localNodeIndex1] * basisFunctionDerivY[localNodeIndex2]);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Create an instance of ThermalBoundaryConditions\r\n  debugLog(\"Applying thermal boundary conditions...\");\r\n  const thermalBoundaryConditions = new ThermalBoundaryConditions(\r\n    boundaryConditions,\r\n    boundaryElements,\r\n    nop,\r\n    meshDimension,\r\n    elementOrder\r\n  );\r\n\r\n  // Impose Convection boundary conditions\r\n  thermalBoundaryConditions.imposeConvectionBoundaryConditions(\r\n    residualVector,\r\n    jacobianMatrix,\r\n    gaussPoints,\r\n    gaussWeights,\r\n    nodesXCoordinates,\r\n    nodesYCoordinates,\r\n    basisFunctionsData\r\n  );\r\n  debugLog(\"Convection boundary conditions applied\");\r\n\r\n  // Impose ConstantTemp boundary conditions\r\n  thermalBoundaryConditions.imposeConstantTempBoundaryConditions(residualVector, jacobianMatrix);\r\n  debugLog(\"Constant temperature boundary conditions applied\");\r\n\r\n  basicLog(\"Solid heat transfer matrix assembly completed\");\r\n\r\n  return {\r\n    jacobianMatrix,\r\n    residualVector,\r\n    nodesCoordinates: {\r\n      nodesXCoordinates,\r\n      nodesYCoordinates,\r\n    },\r\n  };\r\n}\r\n","//   ______ ______           _____           _       _     //\r\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\r\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\r\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\r\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\r\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\r\n//                                            | |   | |    //\r\n//                                            |_|   | |_   //\r\n//       Website: https://feascript.com/             \\__|  //\r\n\r\n/**\r\n * Function to solve a system of linear equations using the Jacobi iterative method\r\n * @param {array} A - The coefficient matrix (must be square)\r\n * @param {array} b - The right-hand side vector\r\n * @param {array} x0 - Initial guess for solution vector\r\n * @param {number} [maxIterations=100] - Maximum number of iterations\r\n * @param {number} [tolerance=1e-7] - Convergence tolerance\r\n * @returns {object} An object containing:\r\n *  - solution: The solution vector\r\n *  - iterations: The number of iterations performed\r\n *  - converged: Boolean indicating whether the method converged\r\n */\r\nexport function jacobiMethod(A, b, x0, maxIterations = 100, tolerance = 1e-7) {\r\n  const n = A.length; // Size of the square matrix\r\n  let x = [...x0]; // Current solution (starts with initial guess)\r\n  let xNew = new Array(n); // Next iteration's solution\r\n\r\n  for (let iteration = 0; iteration < maxIterations; iteration++) {\r\n    // Perform one iteration\r\n    for (let i = 0; i < n; i++) {\r\n      let sum = 0;\r\n      // Calculate sum of A[i][j] * x[j] for j  i\r\n      for (let j = 0; j < n; j++) {\r\n        if (j !== i) {\r\n          sum += A[i][j] * x[j];\r\n        }\r\n      }\r\n      // Update xNew[i] using the Jacobi formula\r\n      xNew[i] = (b[i] - sum) / A[i][i];\r\n    }\r\n\r\n    // Check convergence\r\n    let maxDiff = 0;\r\n    for (let i = 0; i < n; i++) {\r\n      maxDiff = Math.max(maxDiff, Math.abs(xNew[i] - x[i]));\r\n    }\r\n\r\n    // Update x for next iteration\r\n    x = [...xNew];\r\n\r\n    // Successfully converged if maxDiff is less than tolerance\r\n    if (maxDiff < tolerance) {\r\n      return {\r\n        solution: x,\r\n        iterations: iteration + 1,\r\n        converged: true,\r\n      };\r\n    }\r\n  }\r\n\r\n  // maxIterations were reached without convergence\r\n  return {\r\n    solution: x,\r\n    iterations: maxIterations,\r\n    converged: false,\r\n  };\r\n}\r\n","//   ______ ______           _____           _       _     //\r\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\r\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\r\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\r\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\r\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\r\n//                                            | |   | |    //\r\n//                                            |_|   | |_   //\r\n//       Website: https://feascript.com/             \\__|  //\r\n\r\n// External imports\r\nimport * as Comlink from \"../vendor/comlink.mjs\";\r\n\r\n// Internal imports\r\nimport { basicLog } from \"../utilities/loggingScript.js\";\r\n\r\n/**\r\n * Class to facilitate communication with web workers for FEAScript operations\r\n */\r\nexport class FEAScriptWorker {\r\n  /**\r\n   * Constructor to initialize the FEAScriptWorker class\r\n   * Sets up the worker and initializes the workerWrapper.\r\n   */\r\n  constructor() {\r\n    this.worker = null;\r\n    this.feaWorker = null;\r\n    this.isReady = false;\r\n\r\n    this._initWorker();\r\n  }\r\n\r\n  /**\r\n   * Function to initialize the web worker and wrap it using Comlink.\r\n   * @private\r\n   * @throws Will throw an error if the worker fails to initialize.\r\n   */\r\n  async _initWorker() {\r\n    try {\r\n      this.worker = new Worker(new URL(\"./wrapperScript.js\", import.meta.url), {\r\n        type: \"module\",\r\n      });\r\n\r\n      this.worker.onerror = (event) => {\r\n        console.error(\"FEAScriptWorker: Worker error:\", event);\r\n      };\r\n      const workerWrapper = Comlink.wrap(this.worker);\r\n\r\n      this.feaWorker = await new workerWrapper();\r\n\r\n      this.isReady = true;\r\n    } catch (error) {\r\n      console.error(\"Failed to initialize worker\", error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Function to ensure that the worker is ready before performing any operations.\r\n   * @private\r\n   * @returns {Promise<void>} Resolves when the worker is ready.\r\n   * @throws Will throw an error if the worker is not ready within the timeout period.\r\n   */\r\n  async _ensureReady() {\r\n    if (this.isReady) return Promise.resolve();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      let attempts = 0;\r\n      const maxAttempts = 50; // 5 seconds max\r\n\r\n      const checkReady = () => {\r\n        attempts++;\r\n        if (this.isReady) {\r\n          resolve();\r\n        } else if (attempts >= maxAttempts) {\r\n          reject(new Error(\"Timeout waiting for worker to be ready\"));\r\n        } else {\r\n          setTimeout(checkReady, 1000);\r\n        }\r\n      };\r\n      checkReady();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Function to set the solver configuration in the worker.\r\n   * @param {string} solverConfig - The solver configuration to set.\r\n   * @returns {Promise<boolean>} Resolves when the configuration is set.\r\n   */\r\n  async setSolverConfig(solverConfig) {\r\n    await this._ensureReady();\r\n    basicLog(`FEAScriptWorker: Setting solver config to: ${solverConfig}`);\r\n    return this.feaWorker.setSolverConfig(solverConfig);\r\n  }\r\n\r\n  /**\r\n   * Sets the mesh configuration in the worker.\r\n   * @param {object} meshConfig - The mesh configuration to set.\r\n   * @returns {Promise<boolean>} Resolves when the configuration is set.\r\n   */\r\n  async setMeshConfig(meshConfig) {\r\n    await this._ensureReady();\r\n    basicLog(`FEAScriptWorker: Setting mesh config`);\r\n    return this.feaWorker.setMeshConfig(meshConfig);\r\n  }\r\n\r\n  /**\r\n   * Adds a boundary condition to the worker.\r\n   * @param {string} boundaryKey - The key identifying the boundary.\r\n   * @param {array} condition - The boundary condition to add.\r\n   * @returns {Promise<boolean>} Resolves when the boundary condition is added.\r\n   */\r\n  async addBoundaryCondition(boundaryKey, condition) {\r\n    await this._ensureReady();\r\n    basicLog(`FEAScriptWorker: Adding boundary condition for boundary: ${boundaryKey}`);\r\n    return this.feaWorker.addBoundaryCondition(boundaryKey, condition);\r\n  }\r\n\r\n  /**\r\n   * Sets the solver method in the worker.\r\n   * @param {string} solverMethod - The solver method to set.\r\n   * @returns {Promise<boolean>} Resolves when the solver method is set.\r\n   */\r\n  async setSolverMethod(solverMethod) {\r\n    await this._ensureReady();\r\n    basicLog(`FEAScriptWorker: Setting solver method to: ${solverMethod}`);\r\n    return this.feaWorker.setSolverMethod(solverMethod);\r\n  }\r\n\r\n  /**\r\n   * Requests the worker to solve the problem.\r\n   * @returns {Promise<object>} Resolves with the solution result.\r\n   */\r\n  async solve() {\r\n    await this._ensureReady();\r\n    basicLog(\"FEAScriptWorker: Requesting solution from worker...\");\r\n\r\n    const startTime = performance.now();\r\n    const result = await this.feaWorker.solve();\r\n    const endTime = performance.now();\r\n\r\n    basicLog(`FEAScriptWorker: Solution completed in ${((endTime - startTime) / 1000).toFixed(2)}s`);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Retrieves model information from the worker.\r\n   * @returns {Promise<object>} Resolves with the model information.\r\n   */\r\n  async getModelInfo() {\r\n    await this._ensureReady();\r\n    return this.feaWorker.getModelInfo();\r\n  }\r\n\r\n  /**\r\n   * Sends a ping request to the worker to check its availability.\r\n   * @returns {Promise<boolean>} Resolves if the worker responds.\r\n   */\r\n  async ping() {\r\n    await this._ensureReady();\r\n    return this.feaWorker.ping();\r\n  }\r\n\r\n  /**\r\n   * Terminates the worker and cleans up resources.\r\n   */\r\n  terminate() {\r\n    if (this.worker) {\r\n      this.worker.terminate();\r\n      this.worker = null;\r\n      this.feaWorker = null;\r\n      this.isReady = false;\r\n    }\r\n  }\r\n}\r\n","//   ______ ______           _____           _       _     //\r\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\r\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\r\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\r\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\r\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\r\n//                                            | |   | |    //\r\n//                                            |_|   | |_   //\r\n//       Website: https://feascript.com/             \\__|  //\r\n\r\n// Internal imports\r\nimport { basicLog, debugLog, errorLog } from \"../utilities/loggingScript.js\";\r\n\r\n/**\r\n * Function to import mesh data from Gmsh format containing quadrilateral and triangular elements\r\n * @param {File} file - The Gmsh file to be parsed (.msh version 4.1)\r\n * @returns {object} The parsed mesh data including node coordinates, element connectivity, and boundary conditions\r\n */\r\nconst importGmshQuadTri = async (file) => {\r\n  let result = {\r\n    nodesXCoordinates: [],\r\n    nodesYCoordinates: [],\r\n    nodalNumbering: {\r\n      quadElements: [],\r\n      triangleElements: [],\r\n    },\r\n    boundaryElements: [],\r\n    boundaryConditions: [],\r\n    boundaryNodePairs: {}, // Store boundary node pairs for processing in meshGenerationScript\r\n    gmshV: 0,\r\n    ascii: false,\r\n    fltBytes: \"8\",\r\n    totalNodesX: 0,\r\n    totalNodesY: 0,\r\n    physicalPropMap: [],\r\n    elementTypes: {},\r\n  };\r\n\r\n  let content = await file.text();\r\n  let lines = content\r\n    .split(\"\\n\")\r\n    .map((line) => line.trim())\r\n    .filter((line) => line !== \"\" && line !== \" \");\r\n\r\n  let section = \"\";\r\n  let lineIndex = 0;\r\n\r\n  let nodeEntityBlocks = 0;\r\n  let totalNodes = 0;\r\n  let nodeBlocksProcessed = 0;\r\n  let currentNodeBlock = { numNodes: 0 };\r\n  let nodeTagsCollected = 0;\r\n  let nodeTags = [];\r\n  let nodeCoordinatesCollected = 0;\r\n\r\n  let elementEntityBlocks = 0;\r\n  let totalElements = 0;\r\n  let elementBlocksProcessed = 0;\r\n  let currentElementBlock = {\r\n    dim: 0,\r\n    tag: 0,\r\n    elementType: 0,\r\n    numElements: 0,\r\n  };\r\n  let elementsProcessedInBlock = 0;\r\n\r\n  let boundaryElementsByTag = {};\r\n\r\n  while (lineIndex < lines.length) {\r\n    const line = lines[lineIndex];\r\n\r\n    if (line === \"$MeshFormat\") {\r\n      section = \"meshFormat\";\r\n      lineIndex++;\r\n      continue;\r\n    } else if (line === \"$EndMeshFormat\") {\r\n      section = \"\";\r\n      lineIndex++;\r\n      continue;\r\n    } else if (line === \"$PhysicalNames\") {\r\n      section = \"physicalNames\";\r\n      lineIndex++;\r\n      continue;\r\n    } else if (line === \"$EndPhysicalNames\") {\r\n      section = \"\";\r\n      lineIndex++;\r\n      continue;\r\n    } else if (line === \"$Entities\") {\r\n      section = \"entities\";\r\n      lineIndex++;\r\n      continue;\r\n    } else if (line === \"$EndEntities\") {\r\n      section = \"\";\r\n      lineIndex++;\r\n      continue;\r\n    } else if (line === \"$Nodes\") {\r\n      section = \"nodes\";\r\n      lineIndex++;\r\n      continue;\r\n    } else if (line === \"$EndNodes\") {\r\n      section = \"\";\r\n      lineIndex++;\r\n      continue;\r\n    } else if (line === \"$Elements\") {\r\n      section = \"elements\";\r\n      lineIndex++;\r\n      continue;\r\n    } else if (line === \"$EndElements\") {\r\n      section = \"\";\r\n      lineIndex++;\r\n      continue;\r\n    }\r\n\r\n    const parts = line.split(/\\s+/).filter((part) => part !== \"\");\r\n\r\n    if (section === \"meshFormat\") {\r\n      result.gmshV = parseFloat(parts[0]);\r\n      result.ascii = parts[1] === \"0\";\r\n      result.fltBytes = parts[2];\r\n    } else if (section === \"physicalNames\") {\r\n      if (parts.length >= 3) {\r\n        if (!/^\\d+$/.test(parts[0])) {\r\n          lineIndex++;\r\n          continue;\r\n        }\r\n\r\n        const dimension = parseInt(parts[0], 10);\r\n        const tag = parseInt(parts[1], 10);\r\n        let name = parts.slice(2).join(\" \");\r\n        name = name.replace(/^\"|\"$/g, \"\");\r\n\r\n        result.physicalPropMap.push({\r\n          tag,\r\n          dimension,\r\n          name,\r\n        });\r\n      }\r\n    } else if (section === \"nodes\") {\r\n      if (nodeEntityBlocks === 0) {\r\n        nodeEntityBlocks = parseInt(parts[0], 10);\r\n        totalNodes = parseInt(parts[1], 10);\r\n        result.nodesXCoordinates = new Array(totalNodes).fill(0);\r\n        result.nodesYCoordinates = new Array(totalNodes).fill(0);\r\n        lineIndex++;\r\n        continue;\r\n      }\r\n\r\n      if (nodeBlocksProcessed < nodeEntityBlocks && currentNodeBlock.numNodes === 0) {\r\n        currentNodeBlock = {\r\n          dim: parseInt(parts[0], 10),\r\n          tag: parseInt(parts[1], 10),\r\n          parametric: parseInt(parts[2], 10),\r\n          numNodes: parseInt(parts[3], 10),\r\n        };\r\n\r\n        nodeTags = [];\r\n        nodeTagsCollected = 0;\r\n        nodeCoordinatesCollected = 0;\r\n\r\n        lineIndex++;\r\n        continue;\r\n      }\r\n\r\n      if (nodeTagsCollected < currentNodeBlock.numNodes) {\r\n        for (let i = 0; i < parts.length && nodeTagsCollected < currentNodeBlock.numNodes; i++) {\r\n          nodeTags.push(parseInt(parts[i], 10));\r\n          nodeTagsCollected++;\r\n        }\r\n\r\n        if (nodeTagsCollected < currentNodeBlock.numNodes) {\r\n          lineIndex++;\r\n          continue;\r\n        }\r\n\r\n        lineIndex++;\r\n        continue;\r\n      }\r\n\r\n      if (nodeCoordinatesCollected < currentNodeBlock.numNodes) {\r\n        const nodeTag = nodeTags[nodeCoordinatesCollected] - 1;\r\n        const x = parseFloat(parts[0]);\r\n        const y = parseFloat(parts[1]);\r\n\r\n        result.nodesXCoordinates[nodeTag] = x;\r\n        result.nodesYCoordinates[nodeTag] = y;\r\n        result.totalNodesX++;\r\n        result.totalNodesY++;\r\n\r\n        nodeCoordinatesCollected++;\r\n\r\n        if (nodeCoordinatesCollected === currentNodeBlock.numNodes) {\r\n          nodeBlocksProcessed++;\r\n          currentNodeBlock = { numNodes: 0 };\r\n        }\r\n      }\r\n    } else if (section === \"elements\") {\r\n      if (elementEntityBlocks === 0) {\r\n        elementEntityBlocks = parseInt(parts[0], 10);\r\n        totalElements = parseInt(parts[1], 10);\r\n        lineIndex++;\r\n        continue;\r\n      }\r\n\r\n      if (elementBlocksProcessed < elementEntityBlocks && currentElementBlock.numElements === 0) {\r\n        currentElementBlock = {\r\n          dim: parseInt(parts[0], 10),\r\n          tag: parseInt(parts[1], 10),\r\n          elementType: parseInt(parts[2], 10),\r\n          numElements: parseInt(parts[3], 10),\r\n        };\r\n\r\n        result.elementTypes[currentElementBlock.elementType] =\r\n          (result.elementTypes[currentElementBlock.elementType] || 0) + currentElementBlock.numElements;\r\n\r\n        elementsProcessedInBlock = 0;\r\n        lineIndex++;\r\n        continue;\r\n      }\r\n\r\n      if (elementsProcessedInBlock < currentElementBlock.numElements) {\r\n        const elementTag = parseInt(parts[0], 10);\r\n        const nodeIndices = parts.slice(1).map((idx) => parseInt(idx, 10));\r\n\r\n        if (currentElementBlock.elementType === 1 || currentElementBlock.elementType === 8) {\r\n          const physicalTag = currentElementBlock.tag;\r\n\r\n          if (!boundaryElementsByTag[physicalTag]) {\r\n            boundaryElementsByTag[physicalTag] = [];\r\n          }\r\n\r\n          boundaryElementsByTag[physicalTag].push(nodeIndices);\r\n\r\n          // Store boundary node pairs for later processing in meshGenerationScript\r\n          if (!result.boundaryNodePairs[physicalTag]) {\r\n            result.boundaryNodePairs[physicalTag] = [];\r\n          }\r\n          result.boundaryNodePairs[physicalTag].push(nodeIndices);\r\n        } else if (currentElementBlock.elementType === 2) {\r\n          // Linear triangle elements (3 nodes)\r\n          result.nodalNumbering.triangleElements.push(nodeIndices);\r\n        } else if (currentElementBlock.elementType === 3) {\r\n          // Linear quadrilateral elements (4 nodes)\r\n          result.nodalNumbering.quadElements.push(nodeIndices);\r\n        } else if (currentElementBlock.elementType === 10) {\r\n          // Quadratic quadrilateral elements (9 nodes)\r\n          result.nodalNumbering.quadElements.push(nodeIndices);\r\n        }\r\n\r\n        elementsProcessedInBlock++;\r\n\r\n        if (elementsProcessedInBlock === currentElementBlock.numElements) {\r\n          elementBlocksProcessed++;\r\n          currentElementBlock = { numElements: 0 };\r\n        }\r\n      }\r\n    }\r\n\r\n    lineIndex++;\r\n  }\r\n\r\n  // Store boundary conditions information\r\n  result.physicalPropMap.forEach((prop) => {\r\n    if (prop.dimension === 1) {\r\n      const boundaryNodes = boundaryElementsByTag[prop.tag] || [];\r\n\r\n      if (boundaryNodes.length > 0) {\r\n        result.boundaryConditions.push({\r\n          name: prop.name,\r\n          tag: prop.tag,\r\n          nodes: boundaryNodes,\r\n        });\r\n      }\r\n    }\r\n  });\r\n\r\n  debugLog(\r\n    `Parsed boundary node pairs by physical tag: ${JSON.stringify(\r\n      result.boundaryNodePairs\r\n    )}. These pairs will be used to identify boundary elements in the mesh.`\r\n  );\r\n\r\n  return result;\r\n};\r\n\r\nexport { importGmshQuadTri };\r\n","//   ______ ______           _____           _       _     //\r\n//  |  ____|  ____|   /\\    / ____|         (_)     | |    //\r\n//  | |__  | |__     /  \\  | (___   ___ ____ _ ____ | |_   //\r\n//  |  __| |  __|   / /\\ \\  \\___ \\ / __|  __| |  _ \\| __|  //\r\n//  | |    | |____ / ____ \\ ____) | (__| |  | | |_) | |    //\r\n//  |_|    |______/_/    \\_\\_____/ \\___|_|  |_|  __/| |    //\r\n//                                            | |   | |    //\r\n//                                            |_|   | |_   //\r\n//       Website: https://feascript.com/             \\__|  //\r\n\r\n/**\r\n * Function to create plots of the solution vector\r\n * @param {*} solutionVector - The computed solution vector\r\n * @param {*} nodesCoordinates - Object containing x and y coordinates for the nodes\r\n * @param {string} solverConfig - Parameter specifying the type of solver\r\n * @param {string} meshDimension - The dimension of the solution\r\n * @param {string} plotType - The type of plot\r\n * @param {string} plotDivId - The id of the div where the plot will be rendered\r\n * @param {string} [meshType=\"structured\"] - Type of mesh: \"structured\" or \"unstructured\"\r\n */\r\nexport function plotSolution(\r\n  solutionVector,\r\n  nodesCoordinates,\r\n  solverConfig,\r\n  meshDimension,\r\n  plotType,\r\n  plotDivId,\r\n  meshType = \"structured\"\r\n) {\r\n  const { nodesXCoordinates, nodesYCoordinates } = nodesCoordinates;\r\n\r\n  if (meshDimension === \"1D\" && plotType === \"line\") {\r\n    // Check if solutionVector is a nested array\r\n    let yData;\r\n    if (solutionVector.length > 0 && Array.isArray(solutionVector[0])) {\r\n      yData = solutionVector.map((arr) => arr[0]);\r\n    } else {\r\n      yData = solutionVector;\r\n    }\r\n    let xData = Array.from(nodesXCoordinates);\r\n\r\n    let lineData = {\r\n      x: xData,\r\n      y: yData,\r\n      mode: \"lines\",\r\n      type: \"scatter\",\r\n      line: { color: \"rgb(219, 64, 82)\", width: 2 },\r\n      name: \"Solution\",\r\n    };\r\n\r\n    let maxWindowWidth = Math.min(window.innerWidth, 700);\r\n    let maxPlotWidth = Math.max(...xData);\r\n    let zoomFactor = maxWindowWidth / maxPlotWidth;\r\n    let plotWidth = Math.max(zoomFactor * maxPlotWidth, 400);\r\n    let plotHeight = 350;\r\n\r\n    let layout = {\r\n      title: `line plot - ${solverConfig}`,\r\n      width: plotWidth,\r\n      height: plotHeight,\r\n      xaxis: { title: \"x\" },\r\n      yaxis: { title: \"Solution\" },\r\n      margin: { l: 70, r: 40, t: 50, b: 50 },\r\n    };\r\n\r\n    Plotly.newPlot(plotDivId, [lineData], layout, { responsive: true });\r\n  } else if (meshDimension === \"2D\" && plotType === \"contour\") {\r\n    // Use the user-provided mesh type\r\n    const isStructured = meshType === \"structured\";\r\n    \r\n    // For auto-detection (if needed)\r\n    const uniqueXCoords = new Set(nodesXCoordinates).size;\r\n    const uniqueYCoords = new Set(nodesYCoordinates).size;\r\n    \r\n    // Extract scalar values from solution vector\r\n    let zValues = Array.isArray(solutionVector[0]) \r\n      ? solutionVector.map(val => val[0]) \r\n      : solutionVector;\r\n    \r\n    // Common sizing parameters for both plot types\r\n    let maxWindowWidth = Math.min(window.innerWidth, 700);\r\n    let maxX = Math.max(...nodesXCoordinates);\r\n    let maxY = Math.max(...nodesYCoordinates);\r\n    let aspectRatio = maxY / maxX;\r\n    let plotWidth = Math.min(maxWindowWidth, 600);\r\n    let plotHeight = plotWidth * aspectRatio * 0.8; // Slightly reduce height for better appearance\r\n    \r\n    // Common layout properties\r\n    let layout = {\r\n      title: `${plotType} plot - ${solverConfig}`,\r\n      width: plotWidth,\r\n      height: plotHeight,\r\n      xaxis: { title: \"x\" },\r\n      yaxis: { title: \"y\" },\r\n      margin: { l: 50, r: 50, t: 50, b: 50 },\r\n      hovermode: 'closest'\r\n    };\r\n    \r\n    if (isStructured) {\r\n      // Calculate the number of nodes along the x-axis and y-axis\r\n      const numNodesX = uniqueXCoords;\r\n      const numNodesY = uniqueYCoords;\r\n\r\n      // Reshape the nodesXCoordinates and nodesYCoordinates arrays to match the grid dimensions\r\n      let reshapedXCoordinates = math.reshape(Array.from(nodesXCoordinates), [numNodesX, numNodesY]);\r\n      let reshapedYCoordinates = math.reshape(Array.from(nodesYCoordinates), [numNodesX, numNodesY]);\r\n\r\n      // Reshape the solution array to match the grid dimensions\r\n      let reshapedSolution = math.reshape(Array.from(solutionVector), [numNodesX, numNodesY]);\r\n\r\n      // Transpose the reshapedSolution array to get column-wise data\r\n      let transposedSolution = math.transpose(reshapedSolution);\r\n\r\n      // Create an array for x-coordinates used in the contour plot\r\n      let reshapedXForPlot = [];\r\n      for (let i = 0; i < numNodesX * numNodesY; i += numNodesY) {\r\n        let xValue = nodesXCoordinates[i];\r\n        reshapedXForPlot.push(xValue);\r\n      }\r\n\r\n      // Create the data structure for the contour plot\r\n      let contourData = {\r\n        z: transposedSolution,\r\n        type: \"contour\",\r\n        contours: {\r\n          coloring: \"heatmap\",\r\n          showlabels: false\r\n        },\r\n        //colorscale: 'Viridis',\r\n        colorbar: {\r\n          title: 'Solution'\r\n        },\r\n        x: reshapedXForPlot,\r\n        y: reshapedYCoordinates[0],\r\n        name: 'Solution Field'\r\n      };\r\n\r\n      // Create the plot using Plotly\r\n      Plotly.newPlot(plotDivId, [contourData], layout, { responsive: true });\r\n    } else {\r\n      // Create an interpolated contour plot for the unstructured mesh\r\n      let contourData = {\r\n        x: nodesXCoordinates,\r\n        y: nodesYCoordinates,\r\n        z: zValues,\r\n        type: 'contour',\r\n        contours: {\r\n          coloring: 'heatmap',\r\n          showlabels: false\r\n        },\r\n        //colorscale: 'Viridis',\r\n        colorbar: {\r\n          title: 'Solution'\r\n        },\r\n        name: 'Solution Field'\r\n      };\r\n      \r\n      // Create the plot using only the contour fill\r\n      Plotly.newPlot(plotDivId, [contourData], layout, { responsive: true });\r\n    }\r\n  }\r\n}\r\n"],"names":["numericalIntegration","constructor","meshDimension","elementOrder","this","getGaussPointsAndWeights","gaussPoints","gaussWeights","Math","sqrt","currentLogLevel","debugLog","message","console","log","basicLog","errorLog","basisFunctions","getBasisFunctions","ksi","eta","basisFunction","basisFunctionDerivKsi","basisFunctionDerivEta","l1","c","l2","l3","dl1","dl2","dl3","meshGeneration","numElementsX","maxX","numElementsY","maxY","parsedMesh","generateMesh","nodalNumbering","Array","isArray","quadElements","triangleElements","JSON","stringify","elementTypes","mappedNodalNumbering","elemIdx","length","gmshNodes","feaScriptNodes","push","physicalPropMap","boundaryElements","undefined","fixedBoundaryElements","i","boundaryNodePairs","boundaryElementsProcessed","forEach","prop","dimension","tag","nodesPair","node1","node2","name","foundElement","elemNodes","includes","side","node1Index","indexOf","node2Index","join","generateMeshFromGeometry","nodesXCoordinates","nodesYCoordinates","totalNodesX","totalNodesY","deltaX","deltaY","nodeIndex","generateNodalNumbering","findBoundaryElements","nodeIndexY","nodeIndexX","nnode","maxSides","sideIndex","elementIndexX","elementIndexY","elementIndex","nop","columnCounter","rowCounter","nodeIndex1","nodeIndex2","ThermalBoundaryConditions","boundaryConditions","imposeConstantTempBoundaryConditions","residualVector","jacobianMatrix","Object","keys","boundaryKey","tempValue","globalNodeIndex","colIndex","imposeConvectionBoundaryConditions","basisFunctionsData","convectionHeatTranfCoeff","convectionExtTemp","key","boundaryCondition","convectionCoeff","extTemp","gaussPoint1","gaussPoint2","firstNodeIndex","lastNodeIndex","nodeIncrement","basisFunctionsAndDerivatives","ksiDerivX","ksiDerivY","etaDerivX","etaDerivY","numNodes","tangentVectorLength","localNodeIndex","localNodeIndex2","globalNodeIndex2","gaussPointIndex","proxyMarker","Symbol","createEndpoint","releaseProxy","finalizer","throwMarker","isObject","val","transferHandlers","Map","canHandle","serialize","obj","port1","port2","MessageChannel","expose","deserialize","port","start","wrap","value","serialized","Error","isError","stack","assign","ep","globalThis","allowedOrigins","addEventListener","callback","ev","data","origin","allowedOrigin","RegExp","test","isAllowedOrigin","warn","id","type","path","argumentList","map","fromWireValue","returnValue","parent","slice","reduce","rawValue","apply","proxy","transfers","transferCache","set","transfer","Promise","resolve","catch","then","wireValue","transferables","toWireValue","postMessage","removeEventListener","closeEndPoint","error","TypeError","endpoint","isMessagePort","close","target","pendingListeners","resolver","get","delete","createProxy","throwIfProxyReleased","isReleased","releaseEndpoint","requestResponseMessage","proxyCounter","WeakMap","proxyFinalizers","FinalizationRegistry","newCount","isProxyReleased","Proxy","_target","unregister","unregisterProxy","clear","r","p","toString","bind","_thisArg","rawArgumentList","last","processArguments","construct","register","registerProxy","processed","v","arr","prototype","concat","handler","serializedValue","msg","fill","floor","random","Number","MAX_SAFE_INTEGER","solverConfig","meshConfig","solverMethod","setSolverConfig","setMeshConfig","addBoundaryCondition","condition","setSolverMethod","solve","solutionVector","nodesCoordinates","time","nodesCoordinatesAndNumbering","totalElements","totalNodes","xCoordinates","yCoordinates","detJacobian","localToGlobalMap","basisFunctionDerivX","basisFunctionDerivY","gaussPointsAndWeights","gaussPointIndex1","localNodeIndex1","localToGlobalMap1","localToGlobalMap2","gaussPointIndex2","thermalBoundaryConditions","assembleSolidHeatTransferMat","timeEnd","math","lusolve","jacobiResult","A","b","x0","maxIterations","tolerance","n","x","xNew","iteration","sum","j","maxDiff","max","abs","solution","iterations","converged","jacobiMethod","worker","feaWorker","isReady","_initWorker","Worker","URL","document","location","require","__filename","href","currentScript","tagName","toUpperCase","src","baseURI","onerror","event","workerWrapper","Comlink.wrap","_ensureReady","reject","attempts","checkReady","setTimeout","startTime","performance","now","result","toFixed","getModelInfo","ping","terminate","async","file","gmshV","ascii","fltBytes","lines","text","split","line","trim","filter","section","lineIndex","nodeEntityBlocks","nodeBlocksProcessed","currentNodeBlock","nodeTagsCollected","nodeTags","nodeCoordinatesCollected","elementEntityBlocks","elementBlocksProcessed","currentElementBlock","dim","elementType","numElements","elementsProcessedInBlock","boundaryElementsByTag","parts","part","parseFloat","parseInt","replace","parametric","nodeTag","y","nodeIndices","idx","physicalTag","boundaryNodes","nodes","level","plotType","plotDivId","meshType","yData","xData","from","lineData","mode","color","width","maxWindowWidth","min","window","innerWidth","maxPlotWidth","zoomFactor","layout","title","height","xaxis","yaxis","margin","l","t","Plotly","newPlot","responsive","isStructured","uniqueXCoords","Set","size","uniqueYCoords","zValues","aspectRatio","plotWidth","hovermode","numNodesX","numNodesY","reshape","reshapedYCoordinates","reshapedSolution","transposedSolution","transpose","reshapedXForPlot","xValue","contourData","z","contours","coloring","showlabels","colorbar","commitResponse","fetch","commitData","json","latestCommitDate","Date","commit","committer","date","toLocaleString"],"mappings":"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"}