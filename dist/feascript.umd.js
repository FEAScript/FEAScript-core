!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).FEAScript={})}(this,(function(e){"use strict";function t(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n]*e[n];return t=Math.sqrt(t),t}let n="basic";function o(e){"debug"===n&&console.log("%c[DEBUG] "+e,"color: #2196F3; font-weight: bold;")}function s(e){console.log("%c[INFO] "+e,"color: #4CAF50; font-weight: bold;")}function i(e){console.log("%c[ERROR] "+e,"color: #F44336; font-weight: bold;")}function r(e,t,n,r={}){const{maxIterations:a=1e3,tolerance:l=1e-6}=r;let d=[],c=!0,u=0;if(s(`Solving system using ${e}...`),console.time("systemSolving"),"lusolve"===e){const e=math.sparse(t),o=math.slu(e,1,1);let s=math.lusolve(o,n);d=math.squeeze(s).valueOf()}else if("jacobi"===e){const e=function(e,t,n,o={}){const{maxIterations:s=1e3,tolerance:i=1e-6}=o,r=e.length;let a=[...n],l=new Array(r);for(let n=0;n<s;n++){for(let n=0;n<r;n++){let o=0;for(let t=0;t<r;t++)t!==n&&(o+=e[n][t]*a[t]);l[n]=(t[n]-o)/e[n][n]}let o=0;for(let e=0;e<r;e++)o=Math.max(o,Math.abs(l[e]-a[e]));if(a=[...l],o<i)return{solutionVector:a,iterations:n+1,converged:!0}}return{solutionVector:a,iterations:s,converged:!1}}(t,n,new Array(n.length).fill(0),{maxIterations:a,tolerance:l});e.converged?o(`Jacobi method converged in ${e.iterations} iterations`):o(`Jacobi method did not converge after ${e.iterations} iterations`),d=e.solutionVector,c=e.converged,u=e.iterations}else i(`Unknown solver method: ${e}`);return console.timeEnd("systemSolving"),s("System solved successfully"),{solutionVector:d,converged:c,iterations:u}}function a(e,n,o=100,a=1e-4){let l=0,d=!1,c=0,u=[],h=[],m=[],f=[],p=n.meshData.nodesXCoordinates.length;for(let e=0;e<p;e++)u[e]=0,h[e]=0;for(n.initialSolution&&n.initialSolution.length===p&&(h=[...n.initialSolution]);c<o&&!d;){for(let e=0;e<h.length;e++)h[e]=Number(h[e])+Number(u[e]);({jacobianMatrix:m,residualVector:f}=e(n.meshData,n.boundaryConditions,h,n.eikonalActivationFlag));if(u=r(n.solverMethod,m,f).solutionVector,l=t(u),s(`Newton-Raphson iteration ${c+1}: Error norm = ${l.toExponential(4)}`),l<=a)d=!0;else if(l>100){i(`Solution not converged. Error norm: ${l}`);break}c++}return{solutionVector:h,converged:d,iterations:c,jacobianMatrix:m,residualVector:f}}class l{constructor({meshDimension:e,elementOrder:t}){this.meshDimension=e,this.elementOrder=t}getBasisFunctions(e,t=null){let n=[],o=[],s=[];if("1D"===this.meshDimension)"linear"===this.elementOrder?(n[0]=1-e,n[1]=e,o[0]=-1,o[1]=1):"quadratic"===this.elementOrder&&(n[0]=1-3*e+2*e**2,n[1]=4*e-4*e**2,n[2]=2*e**2-e,o[0]=4*e-3,o[1]=4-8*e,o[2]=4*e-1);else if("2D"===this.meshDimension){if(null===t)return void i("Eta coordinate is required for 2D elements");if("linear"===this.elementOrder){function r(e){return 1-e}n[0]=r(e)*r(t),n[1]=r(e)*t,n[2]=e*r(t),n[3]=e*t,o[0]=-1*r(t),o[1]=-1*t,o[2]=1*r(t),o[3]=1*t,s[0]=-1*r(e),s[1]=1*r(e),s[2]=-1*e,s[3]=1*e}else if("quadratic"===this.elementOrder){function a(e){return 2*e**2-3*e+1}function l(e){return-4*e**2+4*e}function d(e){return 2*e**2-e}function c(e){return 4*e-3}function u(e){return-8*e+4}function h(e){return 4*e-1}n[0]=a(e)*a(t),n[1]=a(e)*l(t),n[2]=a(e)*d(t),n[3]=l(e)*a(t),n[4]=l(e)*l(t),n[5]=l(e)*d(t),n[6]=d(e)*a(t),n[7]=d(e)*l(t),n[8]=d(e)*d(t),o[0]=c(e)*a(t),o[1]=c(e)*l(t),o[2]=c(e)*d(t),o[3]=u(e)*a(t),o[4]=u(e)*l(t),o[5]=u(e)*d(t),o[6]=h(e)*a(t),o[7]=h(e)*l(t),o[8]=h(e)*d(t),s[0]=a(e)*c(t),s[1]=a(e)*u(t),s[2]=a(e)*h(t),s[3]=l(e)*c(t),s[4]=l(e)*u(t),s[5]=l(e)*h(t),s[6]=d(e)*c(t),s[7]=d(e)*u(t),s[8]=d(e)*h(t)}}return{basisFunction:n,basisFunctionDerivKsi:o,basisFunctionDerivEta:s}}}class d{constructor({numElementsX:e=null,maxX:t=null,numElementsY:n=null,maxY:o=null,meshDimension:i=null,elementOrder:r="linear",parsedMesh:a=null}){this.numElementsX=e,this.numElementsY=n,this.maxX=t,this.maxY=o,this.meshDimension=i,this.elementOrder=r,this.parsedMesh=a,this.boundaryElementsProcessed=!1,this.parsedMesh&&(s("Using pre-parsed mesh from gmshReader data for mesh generation."),this.parseMeshFromGmsh())}parseMeshFromGmsh(){if(this.parsedMesh.nodalNumbering||i("No valid nodal numbering found in the parsed mesh."),"object"==typeof this.parsedMesh.nodalNumbering&&!Array.isArray(this.parsedMesh.nodalNumbering)){const e=this.parsedMesh.nodalNumbering.quadElements||[];if(this.parsedMesh.nodalNumbering.triangleElements,o("Initial parsed mesh nodal numbering from GMSH format: "+JSON.stringify(this.parsedMesh.nodalNumbering)),this.parsedMesh.elementTypes[3]||this.parsedMesh.elementTypes[10]){const t=[];for(let n=0;n<e.length;n++){const o=e[n],s=new Array(o.length);4===o.length?(s[0]=o[0],s[1]=o[3],s[2]=o[1],s[3]=o[2]):9===o.length&&(s[0]=o[0],s[1]=o[7],s[2]=o[3],s[3]=o[4],s[4]=o[8],s[5]=o[6],s[6]=o[1],s[7]=o[5],s[8]=o[2]),t.push(s)}this.parsedMesh.nodalNumbering=t}else this.parsedMesh.elementTypes[2]&&i("Element type is neither triangle nor quad; mapping for this type is not implemented yet.");if(o("Nodal numbering after mapping from GMSH to FEAScript format: "+JSON.stringify(this.parsedMesh.nodalNumbering)),this.parsedMesh.physicalPropMap&&this.parsedMesh.boundaryElements){if(Array.isArray(this.parsedMesh.boundaryElements)&&this.parsedMesh.boundaryElements.length>0&&void 0===this.parsedMesh.boundaryElements[0]){const e=[];for(let t=1;t<this.parsedMesh.boundaryElements.length;t++)this.parsedMesh.boundaryElements[t]&&e.push(this.parsedMesh.boundaryElements[t]);this.parsedMesh.boundaryElements=e}if(this.parsedMesh.boundaryNodePairs&&!this.parsedMesh.boundaryElementsProcessed&&(this.parsedMesh.boundaryElements=[],this.parsedMesh.physicalPropMap.forEach((e=>{if(1===e.dimension){const t=this.parsedMesh.boundaryNodePairs[e.tag]||[];t.length>0&&(this.parsedMesh.boundaryElements[e.tag]||(this.parsedMesh.boundaryElements[e.tag]=[]),t.forEach((t=>{const n=t[0],s=t[1];o(`Processing boundary node pair: [${n}, ${s}] for boundary ${e.tag} (${e.name||"unnamed"})`);let r=!1;for(let t=0;t<this.parsedMesh.nodalNumbering.length;t++){const i=this.parsedMesh.nodalNumbering[t];if(4===i.length){if(i.includes(n)&&i.includes(s)){let a;const l=i.indexOf(n),d=i.indexOf(s);o(`  Found element ${t} containing boundary nodes. Element nodes: [${i.join(", ")}]`),o(`  Node ${n} is at index ${l}, Node ${s} is at index ${d} in the element`),0===l&&2===d||2===l&&0===d?(a=0,o(`  These nodes form the BOTTOM side (${a}) of element ${t}`)):0===l&&1===d||1===l&&0===d?(a=1,o(`  These nodes form the LEFT side (${a}) of element ${t}`)):1===l&&3===d||3===l&&1===d?(a=2,o(`  These nodes form the TOP side (${a}) of element ${t}`)):(2===l&&3===d||3===l&&2===d)&&(a=3,o(`  These nodes form the RIGHT side (${a}) of element ${t}`)),this.parsedMesh.boundaryElements[e.tag].push([t,a]),o(`  Added element-side pair [${t}, ${a}] to boundary tag ${e.tag}`),r=!0;break}}else if(9===i.length&&i.includes(n)&&i.includes(s)){let a;const l=i.indexOf(n),d=i.indexOf(s);o(`  Found element ${t} containing boundary nodes. Element nodes: [${i.join(", ")}]`),o(`  Node ${n} is at index ${l}, Node ${s} is at index ${d} in the element`),0===l&&6===d||6===l&&0===d||0===l&&3===d||3===l&&0===d||3===l&&6===d||6===l&&3===d?(a=0,o(`  These nodes form the BOTTOM side (${a}) of element ${t}`)):0===l&&2===d||2===l&&0===d||0===l&&1===d||1===l&&0===d||1===l&&2===d||2===l&&1===d?(a=1,o(`  These nodes form the LEFT side (${a}) of element ${t}`)):2===l&&8===d||8===l&&2===d||2===l&&5===d||5===l&&2===d||5===l&&8===d||8===l&&5===d?(a=2,o(`  These nodes form the TOP side (${a}) of element ${t}`)):(6===l&&8===d||8===l&&6===d||6===l&&7===d||7===l&&6===d||7===l&&8===d||8===l&&7===d)&&(a=3,o(`  These nodes form the RIGHT side (${a}) of element ${t}`)),this.parsedMesh.boundaryElements[e.tag].push([t,a]),o(`  Added element-side pair [${t}, ${a}] to boundary tag ${e.tag}`),r=!0;break}}r||i(`Could not find element containing boundary nodes ${n} and ${s}. Boundary may be incomplete.`)})))}})),this.boundaryElementsProcessed=!0,this.parsedMesh.boundaryElements.length>0&&void 0===this.parsedMesh.boundaryElements[0])){const e=[];for(let t=1;t<this.parsedMesh.boundaryElements.length;t++)this.parsedMesh.boundaryElements[t]&&e.push(this.parsedMesh.boundaryElements[t]);this.parsedMesh.boundaryElements=e}}}return this.parsedMesh}}class c extends d{constructor({numElementsX:e=null,maxX:t=null,elementOrder:n="linear",parsedMesh:o=null}){super({numElementsX:e,maxX:t,numElementsY:1,maxY:0,meshDimension:"1D",elementOrder:n,parsedMesh:o}),null!==this.numElementsX&&null!==this.maxX||i("numElementsX and maxX are required parameters when generating a 1D mesh from geometry")}generateMesh(){let e=[];let t,n;if("linear"===this.elementOrder){t=this.numElementsX+1,n=(this.maxX-0)/this.numElementsX,e[0]=0;for(let o=1;o<t;o++)e[o]=e[o-1]+n}else if("quadratic"===this.elementOrder){t=2*this.numElementsX+1,n=(this.maxX-0)/this.numElementsX,e[0]=0;for(let o=1;o<t;o++)e[o]=e[o-1]+n/2}const s=this.generate1DNodalNumbering(this.numElementsX,t,this.elementOrder),i=this.findBoundaryElements();return o("Generated node X coordinates: "+JSON.stringify(e)),{nodesXCoordinates:e,totalNodesX:t,nodalNumbering:s,boundaryElements:i}}generate1DNodalNumbering(e,t,n){let o=[];if("linear"===n)for(let t=0;t<e;t++){o[t]=[];for(let e=1;e<=2;e++)o[t][e-1]=t+e}else if("quadratic"===n){let t=0;for(let n=0;n<e;n++){o[n]=[];for(let e=1;e<=3;e++)o[n][e-1]=n+e+t;t+=1}}return o}findBoundaryElements(){const e=[];for(let t=0;t<2;t++)e.push([]);return e[0].push([0,0]),e[1].push([this.numElementsX-1,1]),o("Identified boundary elements by side: "+JSON.stringify(e)),this.boundaryElementsProcessed=!0,e}}class u extends d{constructor({numElementsX:e=null,maxX:t=null,numElementsY:n=null,maxY:o=null,elementOrder:s="linear",parsedMesh:r=null}){super({numElementsX:e,maxX:t,numElementsY:n,maxY:o,meshDimension:"2D",elementOrder:s,parsedMesh:r}),r||null!==this.numElementsX&&null!==this.maxX&&null!==this.numElementsY&&null!==this.maxY||i("numElementsX, maxX, numElementsY, and maxY are required parameters when generating a 2D mesh from geometry")}generateMesh(){let e=[],t=[];let n,s,i,r;if("linear"===this.elementOrder){n=this.numElementsX+1,s=this.numElementsY+1,i=(this.maxX-0)/this.numElementsX,r=(this.maxY-0)/this.numElementsY,e[0]=0,t[0]=0;for(let n=1;n<s;n++)e[n]=e[0],t[n]=t[0]+n*r;for(let o=1;o<n;o++){const n=o*s;e[n]=e[0]+o*i,t[n]=t[0];for(let o=1;o<s;o++)e[n+o]=e[n],t[n+o]=t[n]+o*r}}else if("quadratic"===this.elementOrder){n=2*this.numElementsX+1,s=2*this.numElementsY+1,i=(this.maxX-0)/this.numElementsX,r=(this.maxY-0)/this.numElementsY,e[0]=0,t[0]=0;for(let n=1;n<s;n++)e[n]=e[0],t[n]=t[0]+n*r/2;for(let o=1;o<n;o++){const n=o*s;e[n]=e[0]+o*i/2,t[n]=t[0];for(let o=1;o<s;o++)e[n+o]=e[n],t[n+o]=t[n]+o*r/2}}const a=this.generate2DNodalNumbering(this.numElementsX,this.numElementsY,s,this.elementOrder),l=this.findBoundaryElements();return o("Generated node X coordinates: "+JSON.stringify(e)),o("Generated node Y coordinates: "+JSON.stringify(t)),{nodesXCoordinates:e,nodesYCoordinates:t,totalNodesX:n,totalNodesY:s,nodalNumbering:a,boundaryElements:l}}generate2DNodalNumbering(e,t,n,o){let s=0,i=[];if("linear"===o){let n=0,o=2;for(let s=0;s<e*t;s++)n+=1,i[s]=[],i[s][0]=s+o-1,i[s][1]=s+o,i[s][2]=s+o+t,i[s][3]=s+o+t+1,n===t&&(o+=1,n=0)}else if("quadratic"===o)for(let o=1;o<=e;o++)for(let e=1;e<=t;e++){i[s]=[];for(let t=1;t<=3;t++){let r=3*t-2;i[s][r-1]=n*(2*o+t-3)+2*e-1,i[s][r]=i[s][r-1]+1,i[s][r+1]=i[s][r-1]+2}s+=1}return i}findBoundaryElements(){const e=[];for(let t=0;t<4;t++)e.push([]);for(let t=0;t<this.numElementsX;t++)for(let n=0;n<this.numElementsY;n++){const o=t*this.numElementsY+n;0===n&&e[0].push([o,0]),0===t&&e[1].push([o,1]),n===this.numElementsY-1&&e[2].push([o,2]),t===this.numElementsX-1&&e[3].push([o,3])}return o("Identified boundary elements by side: "+JSON.stringify(e)),this.boundaryElementsProcessed=!0,e}}class h{constructor({meshDimension:e,elementOrder:t}){this.meshDimension=e,this.elementOrder=t}getGaussPointsAndWeights(){let e=[],t=[];return"linear"===this.elementOrder?(e[0]=.5,t[0]=1):"quadratic"===this.elementOrder&&(e[0]=(1-Math.sqrt(.6))/2,e[1]=.5,e[2]=(1+Math.sqrt(.6))/2,t[0]=5/18,t[1]=8/18,t[2]=5/18),{gaussPoints:e,gaussWeights:t}}}function m(e){const{totalNodes:t,nop:n,meshDimension:o,elementOrder:s}=e;let i=[],r=[];for(let e=0;e<t;e++){i[e]=0,r.push([]);for(let n=0;n<t;n++)r[e][n]=0}const a=new l({meshDimension:o,elementOrder:s});let d=new h({meshDimension:o,elementOrder:s}).getGaussPointsAndWeights();return{residualVector:i,jacobianMatrix:r,localToGlobalMap:[],basisFunctions:a,gaussPoints:d.gaussPoints,gaussWeights:d.gaussWeights,numNodes:n[0].length}}function f(e){const{basisFunction:t,basisFunctionDerivKsi:n,nodesXCoordinates:o,localToGlobalMap:s,numNodes:i}=e;let r=0,a=0;for(let e=0;e<i;e++)r+=o[s[e]]*t[e],a+=o[s[e]]*n[e];let l=a,d=[];for(let e=0;e<i;e++)d[e]=n[e]/l;return{xCoordinates:r,detJacobian:l,basisFunctionDerivX:d}}function p(e){const{basisFunction:t,basisFunctionDerivKsi:n,basisFunctionDerivEta:o,nodesXCoordinates:s,nodesYCoordinates:i,localToGlobalMap:r,numNodes:a}=e;let l=0,d=0,c=0,u=0,h=0,m=0;for(let e=0;e<a;e++)l+=s[r[e]]*t[e],d+=i[r[e]]*t[e],c+=s[r[e]]*n[e],u+=s[r[e]]*o[e],h+=i[r[e]]*n[e],m+=i[r[e]]*o[e];let f=c*m-u*h,p=[],y=[];for(let e=0;e<a;e++)p[e]=(m*n[e]-h*o[e])/f,y[e]=(c*o[e]-u*n[e])/f;return{xCoordinates:l,yCoordinates:d,detJacobian:f,basisFunctionDerivX:p,basisFunctionDerivY:y}}class y{constructor(e,t,n,o,s){this.boundaryConditions=e,this.boundaryElements=t,this.nop=n,this.meshDimension=o,this.elementOrder=s}imposeConstantValueBoundaryConditions(e,t){s("Applying constant value boundary conditions"),"1D"===this.meshDimension?Object.keys(this.boundaryConditions).forEach((n=>{if("constantValue"===this.boundaryConditions[n][0]){const s=this.boundaryConditions[n][1];o(`Boundary ${n}: Applying constant value of ${s} (Dirichlet condition)`),this.boundaryElements[n].forEach((([n,i])=>{if("linear"===this.elementOrder){({0:[0],1:[1]})[i].forEach((i=>{const r=this.nop[n][i]-1;o(`  - Applied constant value to node ${r+1} (element ${n+1}, local node ${i+1})`),e[r]=s;for(let n=0;n<e.length;n++)t[r][n]=0;t[r][r]=1}))}else if("quadratic"===this.elementOrder){({0:[0],2:[2]})[i].forEach((i=>{const r=this.nop[n][i]-1;o(`  - Applied constant value to node ${r+1} (element ${n+1}, local node ${i+1})`),e[r]=s;for(let n=0;n<e.length;n++)t[r][n]=0;t[r][r]=1}))}}))}})):"2D"===this.meshDimension&&Object.keys(this.boundaryConditions).forEach((n=>{if("constantValue"===this.boundaryConditions[n][0]){const s=this.boundaryConditions[n][1];o(`Boundary ${n}: Applying constant value of ${s} (Dirichlet condition)`),this.boundaryElements[n].forEach((([n,i])=>{if("linear"===this.elementOrder){({0:[0,2],1:[0,1],2:[1,3],3:[2,3]})[i].forEach((i=>{const r=this.nop[n][i]-1;o(`  - Applied constant value to node ${r+1} (element ${n+1}, local node ${i+1})`),e[r]=s;for(let n=0;n<e.length;n++)t[r][n]=0;t[r][r]=1}))}else if("quadratic"===this.elementOrder){({0:[0,3,6],1:[0,1,2],2:[2,5,8],3:[6,7,8]})[i].forEach((i=>{const r=this.nop[n][i]-1;o(`  - Applied constant value to node ${r+1} (element ${n+1}, local node ${i+1})`),e[r]=s;for(let n=0;n<e.length;n++)t[r][n]=0;t[r][r]=1}))}}))}}))}}function b(e,t,n,i){s("Starting front propagation matrix assembly...");let r=1-i+.01;s(`eikonalViscousTerm: ${r}`),s(`eikonalActivationFlag: ${i}`);const{nodesXCoordinates:a,nodesYCoordinates:l,nop:d,boundaryElements:c,totalElements:u,meshDimension:h,elementOrder:b}=e,g=m(e),{residualVector:E,jacobianMatrix:v,localToGlobalMap:M,basisFunctions:$,gaussPoints:x,gaussWeights:C,numNodes:F}=g;for(let e=0;e<u;e++){for(let t=0;t<F;t++)M[t]=d[e][t]-1;for(let e=0;e<x.length;e++)if("1D"===h){let t=$.getBasisFunctions(x[e]);const o=f({basisFunction:t.basisFunction,basisFunctionDerivKsi:t.basisFunctionDerivKsi,nodesXCoordinates:a,localToGlobalMap:M,numNodes:F}),{detJacobian:s,basisFunctionDerivX:i}=o;t.basisFunction;let r=0;for(let e=0;e<F;e++)r+=n[M[e]]*i[e];for(let e=0;e<F;e++){M[e];for(let e=0;e<F;e++)M[e]}}else if("2D"===h)for(let t=0;t<x.length;t++){let o=$.getBasisFunctions(x[e],x[t]);const s=p({basisFunction:o.basisFunction,basisFunctionDerivKsi:o.basisFunctionDerivKsi,basisFunctionDerivEta:o.basisFunctionDerivEta,nodesXCoordinates:a,nodesYCoordinates:l,localToGlobalMap:M,numNodes:F}),{detJacobian:d,basisFunctionDerivX:c,basisFunctionDerivY:u}=s,h=o.basisFunction;let m=0,f=0;for(let e=0;e<F;e++)m+=n[M[e]]*c[e],f+=n[M[e]]*u[e];for(let n=0;n<F;n++){let o=M[n];E[o]+=r*C[e]*C[t]*d*c[n]*m+r*C[e]*C[t]*d*u[n]*f,0!==i&&(E[o]+=i*(C[e]*C[t]*d*h[n]*Math.sqrt(m**2+f**2)-C[e]*C[t]*d*h[n]));for(let s=0;s<F;s++){let a=M[s];v[o][a]+=-r*C[e]*C[t]*d*(c[n]*c[s]+u[n]*u[s]),0!==i&&(v[o][a]+=i*(-d*m*h[n]*C[e]*C[t]/Math.sqrt(m**2+f**2+1e-8))*c[s]-d*f*h[n]*C[e]*C[t]/Math.sqrt(m**2+f**2+1e-8)*u[s])}}}}s("Applying generic boundary conditions...");new y(t,c,d,h,b).imposeConstantValueBoundaryConditions(E,v),s("Constant value boundary conditions applied"),o("Residuals at each node:");for(let e=0;e<E.length;e++)o(`Node ${e}: ${E[e].toExponential(6)}`);return s("Front propagation matrix assembly completed"),{jacobianMatrix:v,residualVector:E}}class g{constructor(e,t,n,o,s){this.boundaryConditions=e,this.boundaryElements=t,this.nop=n,this.meshDimension=o,this.elementOrder=s}imposeConstantTempBoundaryConditions(e,t){s("Applying constant temperature boundary conditions"),"1D"===this.meshDimension?Object.keys(this.boundaryConditions).forEach((n=>{if("constantTemp"===this.boundaryConditions[n][0]){const s=this.boundaryConditions[n][1];o(`Boundary ${n}: Applying constant temperature of ${s} K (Dirichlet condition)`),this.boundaryElements[n].forEach((([n,i])=>{if("linear"===this.elementOrder){({0:[0],1:[1]})[i].forEach((i=>{const r=this.nop[n][i]-1;o(`  - Applied constant temperature to node ${r+1} (element ${n+1}, local node ${i+1})`),e[r]=s;for(let n=0;n<e.length;n++)t[r][n]=0;t[r][r]=1}))}else if("quadratic"===this.elementOrder){({0:[0],2:[2]})[i].forEach((i=>{const r=this.nop[n][i]-1;o(`  - Applied constant temperature to node ${r+1} (element ${n+1}, local node ${i+1})`),e[r]=s;for(let n=0;n<e.length;n++)t[r][n]=0;t[r][r]=1}))}}))}})):"2D"===this.meshDimension&&Object.keys(this.boundaryConditions).forEach((n=>{if("constantTemp"===this.boundaryConditions[n][0]){const s=this.boundaryConditions[n][1];o(`Boundary ${n}: Applying constant temperature of ${s} K (Dirichlet condition)`),this.boundaryElements[n].forEach((([n,i])=>{if("linear"===this.elementOrder){({0:[0,2],1:[0,1],2:[1,3],3:[2,3]})[i].forEach((i=>{const r=this.nop[n][i]-1;o(`  - Applied constant temperature to node ${r+1} (element ${n+1}, local node ${i+1})`),e[r]=s;for(let n=0;n<e.length;n++)t[r][n]=0;t[r][r]=1}))}else if("quadratic"===this.elementOrder){({0:[0,3,6],1:[0,1,2],2:[2,5,8],3:[6,7,8]})[i].forEach((i=>{const r=this.nop[n][i]-1;o(`  - Applied constant temperature to node ${r+1} (element ${n+1}, local node ${i+1})`),e[r]=s;for(let n=0;n<e.length;n++)t[r][n]=0;t[r][r]=1}))}}))}}))}imposeConvectionBoundaryConditions(e,t,n,i,r,a,l){s("Applying convection boundary conditions");let d=[],c=[];Object.keys(this.boundaryConditions).forEach((e=>{const t=this.boundaryConditions[e];"convection"===t[0]&&(d[e]=t[1],c[e]=t[2])})),"1D"===this.meshDimension?Object.keys(this.boundaryConditions).forEach((n=>{if("convection"===this.boundaryConditions[n][0]){const s=d[n],i=c[n];o(`Boundary ${n}: Applying convection with heat transfer coefficient h=${s} W/(m²·K) and external temperature T∞=${i} K`),this.boundaryElements[n].forEach((([n,r])=>{let a;"linear"===this.elementOrder?a=0===r?0:1:"quadratic"===this.elementOrder&&(a=0===r?0:2);const l=this.nop[n][a]-1;o(`  - Applied convection boundary condition to node ${l+1} (element ${n+1}, local node ${a+1})`),e[l]+=-s*i,t[l][l]+=s}))}})):"2D"===this.meshDimension&&Object.keys(this.boundaryConditions).forEach((s=>{if("convection"===this.boundaryConditions[s][0]){const u=d[s],h=c[s];o(`Boundary ${s}: Applying convection with heat transfer coefficient h=${u} W/(m²·K) and external temperature T∞=${h} K`),this.boundaryElements[s].forEach((([s,d])=>{if("linear"===this.elementOrder){let c,m,f,p,y;0===d?(c=n[0],m=0,f=0,p=3,y=2):1===d?(c=0,m=n[0],f=0,p=2,y=1):2===d?(c=n[0],m=1,f=1,p=4,y=2):3===d&&(c=1,m=n[0],f=2,p=4,y=1);let b=l.getBasisFunctions(c,m),g=b.basisFunction,E=b.basisFunctionDerivKsi,v=b.basisFunctionDerivEta,M=0,$=0,x=0,C=0;const F=this.nop[s].length;for(let e=0;e<F;e++){const t=this.nop[s][e]-1;0===d||2===d?(M+=r[t]*E[e],$+=a[t]*E[e]):1!==d&&3!==d||(x+=r[t]*v[e],C+=a[t]*v[e])}let A;A=0===d||2===d?Math.sqrt(M**2+$**2):Math.sqrt(x**2+C**2);for(let n=f;n<p;n+=y){let r=this.nop[s][n]-1;o(`  - Applied convection boundary condition to node ${r+1} (element ${s+1}, local node ${n+1})`),e[r]+=-i[0]*A*g[n]*u*h;for(let e=f;e<p;e+=y){let o=this.nop[s][e]-1;t[r][o]+=-i[0]*A*g[n]*g[e]*u}}}else if("quadratic"===this.elementOrder)for(let c=0;c<3;c++){let m,f,p,y,b;0===d?(m=n[c],f=0,p=0,y=7,b=3):1===d?(m=0,f=n[c],p=0,y=3,b=1):2===d?(m=n[c],f=1,p=2,y=9,b=3):3===d&&(m=1,f=n[c],p=6,y=9,b=1);let g=l.getBasisFunctions(m,f),E=g.basisFunction,v=g.basisFunctionDerivKsi,M=g.basisFunctionDerivEta,$=0,x=0,C=0,F=0;const A=this.nop[s].length;for(let e=0;e<A;e++){const t=this.nop[s][e]-1;0===d||2===d?($+=r[t]*v[e],x+=a[t]*v[e]):1!==d&&3!==d||(C+=r[t]*M[e],F+=a[t]*M[e])}let w;w=0===d||2===d?Math.sqrt($**2+x**2):Math.sqrt(C**2+F**2);for(let n=p;n<y;n+=b){let r=this.nop[s][n]-1;o(`  - Applied convection boundary condition to node ${r+1} (element ${s+1}, local node ${n+1})`),e[r]+=-i[c]*w*E[n]*u*h;for(let e=p;e<y;e+=b){let o=this.nop[s][e]-1;t[r][o]+=-i[c]*w*E[n]*E[e]*u}}}}))}}))}}function E(e,t){return function(e,t){(function(e){const{meshDimension:t,numElementsX:n,numElementsY:o,maxX:s,maxY:i,elementOrder:r,parsedMesh:a}=e;x.nex=n,x.ney=o,x.xorigin=0,x.yorigin=0,x.xlast=s,x.ylast=i,x.deltax=(x.xlast-x.xorigin)/x.nex,x.deltay=(x.ylast-x.yorigin)/x.ney})(e),function(){x.ne=x.nex*x.ney,x.nnx=2*x.nex+1,x.nny=2*x.ney+1,x.np=x.nnx*x.nny;let e=0;for(let t=1;t<=x.nex;t++)for(let n=1;n<=x.ney;n++){e++;for(let o=1;o<=3;o++){let s=3*o-2;x.nop[e-1][s-1]=x.nny*(2*t+o-3)+2*n-1,x.nop[e-1][s]=x.nop[e-1][s-1]+1,x.nop[e-1][s+1]=x.nop[e-1][s-1]+2}}}(),function(){x.xpt[0]=x.xorigin,x.ypt[0]=x.yorigin;for(let e=1;e<=x.nnx;e++){let t=(e-1)*x.nny;x.xpt[t]=x.xpt[0]+(e-1)*x.deltax/2,x.ypt[t]=x.ypt[0];for(let e=2;e<=x.nny;e++)x.xpt[t+e-1]=x.xpt[t],x.ypt[t+e-1]=x.ypt[t]+(e-1)*x.deltay/2}}();for(let e=0;e<x.np;e++)x.ncod[e]=0,x.bc[e]=0;Object.keys(t).forEach((e=>{if("constantTemp"===t[e][0]){const n=t[e][1];switch(e){case"0":for(let e=0;e<x.nnx;e++){const t=e*x.nny;x.ncod[t]=1,x.bc[t]=n}break;case"1":for(let e=0;e<x.nny;e++)x.ncod[e]=1,x.bc[e]=n;break;case"2":for(let e=0;e<x.nnx;e++){const t=e*x.nny+(x.nny-1);x.ncod[t]=1,x.bc[t]=n}break;case"3":for(let e=0;e<x.nny;e++){const t=(x.nnx-1)*x.nny+e;x.ncod[t]=1,x.bc[t]=n}}}}));for(let e=0;e<x.ne;e++)x.ntop[e]=0,x.nlat[e]=0;for(let e=0;e<x.np;e++)x.r1[e]=0;F.npt=x.np,F.iwr1=0,F.ntra=1,F.det=1;for(let e=0;e<x.ne;e++)F.nbn[e]=9;!function(){let e,t=Array(9).fill(0),n=Array(9).fill(0),s=Array($).fill(0),r=Array($).fill(0),a=Array($).fill(0),l=Array($).fill(0),d=Array($).fill(0),c=Array($).fill().map((()=>Array($).fill(0))),u=Array(M).fill(0),h=Array(M).fill(0),m=Array(M).fill(0),f=1;F.iwr1++;let p=1,y=1;A.nell=0;for(let e=0;e<F.npt;e++)u[e]=0,h[e]=0;if(0!==F.ntra){for(let e=0;e<F.npt;e++)m[e]=0;for(let e=0;e<x.ne;e++){let t=x.ne-e-1;for(let e=0;e<F.nbn[t];e++){let n=x.nop[t][e];0===m[n-1]&&(m[n-1]=1,x.nop[t][e]=-x.nop[t][e])}}}F.ntra=0;let b=0,g=0;for(let e=0;e<$;e++)for(let t=0;t<$;t++)c[t][e]=0;for(;;){A.nell++,N();let m=A.nell,E=F.nbn[m-1],v=F.nbn[m-1];for(let e=0;e<v;e++){let o,i,r=x.nop[m-1][e];if(0===b)b++,t[e]=b,w.lhed[b-1]=r;else{for(o=0;o<b&&Math.abs(r)!==Math.abs(w.lhed[o]);o++);o===b?(b++,t[e]=b,w.lhed[b-1]=r):(t[e]=o+1,w.lhed[o]=r)}if(0===g)g++,n[e]=g,s[g-1]=r;else{for(i=0;i<g&&Math.abs(r)!==Math.abs(s[i]);i++);i===g?(g++,n[e]=g,s[g-1]=r):(n[e]=i+1,s[i]=r)}}if(g>$||b>$)return void i("Error: nmax-nsum not large enough");for(let e=0;e<v;e++){let o=t[e];for(let t=0;t<E;t++){c[n[t]-1][o-1]+=A.estifm[t][e]}}let M=0;for(let e=0;e<b;e++)w.lhed[e]<0&&(a[M]=e+1,M++);let C=0,D=0;for(let e=0;e<g;e++){let t=s[e];if(t<0){r[D]=e+1,D++;let n=Math.abs(t);1===x.ncod[n-1]&&(l[C]=e+1,C++,x.ncod[n-1]=2,x.r1[n-1]=x.bc[n-1])}}if(C>0)for(let e=0;e<C;e++){let t=l[e]-1,n=Math.abs(s[t]);for(let e=0;e<b;e++){c[t][e]=0,Math.abs(w.lhed[e])===n&&(c[t][e]=1)}}if(M>y||A.nell<x.ne){if(0===M)return void i("Error: no more rows fully summed");let t=r[0],n=a[0],l=c[t-1][n-1];if(Math.abs(l)<1e-4){l=0;for(let e=0;e<M;e++){let o=a[e];for(let e=0;e<D;e++){let s=r[e],i=c[s-1][o-1];Math.abs(i)>Math.abs(l)&&(l=i,n=o,t=s)}}}let m=Math.abs(s[t-1]);e=Math.abs(w.lhed[n-1]);let y=m+e+u[m-1]+h[e-1];F.det=F.det*l*(-1)**y/Math.abs(l);for(let t=0;t<F.npt;t++)t>=m&&u[t]--,t>=e&&h[t]--;if(Math.abs(l)<1e-10&&i(`Warning: matrix singular or ill-conditioned, nell=${A.nell}, kro=${m}, lco=${e}, pivot=${l}`),0===l)return;for(let e=0;e<b;e++)w.qq[e]=c[t-1][e]/l;let E=x.r1[m-1]/l;if(x.r1[m-1]=E,d[t-1]=l,t>1)for(let e=0;e<t-1;e++){let t=Math.abs(s[e]),o=c[e][n-1];if(d[e]=o,n>1&&0!==o)for(let t=0;t<n-1;t++)c[e][t]-=o*w.qq[t];if(n<b)for(let t=n;t<b;t++)c[e][t-1]=c[e][t]-o*w.qq[t];x.r1[t-1]-=o*E}if(t<g)for(let e=t;e<g;e++){let t=Math.abs(s[e]),o=c[e][n-1];if(d[e]=o,n>1)for(let t=0;t<n-1;t++)c[e-1][t]=c[e][t]-o*w.qq[t];if(n<b)for(let t=n;t<b;t++)c[e-1][t-1]=c[e][t]-o*w.qq[t];x.r1[t-1]-=o*E}for(let e=0;e<g;e++)w.ecpiv[p+e-1]=d[e];p+=g;for(let e=0;e<g;e++)w.ecpiv[p+e-1]=s[e];p+=g,w.ecpiv[p-1]=t,p++;for(let e=0;e<b;e++)w.ecv[f-1+e]=w.qq[e];f+=b;for(let e=0;e<b;e++)w.ecv[f-1+e]=w.lhed[e];f+=b,w.ecv[f-1]=m,w.ecv[f]=b,w.ecv[f+1]=n,w.ecv[f+2]=l,f+=4;for(let e=0;e<g;e++)c[e][b-1]=0;for(let e=0;e<b;e++)c[g-1][e]=0;if(b--,n<b+1)for(let e=n-1;e<b;e++)w.lhed[e]=w.lhed[e+1];if(g--,t<g+1)for(let e=t-1;e<g;e++)s[e]=s[e+1];if(g>1||A.nell<x.ne)continue;if(e=Math.abs(w.lhed[0]),t=1,l=c[0][0],m=Math.abs(s[0]),n=1,y=m+e+u[m-1]+h[e-1],F.det=F.det*l*(-1)**y/Math.abs(l),w.qq[0]=1,Math.abs(l)<1e-10&&i(`Warning: matrix singular or ill-conditioned, nell=${A.nell}, kro=${m}, lco=${e}, pivot=${l}`),0===l)return;x.r1[m-1]=x.r1[m-1]/l,w.ecv[f-1]=w.qq[0],f++,w.ecv[f-1]=w.lhed[0],f++,w.ecv[f-1]=m,w.ecv[f]=b,w.ecv[f+1]=n,w.ecv[f+2]=l,f+=4,w.ecpiv[p-1]=d[0],p++,w.ecpiv[p-1]=s[0],p++,w.ecpiv[p-1]=t,p++,F.ice1=f,1===F.iwr1&&o(`total ecs transfer in matrix reduction=${f}`),S(f);break}}}();for(let e=0;e<x.np;e++)x.u[e]=F.sk[e];for(let e=0;e<x.np;e++)o(`${x.xpt[e].toExponential(5)}  ${x.ypt[e].toExponential(5)}  ${x.u[e].toExponential(5)}`)}(e,t),{solutionVector:x.u.slice(0,x.np),nodesCoordinates:{nodesXCoordinates:x.xpt.slice(0,x.np),nodesYCoordinates:x.ypt.slice(0,x.np)}}}const v=1600,M=6724,$=2e3,x={nex:0,ney:0,nnx:0,nny:0,ne:0,np:0,xorigin:0,yorigin:0,xlast:0,ylast:0,deltax:0,deltay:0,nop:Array(v).fill().map((()=>Array(9).fill(0))),xpt:Array(M).fill(0),ypt:Array(M).fill(0),ncod:Array(M).fill(0),bc:Array(M).fill(0),r1:Array(M).fill(0),u:Array(M).fill(0),ntop:Array(v).fill(0),nlat:Array(v).fill(0)},C={w:[.27777777777778,.444444444444,.27777777777778],gp:[.1127016654,.5,.8872983346]},F={iwr1:0,npt:0,ntra:0,nbn:Array(v).fill(0),det:1,sk:Array($*$).fill(0),ice1:0},A={estifm:Array(9).fill().map((()=>Array(9).fill(0))),nell:0},w={ecv:Array(2e6).fill(0),lhed:Array($).fill(0),qq:Array($).fill(0),ecpiv:Array(2e6).fill(0)},D=new l({meshDimension:"2D",elementOrder:"quadratic"});function N(){const e=A.nell-1,{estifm:t,localLoad:n,ngl:o}=function({elementIndex:e,nop:t,xCoordinates:n,yCoordinates:o,basisFunctions:s,gaussPoints:i,gaussWeights:r,ntopFlag:a=!1,nlatFlag:l=!1,convectionTop:d={active:!1,coeff:0,extTemp:0}}){const c=Array(9).fill().map((()=>Array(9).fill(0))),u=Array(9).fill(0),h=Array(9);for(let n=0;n<9;n++)h[n]=Math.abs(t[e][n]);for(let e=0;e<i.length;e++)for(let t=0;t<i.length;t++){const{basisFunction:a,basisFunctionDerivKsi:l,basisFunctionDerivEta:d}=s.getBasisFunctions(i[e],i[t]),u=h.map((e=>e-1)),{detJacobian:m,basisFunctionDerivX:f,basisFunctionDerivY:y}=p({basisFunction:a,basisFunctionDerivKsi:l,basisFunctionDerivEta:d,nodesXCoordinates:n,nodesYCoordinates:o,localToGlobalMap:u,numNodes:9});for(let n=0;n<9;n++)for(let o=0;o<9;o++)c[n][o]-=r[e]*r[t]*m*(f[n]*f[o]+y[n]*y[o])}if(a&&d.active){const a=d.coeff,l=d.extTemp;for(let d=0;d<i.length;d++){const h=i[d],{basisFunction:m,basisFunctionDerivKsi:f}=s.getBasisFunctions(h,1);let p=0,y=0;const b=[2,5,8];for(let s=0;s<9;s++){const i=t[e][s]-1;p+=n[i]*f[s],y+=o[i]*f[s]}const g=Math.sqrt(p*p+y*y);for(const e of b){for(const t of b)c[e][t]-=r[d]*g*a*m[e]*m[t];u[e]-=r[d]*g*a*l*m[e]}}}else a&&d.active;return{estifm:c,localLoad:u,ngl:h}}({elementIndex:e,nop:x.nop,xCoordinates:x.xpt,yCoordinates:x.ypt,basisFunctions:D,gaussPoints:C.gp,gaussWeights:C.w,ntopFlag:1===x.ntop[e],nlatFlag:1===x.nlat[e]});for(let e=0;e<9;e++)for(let n=0;n<9;n++)A.estifm[e][n]=t[e][n];for(let e=0;e<9;e++){const t=o[e]-1;x.r1[t]+=n[e]}}function S(e){for(let e=0;e<F.npt;e++)F.sk[e]=x.bc[e];for(let t=1;t<=F.npt;t++){e-=4;let n=w.ecv[e-1],o=w.ecv[e],s=w.ecv[e+1];if(w.ecv[e+2],1===t)e--,w.lhed[0]=w.ecv[e-1],e--,w.qq[0]=w.ecv[e-1];else{e-=o;for(let t=0;t<o;t++)w.lhed[t]=w.ecv[e-1+t];e-=o;for(let t=0;t<o;t++)w.qq[t]=w.ecv[e-1+t]}let i=Math.abs(w.lhed[s-1]);if(x.ncod[i-1]>0)continue;let r=0;w.qq[s-1]=0;for(let e=0;e<o;e++)r-=w.qq[e]*F.sk[Math.abs(w.lhed[e])-1];F.sk[i-1]=r+x.r1[n-1],x.ncod[i-1]=1}1===F.iwr1&&o(`value of ice after backsubstitution=${e}`)}
/**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   */
const O=Symbol("Comlink.proxy"),X=Symbol("Comlink.endpoint"),T=Symbol("Comlink.releaseProxy"),k=Symbol("Comlink.finalizer"),q=Symbol("Comlink.thrown"),Y=e=>"object"==typeof e&&null!==e||"function"==typeof e,P=new Map([["proxy",{canHandle:e=>Y(e)&&e[O],serialize(e){const{port1:t,port2:n}=new MessageChannel;return R(e,t),[n,[n]]},deserialize:e=>(e.start(),I(e))}],["throw",{canHandle:e=>Y(e)&&q in e,serialize({value:e}){let t;return t=e instanceof Error?{isError:!0,value:{message:e.message,name:e.name,stack:e.stack}}:{isError:!1,value:e},[t,[]]},deserialize(e){if(e.isError)throw Object.assign(new Error(e.value.message),e.value);throw e.value}}]]);function R(e,t=globalThis,n=["*"]){t.addEventListener("message",(function o(s){if(!s||!s.data)return;if(!function(e,t){for(const n of e){if(t===n||"*"===n)return!0;if(n instanceof RegExp&&n.test(t))return!0}return!1}(n,s.origin))return void console.warn(`Invalid origin '${s.origin}' for comlink proxy`);const{id:i,type:r,path:a}=Object.assign({path:[]},s.data),l=(s.data.argumentList||[]).map(z);let d;try{const t=a.slice(0,-1).reduce(((e,t)=>e[t]),e),n=a.reduce(((e,t)=>e[t]),e);switch(r){case"GET":d=n;break;case"SET":t[a.slice(-1)[0]]=z(s.data.value),d=!0;break;case"APPLY":d=n.apply(t,l);break;case"CONSTRUCT":d=function(e){return Object.assign(e,{[O]:!0})}(new n(...l));break;case"ENDPOINT":{const{port1:t,port2:n}=new MessageChannel;R(e,n),d=function(e,t){return J.set(e,t),e}(t,[t])}break;case"RELEASE":d=void 0;break;default:return}}catch(e){d={value:e,[q]:0}}Promise.resolve(d).catch((e=>({value:e,[q]:0}))).then((n=>{const[s,a]=U(n);t.postMessage(Object.assign(Object.assign({},s),{id:i}),a),"RELEASE"===r&&(t.removeEventListener("message",o),W(t),k in e&&"function"==typeof e[k]&&e[k]())})).catch((e=>{const[n,o]=U({value:new TypeError("Unserializable return value"),[q]:0});t.postMessage(Object.assign(Object.assign({},n),{id:i}),o)}))})),t.start&&t.start()}function W(e){(function(e){return"MessagePort"===e.constructor.name})(e)&&e.close()}function I(e,t){const n=new Map;return e.addEventListener("message",(function(e){const{data:t}=e;if(!t||!t.id)return;const o=n.get(t.id);if(o)try{o(t)}finally{n.delete(t.id)}})),L(e,n,[],t)}function j(e){if(e)throw new Error("Proxy has been released and is not useable")}function B(e){return _(e,new Map,{type:"RELEASE"}).then((()=>{W(e)}))}const V=new WeakMap,G="FinalizationRegistry"in globalThis&&new FinalizationRegistry((e=>{const t=(V.get(e)||0)-1;V.set(e,t),0===t&&B(e)}));function L(e,t,n=[],o=function(){}){let s=!1;const i=new Proxy(o,{get(o,r){if(j(s),r===T)return()=>{!function(e){G&&G.unregister(e)}(i),B(e),t.clear(),s=!0};if("then"===r){if(0===n.length)return{then:()=>i};const o=_(e,t,{type:"GET",path:n.map((e=>e.toString()))}).then(z);return o.then.bind(o)}return L(e,t,[...n,r])},set(o,i,r){j(s);const[a,l]=U(r);return _(e,t,{type:"SET",path:[...n,i].map((e=>e.toString())),value:a},l).then(z)},apply(o,i,r){j(s);const a=n[n.length-1];if(a===X)return _(e,t,{type:"ENDPOINT"}).then(z);if("bind"===a)return L(e,t,n.slice(0,-1));const[l,d]=K(r);return _(e,t,{type:"APPLY",path:n.map((e=>e.toString())),argumentList:l},d).then(z)},construct(o,i){j(s);const[r,a]=K(i);return _(e,t,{type:"CONSTRUCT",path:n.map((e=>e.toString())),argumentList:r},a).then(z)}});return function(e,t){const n=(V.get(t)||0)+1;V.set(t,n),G&&G.register(e,t,e)}(i,e),i}function K(e){const t=e.map(U);return[t.map((e=>e[0])),(n=t.map((e=>e[1])),Array.prototype.concat.apply([],n))];var n}const J=new WeakMap;function U(e){for(const[t,n]of P)if(n.canHandle(e)){const[o,s]=n.serialize(e);return[{type:"HANDLER",name:t,value:o},s]}return[{type:"RAW",value:e},J.get(e)||[]]}function z(e){switch(e.type){case"HANDLER":return P.get(e.name).deserialize(e.value);case"RAW":return e.value}}function _(e,t,n,o){return new Promise((s=>{const i=new Array(4).fill(0).map((()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16))).join("-");t.set(i,s),e.start&&e.start(),e.postMessage(Object.assign({id:i},n),o)}))}e.FEAScriptModel=class{constructor(){this.solverConfig=null,this.meshConfig={},this.boundaryConditions={},this.solverMethod="lusolve",s("FEAScriptModel instance created")}setSolverConfig(e){this.solverConfig=e,o(`Solver config set to: ${e}`)}setMeshConfig(e){this.meshConfig=e,o(`Mesh config set with dimensions: ${e.meshDimension}`)}addBoundaryCondition(e,t){this.boundaryConditions[e]=t,o(`Boundary condition added for boundary: ${e}, type: ${t[0]}`)}setSolverMethod(e){this.solverMethod=e,o(`Solver method set to: ${e}`)}solve(){if(!this.solverConfig||!this.meshConfig||!this.boundaryConditions){const e="Solver config, mesh config, and boundary conditions must be set before solving.";throw console.error(e),new Error(e)}let e=[],t=[],n=[],l=[];s("Preparing mesh...");const d=function(e){const{meshDimension:t,numElementsX:n,numElementsY:s,maxX:r,maxY:a,elementOrder:l,parsedMesh:d}=e;let h;"1D"===t?h=new c({numElementsX:n,maxX:r,elementOrder:l,parsedMesh:d}):"2D"===t?h=new u({numElementsX:n,maxX:r,numElementsY:s,maxY:a,elementOrder:l,parsedMesh:d}):i("Mesh dimension must be either '1D' or '2D'.");const m=h.boundaryElementsProcessed?h.parsedMesh:h.generateMesh();let f,p,y=m.nodesXCoordinates,b=m.nodesYCoordinates,g=m.totalNodesX,E=m.totalNodesY,v=m.nodalNumbering,M=m.boundaryElements;return null!=d?(f=v.length,p=y.length,o(`Using parsed mesh with ${f} elements and ${p} nodes`)):(f=n*("2D"===t?s:1),p=g*("2D"===t?E:1),o(`Using mesh generated from geometry with ${f} elements and ${p} nodes`)),{nodesXCoordinates:y,nodesYCoordinates:b,totalNodesX:g,totalNodesY:E,nop:v,boundaryElements:M,totalElements:f,totalNodes:p,meshDimension:t,elementOrder:l}}(this.meshConfig);s("Mesh preparation completed");const h={nodesXCoordinates:d.nodesXCoordinates,nodesYCoordinates:d.nodesYCoordinates};if(s("Beginning solving process..."),console.time("totalSolvingTime"),"solidHeatTransferScript"===this.solverConfig)if(s(`Using solver: ${this.solverConfig}`),"frontal"===this.solverMethod){s("Using frontal solver method");n=E(this.meshConfig,this.boundaryConditions).solutionVector}else{({jacobianMatrix:e,residualVector:t}=function(e,t){s("Starting solid heat transfer matrix assembly...");const{nodesXCoordinates:n,nodesYCoordinates:i,nop:r,boundaryElements:a,totalElements:l,meshDimension:d,elementOrder:c}=e,u=m(e),{residualVector:h,jacobianMatrix:y,localToGlobalMap:b,basisFunctions:E,gaussPoints:v,gaussWeights:M,numNodes:$}=u;for(let e=0;e<l;e++){for(let t=0;t<$;t++)b[t]=r[e][t]-1;for(let e=0;e<v.length;e++)if("1D"===d){let t=E.getBasisFunctions(v[e]);const o=f({basisFunction:t.basisFunction,basisFunctionDerivKsi:t.basisFunctionDerivKsi,nodesXCoordinates:n,localToGlobalMap:b,numNodes:$}),{detJacobian:s,basisFunctionDerivX:i}=o;for(let t=0;t<$;t++){let n=b[t];for(let o=0;o<$;o++){let r=b[o];y[n][r]+=-M[e]*s*(i[t]*i[o])}}}else if("2D"===d)for(let t=0;t<v.length;t++){let o=E.getBasisFunctions(v[e],v[t]);const s=p({basisFunction:o.basisFunction,basisFunctionDerivKsi:o.basisFunctionDerivKsi,basisFunctionDerivEta:o.basisFunctionDerivEta,nodesXCoordinates:n,nodesYCoordinates:i,localToGlobalMap:b,numNodes:$}),{detJacobian:r,basisFunctionDerivX:a,basisFunctionDerivY:l}=s;for(let n=0;n<$;n++){let o=b[n];for(let s=0;s<$;s++){let i=b[s];y[o][i]+=-M[e]*M[t]*r*(a[n]*a[s]+l[n]*l[s])}}}}s("Applying thermal boundary conditions...");const x=new g(t,a,r,d,c);x.imposeConvectionBoundaryConditions(h,y,v,M,n,i,E),s("Convection boundary conditions applied"),x.imposeConstantTempBoundaryConditions(h,y),s("Constant temperature boundary conditions applied"),o("Residuals at each node:");for(let e=0;e<h.length;e++)o(`Node ${e}: ${h[e].toExponential(6)}`);return s("Solid heat transfer matrix assembly completed"),{jacobianMatrix:y,residualVector:h}}(d,this.boundaryConditions));n=r(this.solverMethod,e,t).solutionVector}else if("frontPropagationScript"===this.solverConfig){s(`Using solver: ${this.solverConfig}`);let o=0;const i=5,r={meshData:d,boundaryConditions:this.boundaryConditions,eikonalActivationFlag:o,solverMethod:this.solverMethod,initialSolution:l};for(;o<=1;){r.eikonalActivationFlag=o,n.length>0&&(r.initialSolution=[...n]);const s=a(b,r,100,1e-4);e=s.jacobianMatrix,t=s.residualVector,n=s.solutionVector,o+=1/i}}return console.timeEnd("totalSolvingTime"),s("Solving process completed"),{solutionVector:n,nodesCoordinates:h}}},e.FEAScriptWorker=class{constructor(){this.worker=null,this.feaWorker=null,this.isReady=!1,this._initWorker()}async _initWorker(){try{this.worker=new Worker(new URL("./wrapperScript.js","undefined"==typeof document&&"undefined"==typeof location?new(require("url").URL)("file:"+__filename).href:"undefined"==typeof document?location.href:document.currentScript&&"SCRIPT"===document.currentScript.tagName.toUpperCase()&&document.currentScript.src||new URL("feascript.umd.js",document.baseURI).href),{type:"module"}),this.worker.onerror=e=>{console.error("FEAScriptWorker: Worker error:",e)};const e=I(this.worker);this.feaWorker=await new e,this.isReady=!0}catch(e){throw console.error("Failed to initialize worker",e),e}}async _ensureReady(){return this.isReady?Promise.resolve():new Promise(((e,t)=>{let n=0;const o=()=>{n++,this.isReady?e():n>=50?t(new Error("Timeout waiting for worker to be ready")):setTimeout(o,1e3)};o()}))}async setSolverConfig(e){return await this._ensureReady(),s(`FEAScriptWorker: Setting solver config to: ${e}`),this.feaWorker.setSolverConfig(e)}async setMeshConfig(e){return await this._ensureReady(),s("FEAScriptWorker: Setting mesh config"),this.feaWorker.setMeshConfig(e)}async addBoundaryCondition(e,t){return await this._ensureReady(),s(`FEAScriptWorker: Adding boundary condition for boundary: ${e}`),this.feaWorker.addBoundaryCondition(e,t)}async setSolverMethod(e){return await this._ensureReady(),s(`FEAScriptWorker: Setting solver method to: ${e}`),this.feaWorker.setSolverMethod(e)}async solve(){await this._ensureReady(),s("FEAScriptWorker: Requesting solution from worker...");const e=performance.now(),t=await this.feaWorker.solve();return s(`FEAScriptWorker: Solution completed in ${((performance.now()-e)/1e3).toFixed(2)}s`),t}async getModelInfo(){return await this._ensureReady(),this.feaWorker.getModelInfo()}async ping(){return await this._ensureReady(),this.feaWorker.ping()}terminate(){this.worker&&(this.worker.terminate(),this.worker=null,this.feaWorker=null,this.isReady=!1)}},e.VERSION="0.1.3",e.importGmshQuadTri=async e=>{let t={nodesXCoordinates:[],nodesYCoordinates:[],nodalNumbering:{quadElements:[],triangleElements:[]},boundaryElements:[],boundaryConditions:[],boundaryNodePairs:{},gmshV:0,ascii:!1,fltBytes:"8",totalNodesX:0,totalNodesY:0,physicalPropMap:[],elementTypes:{}},n=(await e.text()).split("\n").map((e=>e.trim())).filter((e=>""!==e&&" "!==e)),s="",i=0,r=0,a=0,l=0,d={numNodes:0},c=0,u=[],h=0,m=0,f=0,p={dim:0,tag:0,elementType:0,numElements:0},y=0,b={};for(;i<n.length;){const e=n[i];if("$MeshFormat"===e){s="meshFormat",i++;continue}if("$EndMeshFormat"===e){s="",i++;continue}if("$PhysicalNames"===e){s="physicalNames",i++;continue}if("$EndPhysicalNames"===e){s="",i++;continue}if("$Entities"===e){s="entities",i++;continue}if("$EndEntities"===e){s="",i++;continue}if("$Nodes"===e){s="nodes",i++;continue}if("$EndNodes"===e){s="",i++;continue}if("$Elements"===e){s="elements",i++;continue}if("$EndElements"===e){s="",i++;continue}const o=e.split(/\s+/).filter((e=>""!==e));if("meshFormat"===s)t.gmshV=parseFloat(o[0]),t.ascii="0"===o[1],t.fltBytes=o[2];else if("physicalNames"===s){if(o.length>=3){if(!/^\d+$/.test(o[0])){i++;continue}const e=parseInt(o[0],10),n=parseInt(o[1],10);let s=o.slice(2).join(" ");s=s.replace(/^"|"$/g,""),t.physicalPropMap.push({tag:n,dimension:e,name:s})}}else if("nodes"===s){if(0===r){r=parseInt(o[0],10),a=parseInt(o[1],10),t.nodesXCoordinates=new Array(a).fill(0),t.nodesYCoordinates=new Array(a).fill(0),i++;continue}if(l<r&&0===d.numNodes){d={dim:parseInt(o[0],10),tag:parseInt(o[1],10),parametric:parseInt(o[2],10),numNodes:parseInt(o[3],10)},u=[],c=0,h=0,i++;continue}if(c<d.numNodes){for(let e=0;e<o.length&&c<d.numNodes;e++)u.push(parseInt(o[e],10)),c++;if(c<d.numNodes){i++;continue}i++;continue}if(h<d.numNodes){const e=u[h]-1,n=parseFloat(o[0]),s=parseFloat(o[1]);t.nodesXCoordinates[e]=n,t.nodesYCoordinates[e]=s,t.totalNodesX++,t.totalNodesY++,h++,h===d.numNodes&&(l++,d={numNodes:0})}}else if("elements"===s){if(0===m){m=parseInt(o[0],10),parseInt(o[1],10),i++;continue}if(f<m&&0===p.numElements){p={dim:parseInt(o[0],10),tag:parseInt(o[1],10),elementType:parseInt(o[2],10),numElements:parseInt(o[3],10)},t.elementTypes[p.elementType]=(t.elementTypes[p.elementType]||0)+p.numElements,y=0,i++;continue}if(y<p.numElements){parseInt(o[0],10);const e=o.slice(1).map((e=>parseInt(e,10)));if(1===p.elementType||8===p.elementType){const n=p.tag;b[n]||(b[n]=[]),b[n].push(e),t.boundaryNodePairs[n]||(t.boundaryNodePairs[n]=[]),t.boundaryNodePairs[n].push(e)}else 2===p.elementType?t.nodalNumbering.triangleElements.push(e):(3===p.elementType||10===p.elementType)&&t.nodalNumbering.quadElements.push(e);y++,y===p.numElements&&(f++,p={numElements:0})}}i++}return t.physicalPropMap.forEach((e=>{if(1===e.dimension){const n=b[e.tag]||[];n.length>0&&t.boundaryConditions.push({name:e.name,tag:e.tag,nodes:n})}})),o(`Parsed boundary node pairs by physical tag: ${JSON.stringify(t.boundaryNodePairs)}. These pairs will be used to identify boundary elements in the mesh.`),t},e.logSystem=function(e){"basic"!==e&&"debug"!==e?(console.log("%c[WARN] Invalid log level: "+e+". Using basic instead.","color: #FFC107; font-weight: bold;"),n="basic"):(n=e,s(`Log level set to: ${e}`))},e.plotSolution=function(e,t,n,o,s,i,r="structured"){const{nodesXCoordinates:a,nodesYCoordinates:l}=t;if("1D"===o&&"line"===s){let t;t=e.length>0&&Array.isArray(e[0])?e.map((e=>e[0])):e;let o=Array.from(a),s={x:o,y:t,mode:"lines",type:"scatter",line:{color:"rgb(219, 64, 82)",width:2},name:"Solution"},r=Math.min(window.innerWidth,700),l=Math.max(...o),d=r/l,c={title:`line plot - ${n}`,width:Math.max(d*l,400),height:350,xaxis:{title:"x"},yaxis:{title:"Solution"},margin:{l:70,r:40,t:50,b:50}};Plotly.newPlot(i,[s],c,{responsive:!0})}else if("2D"===o&&"contour"===s){const t="structured"===r,o=new Set(a).size,d=new Set(l).size;let c;c=Array.isArray(e[0])?e.map((e=>e[0])):e;let u=Math.min(window.innerWidth,700),h=Math.max(...a),m=Math.max(...l)/h,f=Math.min(u,600),p={title:`${s} plot - ${n}`,width:f,height:f*m*.8,xaxis:{title:"x"},yaxis:{title:"y"},margin:{l:50,r:50,t:50,b:50},hovermode:"closest"};if(t){const t=o,n=d;math.reshape(Array.from(a),[t,n]);let s=math.reshape(Array.from(l),[t,n]),r=math.reshape(Array.from(e),[t,n]),c=math.transpose(r),u=[];for(let e=0;e<t*n;e+=n){let t=a[e];u.push(t)}let h={z:c,type:"contour",contours:{coloring:"heatmap",showlabels:!1},colorbar:{title:"Solution"},x:u,y:s[0],name:"Solution Field"};Plotly.newPlot(i,[h],p,{responsive:!0})}else{let e={x:a,y:l,z:c,type:"contour",contours:{coloring:"heatmap",showlabels:!1},colorbar:{title:"Solution"},name:"Solution Field"};Plotly.newPlot(i,[e],p,{responsive:!0})}}},e.printVersion=async function(){s("Fetching latest FEAScript version information...");try{const e=await fetch("https://api.github.com/repos/FEAScript/FEAScript/commits/main"),t=await e.json(),n=new Date(t.commit.committer.date).toLocaleString();return s(`Latest FEAScript update: ${n}`),n}catch(e){return i("Failed to fetch version information: "+e),"Version information unavailable"}},Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=feascript.umd.js.map
