function _loadWasmModule(e,t,n){for(var o=t.length,s="="==t[o-2]?2:"="==t[o-1]?1:0,i=new Uint8Array(3*o/4-s),r="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",a=new Uint8Array(130),l=0;l<64;l++)a[r.charCodeAt(l)]=l;for(var d=0,c=0;d<o;d+=4){var u=a[t.charCodeAt(d+1)],m=a[t.charCodeAt(d+2)];i[c++]=a[t.charCodeAt(d)]<<2|u>>4,i[c++]=(15&u)<<4|m>>2,i[c++]=(3&m)<<6|63&a[t.charCodeAt(d+3)]}if(n&&!e)return WebAssembly.instantiate(i,n);if(n||e){var h=new WebAssembly.Module(i);return n?new WebAssembly.Instance(h,n):h}return WebAssembly.compile(i)}!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).FEAScript={})}(this,(function(e){"use strict";function t(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n]*e[n];return t=Math.sqrt(t),t}let n="basic";function o(e){"debug"===n&&console.log("%c[DEBUG] "+e,"color: #2196F3; font-weight: bold;")}function s(e){console.log("%c[INFO] "+e,"color: #4CAF50; font-weight: bold;")}function i(e){console.log("%c[ERROR] "+e,"color: #F44336; font-weight: bold;")}
/**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   */
const r=Symbol("Comlink.proxy"),a=Symbol("Comlink.endpoint"),l=Symbol("Comlink.releaseProxy"),d=Symbol("Comlink.finalizer"),c=Symbol("Comlink.thrown"),u=e=>"object"==typeof e&&null!==e||"function"==typeof e,m=new Map([["proxy",{canHandle:e=>u(e)&&e[r],serialize(e){const{port1:t,port2:n}=new MessageChannel;return h(e,t),[n,[n]]},deserialize:e=>(e.start(),p(e))}],["throw",{canHandle:e=>u(e)&&c in e,serialize({value:e}){let t;return t=e instanceof Error?{isError:!0,value:{message:e.message,name:e.name,stack:e.stack}}:{isError:!1,value:e},[t,[]]},deserialize(e){if(e.isError)throw Object.assign(new Error(e.value.message),e.value);throw e.value}}]]);function h(e,t=globalThis,n=["*"]){t.addEventListener("message",(function o(s){if(!s||!s.data)return;if(!function(e,t){for(const n of e){if(t===n||"*"===n)return!0;if(n instanceof RegExp&&n.test(t))return!0}return!1}(n,s.origin))return void console.warn(`Invalid origin '${s.origin}' for comlink proxy`);const{id:i,type:a,path:l}=Object.assign({path:[]},s.data),u=(s.data.argumentList||[]).map($);let m;try{const t=l.slice(0,-1).reduce(((e,t)=>e[t]),e),n=l.reduce(((e,t)=>e[t]),e);switch(a){case"GET":m=n;break;case"SET":t[l.slice(-1)[0]]=$(s.data.value),m=!0;break;case"APPLY":m=n.apply(t,u);break;case"CONSTRUCT":m=function(e){return Object.assign(e,{[r]:!0})}(new n(...u));break;case"ENDPOINT":{const{port1:t,port2:n}=new MessageChannel;h(e,n),m=function(e,t){return M.set(e,t),e}(t,[t])}break;case"RELEASE":m=void 0;break;default:return}}catch(e){m={value:e,[c]:0}}Promise.resolve(m).catch((e=>({value:e,[c]:0}))).then((n=>{const[s,r]=D(n);t.postMessage(Object.assign(Object.assign({},s),{id:i}),r),"RELEASE"===a&&(t.removeEventListener("message",o),f(t),d in e&&"function"==typeof e[d]&&e[d]())})).catch((e=>{const[n,o]=D({value:new TypeError("Unserializable return value"),[c]:0});t.postMessage(Object.assign(Object.assign({},n),{id:i}),o)}))})),t.start&&t.start()}function f(e){(function(e){return"MessagePort"===e.constructor.name})(e)&&e.close()}function p(e,t){const n=new Map;return e.addEventListener("message",(function(e){const{data:t}=e;if(!t||!t.id)return;const o=n.get(t.id);if(o)try{o(t)}finally{n.delete(t.id)}})),v(e,n,[],t)}function b(e){if(e)throw new Error("Proxy has been released and is not useable")}function g(e){return F(e,new Map,{type:"RELEASE"}).then((()=>{f(e)}))}const y=new WeakMap,E="FinalizationRegistry"in globalThis&&new FinalizationRegistry((e=>{const t=(y.get(e)||0)-1;y.set(e,t),0===t&&g(e)}));function v(e,t,n=[],o=function(){}){let s=!1;const i=new Proxy(o,{get(o,r){if(b(s),r===l)return()=>{!function(e){E&&E.unregister(e)}(i),g(e),t.clear(),s=!0};if("then"===r){if(0===n.length)return{then:()=>i};const o=F(e,t,{type:"GET",path:n.map((e=>e.toString()))}).then($);return o.then.bind(o)}return v(e,t,[...n,r])},set(o,i,r){b(s);const[a,l]=D(r);return F(e,t,{type:"SET",path:[...n,i].map((e=>e.toString())),value:a},l).then($)},apply(o,i,r){b(s);const l=n[n.length-1];if(l===a)return F(e,t,{type:"ENDPOINT"}).then($);if("bind"===l)return v(e,t,n.slice(0,-1));const[d,c]=C(r);return F(e,t,{type:"APPLY",path:n.map((e=>e.toString())),argumentList:d},c).then($)},construct(o,i){b(s);const[r,a]=C(i);return F(e,t,{type:"CONSTRUCT",path:n.map((e=>e.toString())),argumentList:r},a).then($)}});return function(e,t){const n=(y.get(t)||0)+1;y.set(t,n),E&&E.register(e,t,e)}(i,e),i}function C(e){const t=e.map(D);return[t.map((e=>e[0])),(n=t.map((e=>e[1])),Array.prototype.concat.apply([],n))];var n}const M=new WeakMap;function D(e){for(const[t,n]of m)if(n.canHandle(e)){const[o,s]=n.serialize(e);return[{type:"HANDLER",name:t,value:o},s]}return[{type:"RAW",value:e},M.get(e)||[]]}function $(e){switch(e.type){case"HANDLER":return m.get(e.name).deserialize(e.value);case"RAW":return e.value}}function F(e,t,n,o){return new Promise((s=>{const i=new Array(4).fill(0).map((()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16))).join("-");t.set(i,s),e.start&&e.start(),e.postMessage(Object.assign({id:i},n),o)}))}function A(e,t,n,r={}){const{maxIterations:a=1e4,tolerance:l=1e-4}=r;let d=[],c=!0,u=0;if(s(`Solving system using ${e}...`),console.time("systemSolving"),"lusolve"===e){const e=math.sparse(t),o=math.slu(e,1,1);let s=math.lusolve(o,n);d=math.squeeze(s).valueOf()}else if("jacobi"===e){const e=function(e,t,n,o={}){const{maxIterations:s,tolerance:i}=o,r=e.length;let a=[...n],l=new Array(r);for(let n=0;n<s;n++){for(let n=0;n<r;n++){let o=0;for(let t=0;t<r;t++)n!==t&&(o+=e[n][t]*a[t]);l[n]=(t[n]-o)/e[n][n]}let o=0;for(let e=0;e<r;e++)o=Math.max(o,Math.abs(l[e]-a[e]));if(a=[...l],o<i)return{solutionVector:a,iterations:n+1,converged:!0}}return{solutionVector:a,iterations:s,converged:!1}}(t,n,new Array(n.length).fill(0),{maxIterations:a,tolerance:l});e.converged?o(`Jacobi method converged in ${e.iterations} iterations`):i(`Jacobi method did not converge after ${e.iterations} iterations`),d=e.solutionVector,c=e.converged,u=e.iterations}else i(`Unknown solver method: ${e}`);return console.timeEnd("systemSolving"),s("System solved successfully"),{solutionVector:d,converged:c,iterations:u}}async function x(e,t,n,r={}){const{maxIterations:a=1e4,tolerance:l=1e-4}=r;s(`Solving system using ${e}...`),console.time("systemSolving");const d=Array.isArray(t)?t:t?.toArray?.()??t,c=Array.isArray(n)?n:n?.toArray?.()??n;let u,m=null,h=null,f=[],b=!0;if("jacobi-gpu"===e){m=await async function(){const e=new Worker(new URL("../workers/webgpuWorkerScript.js","undefined"==typeof document&&"undefined"==typeof location?new(require("url").URL)("file:"+__filename).href:"undefined"==typeof document?location.href:document.currentScript&&"SCRIPT"===document.currentScript.tagName.toUpperCase()&&document.currentScript.src||new URL("feascript.umd.js",document.baseURI).href),{type:"module"}),t=p(e);return await t.initialize(),{computeEngine:t,worker:e}}(),h=m.computeEngine;const e=new Array(c.length).fill(0);let t;t=await h.webgpuJacobiSolver(d,c,e,{maxIterations:a,tolerance:l}),f=t.solutionVector,b=t.converged,u=t.iterations,b?o(`Jacobi method converged in ${u} iterations`):i(`Jacobi method did not converge after ${u} iterations`)}else i(`Unknown solver method: ${e}`);return console.timeEnd("systemSolving"),s(`System solved successfully (${e})`),m&&(await(h?.destroy?.().catch((()=>{}))),m.worker.terminate()),{solutionVector:f,converged:b,iterations:u}}class w{constructor({meshDimension:e,elementOrder:t}){this.meshDimension=e,this.elementOrder=t}getBasisFunctions(e,t=null){let n=[],o=[],s=[];if("1D"===this.meshDimension)"linear"===this.elementOrder?(n[0]=1-e,n[1]=e,o[0]=-1,o[1]=1):"quadratic"===this.elementOrder&&(n[0]=1-3*e+2*e**2,n[1]=4*e-4*e**2,n[2]=2*e**2-e,o[0]=4*e-3,o[1]=4-8*e,o[2]=4*e-1);else if("2D"===this.meshDimension){if(null===t)return void i("Eta coordinate is required for 2D elements");if("linear"===this.elementOrder){function r(e){return 1-e}n[0]=r(e)*r(t),n[1]=r(e)*t,n[2]=e*r(t),n[3]=e*t,o[0]=-1*r(t),o[1]=-1*t,o[2]=1*r(t),o[3]=1*t,s[0]=-1*r(e),s[1]=1*r(e),s[2]=-1*e,s[3]=1*e}else if("quadratic"===this.elementOrder){function a(e){return 2*e**2-3*e+1}function l(e){return-4*e**2+4*e}function d(e){return 2*e**2-e}function c(e){return 4*e-3}function u(e){return-8*e+4}function m(e){return 4*e-1}n[0]=a(e)*a(t),n[1]=a(e)*l(t),n[2]=a(e)*d(t),n[3]=l(e)*a(t),n[4]=l(e)*l(t),n[5]=l(e)*d(t),n[6]=d(e)*a(t),n[7]=d(e)*l(t),n[8]=d(e)*d(t),o[0]=c(e)*a(t),o[1]=c(e)*l(t),o[2]=c(e)*d(t),o[3]=u(e)*a(t),o[4]=u(e)*l(t),o[5]=u(e)*d(t),o[6]=m(e)*a(t),o[7]=m(e)*l(t),o[8]=m(e)*d(t),s[0]=a(e)*c(t),s[1]=a(e)*u(t),s[2]=a(e)*m(t),s[3]=l(e)*c(t),s[4]=l(e)*u(t),s[5]=l(e)*m(t),s[6]=d(e)*c(t),s[7]=d(e)*u(t),s[8]=d(e)*m(t)}}return{basisFunction:n,basisFunctionDerivKsi:o,basisFunctionDerivEta:s}}}class S{constructor({numElementsX:e=null,maxX:t=null,numElementsY:n=null,maxY:o=null,meshDimension:i=null,elementOrder:r="linear",parsedMesh:a=null}){this.numElementsX=e,this.numElementsY=n,this.maxX=t,this.maxY=o,this.meshDimension=i,this.elementOrder=r,this.parsedMesh=a,this.boundaryElementsProcessed=!1,this.parsedMesh&&(s("Using pre-parsed mesh from gmshReader data for mesh generation."),this.parseMeshFromGmsh())}parseMeshFromGmsh(){if(this.parsedMesh.nodalNumbering||i("No valid nodal numbering found in the parsed mesh."),Array.isArray(this.parsedMesh.nodalNumbering))return this.boundaryElementsProcessed=!0,this.parsedMesh.boundaryElementsProcessed=!0,this.parsedMesh;if("object"==typeof this.parsedMesh.nodalNumbering&&!Array.isArray(this.parsedMesh.nodalNumbering)){const e=this.parsedMesh.nodalNumbering.quadElements||[];if(this.parsedMesh.nodalNumbering.triangleElements,o("Initial parsed mesh nodal numbering from Gmsh format: "+JSON.stringify(this.parsedMesh.nodalNumbering)),this.parsedMesh.elementTypes[3]||this.parsedMesh.elementTypes[10]){const t=[];for(let n=0;n<e.length;n++){const o=e[n],s=new Array(o.length);4===o.length?(s[0]=o[0],s[1]=o[3],s[2]=o[1],s[3]=o[2]):9===o.length&&(s[0]=o[0],s[1]=o[7],s[2]=o[3],s[3]=o[4],s[4]=o[8],s[5]=o[6],s[6]=o[1],s[7]=o[5],s[8]=o[2]),t.push(s)}this.parsedMesh.nodalNumbering=t}else this.parsedMesh.elementTypes[2]&&i("Element type is neither triangle nor quad; mapping for this type is not implemented yet.");if(o("Nodal numbering after mapping from Gmsh to FEAScript format: "+JSON.stringify(this.parsedMesh.nodalNumbering)),this.parsedMesh.physicalPropMap&&this.parsedMesh.boundaryElements){if(Array.isArray(this.parsedMesh.boundaryElements)&&this.parsedMesh.boundaryElements.length>0&&void 0===this.parsedMesh.boundaryElements[0]){const e=[];for(let t=1;t<this.parsedMesh.boundaryElements.length;t++)this.parsedMesh.boundaryElements[t]&&e.push(this.parsedMesh.boundaryElements[t]);this.parsedMesh.boundaryElements=e}if(this.parsedMesh.boundaryNodePairs&&!this.parsedMesh.boundaryElementsProcessed&&(this.parsedMesh.boundaryElements=[],this.parsedMesh.physicalPropMap.forEach((e=>{if(1===e.dimension){const t=this.parsedMesh.boundaryNodePairs[e.tag]||[];t.length>0&&(this.parsedMesh.boundaryElements[e.tag]||(this.parsedMesh.boundaryElements[e.tag]=[]),t.forEach((t=>{const n=t[0],s=t[1];o(`Processing boundary node pair: [${n}, ${s}] for boundary ${e.tag} (${e.name||"unnamed"})`);let r=!1;for(let t=0;t<this.parsedMesh.nodalNumbering.length;t++){const i=this.parsedMesh.nodalNumbering[t];if(4===i.length){if(i.includes(n)&&i.includes(s)){let a;const l=i.indexOf(n),d=i.indexOf(s);o(`  Found element ${t} containing boundary nodes. Element nodes: [${i.join(", ")}]`),o(`  Node ${n} is at index ${l}, Node ${s} is at index ${d} in the element`),0===l&&2===d||2===l&&0===d?(a=0,o(`  These nodes form the BOTTOM side (${a}) of element ${t}`)):0===l&&1===d||1===l&&0===d?(a=1,o(`  These nodes form the LEFT side (${a}) of element ${t}`)):1===l&&3===d||3===l&&1===d?(a=2,o(`  These nodes form the TOP side (${a}) of element ${t}`)):(2===l&&3===d||3===l&&2===d)&&(a=3,o(`  These nodes form the RIGHT side (${a}) of element ${t}`)),this.parsedMesh.boundaryElements[e.tag].push([t,a]),o(`  Added element-side pair [${t}, ${a}] to boundary tag ${e.tag}`),r=!0;break}}else if(9===i.length&&i.includes(n)&&i.includes(s)){let a;const l=i.indexOf(n),d=i.indexOf(s);o(`  Found element ${t} containing boundary nodes. Element nodes: [${i.join(", ")}]`),o(`  Node ${n} is at index ${l}, Node ${s} is at index ${d} in the element`),0===l&&6===d||6===l&&0===d||0===l&&3===d||3===l&&0===d||3===l&&6===d||6===l&&3===d?(a=0,o(`  These nodes form the BOTTOM side (${a}) of element ${t}`)):0===l&&2===d||2===l&&0===d||0===l&&1===d||1===l&&0===d||1===l&&2===d||2===l&&1===d?(a=1,o(`  These nodes form the LEFT side (${a}) of element ${t}`)):2===l&&8===d||8===l&&2===d||2===l&&5===d||5===l&&2===d||5===l&&8===d||8===l&&5===d?(a=2,o(`  These nodes form the TOP side (${a}) of element ${t}`)):(6===l&&8===d||8===l&&6===d||6===l&&7===d||7===l&&6===d||7===l&&8===d||8===l&&7===d)&&(a=3,o(`  These nodes form the RIGHT side (${a}) of element ${t}`)),this.parsedMesh.boundaryElements[e.tag].push([t,a]),o(`  Added element-side pair [${t}, ${a}] to boundary tag ${e.tag}`),r=!0;break}}r||i(`Could not find element containing boundary nodes ${n} and ${s}. Boundary may be incomplete.`)})))}})),this.boundaryElementsProcessed=!0,this.parsedMesh.boundaryElements.length>0&&void 0===this.parsedMesh.boundaryElements[0])){const e=[];for(let t=1;t<this.parsedMesh.boundaryElements.length;t++)this.parsedMesh.boundaryElements[t]&&e.push(this.parsedMesh.boundaryElements[t]);this.parsedMesh.boundaryElements=e}}}return this.parsedMesh}}class O extends S{constructor({numElementsX:e=null,maxX:t=null,elementOrder:n="linear",parsedMesh:o=null}){super({numElementsX:e,maxX:t,numElementsY:1,maxY:0,meshDimension:"1D",elementOrder:n,parsedMesh:o}),null!==this.numElementsX&&null!==this.maxX||i("numElementsX and maxX are required parameters when generating a 1D mesh from geometry")}generateMesh(){let e=[];let t,n;if("linear"===this.elementOrder){t=this.numElementsX+1,n=(this.maxX-0)/this.numElementsX,e[0]=0;for(let o=1;o<t;o++)e[o]=e[o-1]+n}else if("quadratic"===this.elementOrder){t=2*this.numElementsX+1,n=(this.maxX-0)/this.numElementsX,e[0]=0;for(let o=1;o<t;o++)e[o]=e[o-1]+n/2}const s=this.generateNodalNumbering1D(this.numElementsX,t,this.elementOrder),i=this.findBoundaryElements();return o("Generated node X coordinates: "+JSON.stringify(e)),{nodesXCoordinates:e,totalNodesX:t,nodalNumbering:s,boundaryElements:i}}generateNodalNumbering1D(e,t,n){let o=[];if("linear"===n)for(let t=0;t<e;t++){o[t]=[];for(let e=1;e<=2;e++)o[t][e-1]=t+e}else if("quadratic"===n){let t=0;for(let n=0;n<e;n++){o[n]=[];for(let e=1;e<=3;e++)o[n][e-1]=n+e+t;t+=1}}return o}findBoundaryElements(){const e=[];for(let t=0;t<2;t++)e.push([]);return e[0].push([0,0]),e[1].push([this.numElementsX-1,1]),o("Identified boundary elements by side: "+JSON.stringify(e)),this.boundaryElementsProcessed=!0,e}}class N extends S{constructor({numElementsX:e=null,maxX:t=null,numElementsY:n=null,maxY:o=null,elementOrder:s="linear",parsedMesh:r=null}){super({numElementsX:e,maxX:t,numElementsY:n,maxY:o,meshDimension:"2D",elementOrder:s,parsedMesh:r}),r||null!==this.numElementsX&&null!==this.maxX&&null!==this.numElementsY&&null!==this.maxY||i("numElementsX, maxX, numElementsY, and maxY are required parameters when generating a 2D mesh from geometry")}generateMesh(){let e=[],t=[];let n,s,i,r;if("linear"===this.elementOrder){n=this.numElementsX+1,s=this.numElementsY+1,i=(this.maxX-0)/this.numElementsX,r=(this.maxY-0)/this.numElementsY,e[0]=0,t[0]=0;for(let n=1;n<s;n++)e[n]=e[0],t[n]=t[0]+n*r;for(let o=1;o<n;o++){const n=o*s;e[n]=e[0]+o*i,t[n]=t[0];for(let o=1;o<s;o++)e[n+o]=e[n],t[n+o]=t[n]+o*r}}else if("quadratic"===this.elementOrder){n=2*this.numElementsX+1,s=2*this.numElementsY+1,i=(this.maxX-0)/this.numElementsX,r=(this.maxY-0)/this.numElementsY,e[0]=0,t[0]=0;for(let n=1;n<s;n++)e[n]=e[0],t[n]=t[0]+n*r/2;for(let o=1;o<n;o++){const n=o*s;e[n]=e[0]+o*i/2,t[n]=t[0];for(let o=1;o<s;o++)e[n+o]=e[n],t[n+o]=t[n]+o*r/2}}const a=this.generateNodalNumbering2D(this.numElementsX,this.numElementsY,s,this.elementOrder),l=this.findBoundaryElements();return o("Generated node X coordinates: "+JSON.stringify(e)),o("Generated node Y coordinates: "+JSON.stringify(t)),{nodesXCoordinates:e,nodesYCoordinates:t,totalNodesX:n,totalNodesY:s,nodalNumbering:a,boundaryElements:l}}generateNodalNumbering2D(e,t,n,o){let s=0,i=[];if("linear"===o){let n=0,o=2;for(let s=0;s<e*t;s++)n+=1,i[s]=[],i[s][0]=s+o-1,i[s][1]=s+o,i[s][2]=s+o+t,i[s][3]=s+o+t+1,n===t&&(o+=1,n=0)}else if("quadratic"===o)for(let o=1;o<=e;o++)for(let e=1;e<=t;e++){i[s]=[];for(let t=1;t<=3;t++){let r=3*t-2;i[s][r-1]=n*(2*o+t-3)+2*e-1,i[s][r]=i[s][r-1]+1,i[s][r+1]=i[s][r-1]+2}s+=1}return i}findBoundaryElements(){const e=[];for(let t=0;t<4;t++)e.push([]);for(let t=0;t<this.numElementsX;t++)for(let n=0;n<this.numElementsY;n++){const o=t*this.numElementsY+n;0===n&&e[0].push([o,0]),0===t&&e[1].push([o,1]),n===this.numElementsY-1&&e[2].push([o,2]),t===this.numElementsX-1&&e[3].push([o,3])}return o("Identified boundary elements by side: "+JSON.stringify(e)),this.boundaryElementsProcessed=!0,e}}class X{constructor({meshDimension:e,elementOrder:t}){this.meshDimension=e,this.elementOrder=t}getGaussPointsAndWeights(){let e=[],t=[];return"linear"===this.elementOrder?(e[0]=.5,t[0]=1):"quadratic"===this.elementOrder&&(e[0]=(1-Math.sqrt(.6))/2,e[1]=.5,e[2]=(1+Math.sqrt(.6))/2,t[0]=5/18,t[1]=8/18,t[2]=5/18),{gaussPoints:e,gaussWeights:t}}}function V(e){const{meshDimension:t,numElementsX:n,numElementsY:s,maxX:r,maxY:a,elementOrder:l,parsedMesh:d}=e;let c;"1D"===t?c=new O({numElementsX:n,maxX:r,elementOrder:l,parsedMesh:d}):"2D"===t?c=new N({numElementsX:n,maxX:r,numElementsY:s,maxY:a,elementOrder:l,parsedMesh:d}):i("Mesh dimension must be either '1D' or '2D'.");const u=c.boundaryElementsProcessed?c.parsedMesh:c.generateMesh();let m=u.nodesXCoordinates,h=u.nodesYCoordinates,f=u.totalNodesX,p=u.totalNodesY,b=u.nodalNumbering,g=u.boundaryElements;let y,E;return null!=d?(y=b.length,E=m.length,o(`Using parsed mesh with ${y} elements and ${E} nodes`)):(y=n*("2D"===t?s:1),E=f*("2D"===t?p:1),o(`Using mesh generated from geometry with ${y} elements and ${E} nodes`)),{nodesXCoordinates:m,nodesYCoordinates:h,totalNodesX:f,totalNodesY:p,nop:b,boundaryElements:g,totalElements:y,totalNodes:E,meshDimension:t,elementOrder:l}}function P(e){const{totalNodes:t,nop:n,meshDimension:o,elementOrder:s}=e;let i=[],r=[];for(let e=0;e<t;e++){i[e]=0,r.push([]);for(let n=0;n<t;n++)r[e][n]=0}const a=new w({meshDimension:o,elementOrder:s});let l=new X({meshDimension:o,elementOrder:s}).getGaussPointsAndWeights();return{residualVector:i,jacobianMatrix:r,localToGlobalMap:[],basisFunctions:a,gaussPoints:l.gaussPoints,gaussWeights:l.gaussWeights,nodesPerElement:n[0].length}}function k(e){const{basisFunction:t,basisFunctionDerivKsi:n,nodesXCoordinates:o,localToGlobalMap:s,nodesPerElement:i}=e;let r=0,a=0;for(let e=0;e<i;e++)r+=o[s[e]]*t[e],a+=o[s[e]]*n[e];let l=a,d=[];for(let e=0;e<i;e++)d[e]=n[e]/l;return{xCoordinates:r,detJacobian:l,basisFunctionDerivX:d}}function T(e){const{basisFunction:t,basisFunctionDerivKsi:n,basisFunctionDerivEta:o,nodesXCoordinates:s,nodesYCoordinates:i,localToGlobalMap:r,nodesPerElement:a}=e;let l=0,d=0,c=0,u=0,m=0,h=0;for(let e=0;e<a;e++)l+=s[r[e]]*t[e],d+=i[r[e]]*t[e],c+=s[r[e]]*n[e],u+=s[r[e]]*o[e],m+=i[r[e]]*n[e],h+=i[r[e]]*o[e];let f=c*h-u*m,p=[],b=[];for(let e=0;e<a;e++)p[e]=(h*n[e]-m*o[e])/f,b[e]=(c*o[e]-u*n[e])/f;return{xCoordinates:l,yCoordinates:d,detJacobian:f,basisFunctionDerivX:p,basisFunctionDerivY:b}}function I(e,t,n){const[o,s,i]=n,r=(s[1]-i[1])*(o[0]-i[0])+(i[0]-s[0])*(o[1]-i[1]),a=((s[1]-i[1])*(e-i[0])+(i[0]-s[0])*(t-i[1]))/r,l=((i[1]-o[1])*(e-i[0])+(o[0]-i[0])*(t-i[1]))/r;return{inside:a>=-1e-12&&l>=-1e-12&&1-a-l>=-1e-12,ksi:a,eta:l}}function R(e,t,n){const[o,s]=function(e){const[t,n,o,s]=e;return[[t,n,s],[t,o,s]]}(n),i=I(e,t,o),r=I(e,t,s),a=i.inside||r.inside;let l=0,d=0;if(a){const[o,s,i,r]=n,a=(n,o)=>Math.abs((o[0]-n[0])*(n[1]-t)-(n[0]-e)*(o[1]-n[1]))/Math.sqrt((o[0]-n[0])**2+(o[1]-n[1])**2),c=a(o,s),u=a(i,r),m=a(o,i);l=c/(c+u),d=m/(m+a(s,r))}return{inside:a,ksi:l,eta:d}}class Y{constructor(e,t,n,o,s){this.boundaryConditions=e,this.boundaryElements=t,this.nop=n,this.meshDimension=o,this.elementOrder=s}imposeConstantTempBoundaryConditions(e,t){"1D"===this.meshDimension?Object.keys(this.boundaryConditions).forEach((n=>{if("constantTemp"===this.boundaryConditions[n][0]){const s=this.boundaryConditions[n][1];o(`Boundary ${n}: Applying constant temperature of ${s} K (Dirichlet condition)`),this.boundaryElements[n].forEach((([n,i])=>{if("linear"===this.elementOrder){({0:[0],1:[1]})[i].forEach((i=>{const r=this.nop[n][i]-1;o(`  - Applied constant temperature to node ${r+1} (element ${n+1}, local node ${i+1})`),e[r]=s;for(let n=0;n<e.length;n++)t[r][n]=0;t[r][r]=1}))}else if("quadratic"===this.elementOrder){({0:[0],1:[2]})[i].forEach((i=>{const r=this.nop[n][i]-1;o(`  - Applied constant temperature to node ${r+1} (element ${n+1}, local node ${i+1})`),e[r]=s;for(let n=0;n<e.length;n++)t[r][n]=0;t[r][r]=1}))}}))}})):"2D"===this.meshDimension&&Object.keys(this.boundaryConditions).forEach((n=>{if("constantTemp"===this.boundaryConditions[n][0]){const s=this.boundaryConditions[n][1];o(`Boundary ${n}: Applying constant temperature of ${s} K (Dirichlet condition)`),this.boundaryElements[n].forEach((([n,i])=>{if("linear"===this.elementOrder){({0:[0,2],1:[0,1],2:[1,3],3:[2,3]})[i].forEach((i=>{const r=this.nop[n][i]-1;o(`  - Applied constant temperature to node ${r+1} (element ${n+1}, local node ${i+1})`),e[r]=s;for(let n=0;n<e.length;n++)t[r][n]=0;t[r][r]=1}))}else if("quadratic"===this.elementOrder){({0:[0,3,6],1:[0,1,2],2:[2,5,8],3:[6,7,8]})[i].forEach((i=>{const r=this.nop[n][i]-1;o(`  - Applied constant temperature to node ${r+1} (element ${n+1}, local node ${i+1})`),e[r]=s;for(let n=0;n<e.length;n++)t[r][n]=0;t[r][r]=1}))}}))}}))}imposeConstantTempBoundaryConditionsFront(e,t){"1D"===this.meshDimension?Object.keys(this.boundaryConditions).forEach((n=>{if("constantTemp"===this.boundaryConditions[n][0]){const s=this.boundaryConditions[n][1];o(`Boundary ${n}: Applying constant temperature of ${s} K (Dirichlet condition)`),this.boundaryElements[n].forEach((([n,i])=>{if("linear"===this.elementOrder){({0:[0],1:[1]})[i].forEach((i=>{const r=this.nop[n][i]-1;o(`  - Applied constant temperature to node ${r+1} (element ${n+1}, local node ${i+1})`),e[r]=1,t[r]=s}))}else if("quadratic"===this.elementOrder){({0:[0],2:[2]})[i].forEach((i=>{const r=this.nop[n][i]-1;o(`  - Applied constant temperature to node ${r+1} (element ${n+1}, local node ${i+1})`),e[r]=1,t[r]=s}))}}))}})):"2D"===this.meshDimension&&Object.keys(this.boundaryConditions).forEach((n=>{if("constantTemp"===this.boundaryConditions[n][0]){const s=this.boundaryConditions[n][1];o(`Boundary ${n}: Applying constant temperature of ${s} K (Dirichlet condition)`),this.boundaryElements[n].forEach((([n,i])=>{if("linear"===this.elementOrder){({0:[0,2],1:[0,1],2:[1,3],3:[2,3]})[i].forEach((i=>{const r=this.nop[n][i]-1;o(`  - Applied constant temperature to node ${r+1} (element ${n+1}, local node ${i+1})`),e[r]=1,t[r]=s}))}else if("quadratic"===this.elementOrder){({0:[0,3,6],1:[0,1,2],2:[2,5,8],3:[6,7,8]})[i].forEach((i=>{const r=this.nop[n][i]-1;o(`  - Applied constant temperature to node ${r+1} (element ${n+1}, local node ${i+1})`),e[r]=1,t[r]=s}))}}))}}))}imposeConvectionBoundaryConditions(e,t,n,s,i,r,a){let l=[],d=[];Object.keys(this.boundaryConditions).forEach((e=>{const t=this.boundaryConditions[e];"convection"===t[0]&&(l[e]=t[1],d[e]=t[2])})),"1D"===this.meshDimension?Object.keys(this.boundaryConditions).forEach((n=>{if("convection"===this.boundaryConditions[n][0]){const s=l[n],i=d[n];o(`Boundary ${n}: Applying convection with heat transfer coefficient h=${s} W/(m²·K) and external temperature T∞=${i} K`),this.boundaryElements[n].forEach((([n,r])=>{let a;"linear"===this.elementOrder?a=0===r?0:1:"quadratic"===this.elementOrder&&(a=0===r?0:2);const l=this.nop[n][a]-1;o(`  - Applied convection boundary condition to node ${l+1} (element ${n+1}, local node ${a+1})`),e[l]+=-s*i,t[l][l]+=s}))}})):"2D"===this.meshDimension&&Object.keys(this.boundaryConditions).forEach((c=>{if("convection"===this.boundaryConditions[c][0]){const u=l[c],m=d[c];o(`Boundary ${c}: Applying convection with heat transfer coefficient h=${u} W/(m²·K) and external temperature T∞=${m} K`),this.boundaryElements[c].forEach((([l,d])=>{if("linear"===this.elementOrder){let c,h,f,p,b;0===d?(c=n[0],h=0,f=0,p=3,b=2):1===d?(c=0,h=n[0],f=0,p=2,b=1):2===d?(c=n[0],h=1,f=1,p=4,b=2):3===d&&(c=1,h=n[0],f=2,p=4,b=1);let g=a.getBasisFunctions(c,h),y=g.basisFunction,E=g.basisFunctionDerivKsi,v=g.basisFunctionDerivEta,C=0,M=0,D=0,$=0;const F=this.nop[l].length;for(let e=0;e<F;e++){const t=this.nop[l][e]-1;0===d||2===d?(C+=i[t]*E[e],M+=r[t]*E[e]):1!==d&&3!==d||(D+=i[t]*v[e],$+=r[t]*v[e])}let A;A=0===d||2===d?Math.sqrt(C**2+M**2):Math.sqrt(D**2+$**2);for(let n=f;n<p;n+=b){let i=this.nop[l][n]-1;o(`  - Applied convection boundary condition to node ${i+1} (element ${l+1}, local node ${n+1})`),e[i]+=-s[0]*A*y[n]*u*m;for(let e=f;e<p;e+=b){let o=this.nop[l][e]-1;t[i][o]+=-s[0]*A*y[n]*y[e]*u}}}else if("quadratic"===this.elementOrder)for(let c=0;c<3;c++){let h,f,p,b,g;0===d?(h=n[c],f=0,p=0,b=7,g=3):1===d?(h=0,f=n[c],p=0,b=3,g=1):2===d?(h=n[c],f=1,p=2,b=9,g=3):3===d&&(h=1,f=n[c],p=6,b=9,g=1);let y=a.getBasisFunctions(h,f),E=y.basisFunction,v=y.basisFunctionDerivKsi,C=y.basisFunctionDerivEta,M=0,D=0,$=0,F=0;const A=this.nop[l].length;for(let e=0;e<A;e++){const t=this.nop[l][e]-1;0===d||2===d?(M+=i[t]*v[e],D+=r[t]*v[e]):1!==d&&3!==d||($+=i[t]*C[e],F+=r[t]*C[e])}let x;x=0===d||2===d?Math.sqrt(M**2+D**2):Math.sqrt($**2+F**2);for(let n=p;n<b;n+=g){let i=this.nop[l][n]-1;o(`  - Applied convection boundary condition to node ${i+1} (element ${l+1}, local node ${n+1})`),e[i]+=-s[c]*x*E[n]*u*m;for(let e=p;e<b;e+=g){let o=this.nop[l][e]-1;t[i][o]+=-s[c]*x*E[n]*E[e]*u}}}}))}}))}imposeConvectionBoundaryConditionsFront(e,t,n,s,i,r){let a=[],l=[];Object.keys(this.boundaryConditions).forEach((e=>{const t=this.boundaryConditions[e];"convection"===t[0]&&(a[e]=t[1],l[e]=t[2])}));const d=this.nop[e].length,c=Array(d).fill().map((()=>Array(d).fill(0))),u=Array(d).fill(0);for(const m in this.boundaryElements)if("convection"===this.boundaryConditions[m]?.[0]){const h=a[m],f=l[m];o(`Boundary ${m}: Applying convection with heat transfer coefficient h=${h} W/(m²·K) and external temperature T∞=${f} K`);const p=this.boundaryElements[m].find((([t,n])=>t===e));if(p){const a=p[1];if("1D"===this.meshDimension){let t;"linear"===this.elementOrder?t=0===a?0:1:"quadratic"===this.elementOrder&&(t=0===a?0:2),o(`  - Applied convection boundary condition to node ${t+1} (element ${e+1}, local node ${t+1})`),u[t]+=-h*f,c[t][t]+=h}else if("2D"===this.meshDimension)if("linear"===this.elementOrder){let o,l,m,p,b;0===a?(o=s[0],l=0,m=0,p=3,b=2):1===a?(o=0,l=s[0],m=0,p=2,b=1):2===a?(o=s[0],l=1,m=1,p=4,b=2):3===a&&(o=1,l=s[0],m=2,p=4,b=1);const g=r.getBasisFunctions(o,l),y=g.basisFunction,E=g.basisFunctionDerivKsi,v=g.basisFunctionDerivEta;let C,M=0,D=0,$=0,F=0;for(let o=0;o<d;o++){const s=this.nop[e][o]-1;0===a||2===a?(M+=t[s]*E[o],D+=n[s]*E[o]):1!==a&&3!==a||($+=t[s]*v[o],F+=n[s]*v[o])}C=0===a||2===a?Math.sqrt(M**2+D**2):Math.sqrt($**2+F**2);for(let e=m;e<p;e+=b){u[e]+=-i[0]*C*y[e]*h*f;for(let t=m;t<p;t+=b)c[e][t]+=-i[0]*C*y[e]*y[t]*h}}else if("quadratic"===this.elementOrder)for(let o=0;o<3;o++){let l,d,m,p,b;0===a?(l=s[o],d=0,m=0,p=7,b=3):1===a?(l=0,d=s[o],m=0,p=3,b=1):2===a?(l=s[o],d=1,m=2,p=9,b=3):3===a&&(l=1,d=s[o],m=6,p=9,b=1);let g=r.getBasisFunctions(l,d),y=g.basisFunction,E=g.basisFunctionDerivKsi,v=g.basisFunctionDerivEta,C=0,M=0,D=0,$=0;const F=this.nop[e].length;for(let o=0;o<F;o++){const s=this.nop[e][o]-1;0===a||2===a?(C+=t[s]*E[o],M+=n[s]*E[o]):1!==a&&3!==a||(D+=t[s]*v[o],$+=n[s]*v[o])}let A;A=0===a||2===a?Math.sqrt(C**2+M**2):Math.sqrt(D**2+$**2);for(let e=m;e<p;e+=b){u[e]+=-i[o]*A*y[e]*h*f;for(let t=m;t<p;t+=b)c[e][t]+=-i[o]*A*y[e]*y[t]*h}}}}return{localJacobianMatrix:c,localResidualVector:u}}}function B(e,t){s("Starting solid heat transfer matrix assembly...");const{nodesXCoordinates:n,nodesYCoordinates:o,nop:i,boundaryElements:r,totalElements:a,meshDimension:l,elementOrder:d}=e,c=P(e),{residualVector:u,jacobianMatrix:m,localToGlobalMap:h,basisFunctions:f,gaussPoints:p,gaussWeights:b,nodesPerElement:g}=c;for(let e=0;e<a;e++){for(let t=0;t<g;t++)h[t]=i[e][t]-1;for(let e=0;e<p.length;e++)if("1D"===l){const t=f.getBasisFunctions(p[e]),o=k({basisFunction:t.basisFunction,basisFunctionDerivKsi:t.basisFunctionDerivKsi,nodesXCoordinates:n,localToGlobalMap:h,nodesPerElement:g}),{detJacobian:s,basisFunctionDerivX:i}=o;for(let t=0;t<g;t++){let n=h[t];for(let o=0;o<g;o++){let r=h[o];m[n][r]+=-b[e]*s*(i[t]*i[o])}}}else if("2D"===l)for(let t=0;t<p.length;t++){const s=f.getBasisFunctions(p[e],p[t]),i=T({basisFunction:s.basisFunction,basisFunctionDerivKsi:s.basisFunctionDerivKsi,basisFunctionDerivEta:s.basisFunctionDerivEta,nodesXCoordinates:n,nodesYCoordinates:o,localToGlobalMap:h,nodesPerElement:g}),{detJacobian:r,basisFunctionDerivX:a,basisFunctionDerivY:l}=i;for(let n=0;n<g;n++){let o=h[n];for(let s=0;s<g;s++){let i=h[s];m[o][i]+=-b[e]*b[t]*r*(a[n]*a[s]+l[n]*l[s])}}}}const y=new Y(t,r,i,l,d);return y.imposeConvectionBoundaryConditions(u,m,p,b,n,o,f),y.imposeConstantTempBoundaryConditions(u,m),s("Solid heat transfer matrix assembly completed"),{jacobianMatrix:m,residualVector:u}}function W({elementIndex:e,nop:t,meshData:n,basisFunctions:o,FEAData:s}){const{gaussPoints:i,gaussWeights:r,nodesPerElement:a}=s,{nodesXCoordinates:l,nodesYCoordinates:d,meshDimension:c}=n,u=Array(a).fill().map((()=>Array(a).fill(0))),m=Array(a).fill(0),h=Array(a),f=Array(a);for(let n=0;n<a;n++)h[n]=Math.abs(t[e][n]),f[n]=Math.abs(t[e][n])-1;if("1D"===c)for(let e=0;e<i.length;e++){const{basisFunction:t,basisFunctionDerivKsi:n}=o.getBasisFunctions(i[e]),{detJacobian:s,basisFunctionDerivX:d}=k({basisFunction:t,basisFunctionDerivKsi:n,nodesXCoordinates:l,localToGlobalMap:f,nodesPerElement:a});for(let t=0;t<a;t++)for(let n=0;n<a;n++)u[t][n]-=r[e]*s*(d[t]*d[n])}else if("2D"===c)for(let e=0;e<i.length;e++)for(let t=0;t<i.length;t++){const{basisFunction:n,basisFunctionDerivKsi:s,basisFunctionDerivEta:c}=o.getBasisFunctions(i[e],i[t]),m=h.map((e=>e-1)),{detJacobian:f,basisFunctionDerivX:p,basisFunctionDerivY:b}=T({basisFunction:n,basisFunctionDerivKsi:s,basisFunctionDerivEta:c,nodesXCoordinates:l,nodesYCoordinates:d,localToGlobalMap:m,nodesPerElement:a});for(let n=0;n<a;n++)for(let o=0;o<a;o++)u[n][o]-=r[e]*r[t]*f*(p[n]*p[o]+b[n]*b[o])}return{localJacobianMatrix:u,localResidualVector:m,ngl:h}}class q{constructor(e,t,n,o,s){this.boundaryConditions=e,this.boundaryElements=t,this.nop=n,this.meshDimension=o,this.elementOrder=s}imposeDirichletBoundaryConditions(e,t){"1D"===this.meshDimension?Object.keys(this.boundaryConditions).forEach((n=>{if("constantValue"===this.boundaryConditions[n][0]){const s=this.boundaryConditions[n][1];o(`Boundary ${n}: Applying constant value of ${s} (Dirichlet condition)`),this.boundaryElements[n].forEach((([n,i])=>{if("linear"===this.elementOrder){({0:[0],1:[1]})[i].forEach((i=>{const r=this.nop[n][i]-1;o(`  - Applied constant value to node ${r+1} (element ${n+1}, local node ${i+1})`),e[r]=s;for(let n=0;n<e.length;n++)t[r][n]=0;t[r][r]=1}))}else if("quadratic"===this.elementOrder){({0:[0],1:[2]})[i].forEach((i=>{const r=this.nop[n][i]-1;o(`  - Applied constant value to node ${r+1} (element ${n+1}, local node ${i+1})`),e[r]=s;for(let n=0;n<e.length;n++)t[r][n]=0;t[r][r]=1}))}}))}})):"2D"===this.meshDimension&&Object.keys(this.boundaryConditions).forEach((n=>{if("constantValue"===this.boundaryConditions[n][0]){const s=this.boundaryConditions[n][1];o(`Boundary ${n}: Applying constant value of ${s} (Dirichlet condition)`),this.boundaryElements[n].forEach((([n,i])=>{if("linear"===this.elementOrder){({0:[0,2],1:[0,1],2:[1,3],3:[2,3]})[i].forEach((i=>{const r=this.nop[n][i]-1;o(`  - Applied constant value to node ${r+1} (element ${n+1}, local node ${i+1})`),e[r]=s;for(let n=0;n<e.length;n++)t[r][n]=0;t[r][r]=1}))}else if("quadratic"===this.elementOrder){({0:[0,3,6],1:[0,1,2],2:[2,5,8],3:[6,7,8]})[i].forEach((i=>{const r=this.nop[n][i]-1;o(`  - Applied constant value to node ${r+1} (element ${n+1}, local node ${i+1})`),e[r]=s;for(let n=0;n<e.length;n++)t[r][n]=0;t[r][r]=1}))}}))}}))}imposeConstantValueBoundaryConditionsFront(e,t){"1D"===this.meshDimension?Object.keys(this.boundaryConditions).forEach((n=>{if("constantValue"===this.boundaryConditions[n][0]){const s=this.boundaryConditions[n][1];o(`Boundary ${n}: Applying constant value of ${s} (Dirichlet condition)`),this.boundaryElements[n].forEach((([n,i])=>{if("linear"===this.elementOrder){({0:[0],1:[1]})[i].forEach((i=>{const r=this.nop[n][i]-1;o(`  - Applied constant value to node ${r+1} (element ${n+1}, local node ${i+1})`),e[r]=1,t[r]=s}))}else if("quadratic"===this.elementOrder){({0:[0],2:[2]})[i].forEach((i=>{const r=this.nop[n][i]-1;o(`  - Applied constant value to node ${r+1} (element ${n+1}, local node ${i+1})`),e[r]=1,t[r]=s}))}}))}})):"2D"===this.meshDimension&&Object.keys(this.boundaryConditions).forEach((n=>{if("constantValue"===this.boundaryConditions[n][0]){const s=this.boundaryConditions[n][1];o(`Boundary ${n}: Applying constant value of ${s} (Dirichlet condition)`),this.boundaryElements[n].forEach((([n,i])=>{if("linear"===this.elementOrder){({0:[0,2],1:[0,1],2:[1,3],3:[2,3]})[i].forEach((i=>{const r=this.nop[n][i]-1;o(`  - Applied constant value to node ${r+1} (element ${n+1}, local node ${i+1})`),e[r]=1,t[r]=s}))}else if("quadratic"===this.elementOrder){({0:[0,3,6],1:[0,1,2],2:[2,5,8],3:[6,7,8]})[i].forEach((i=>{const r=this.nop[n][i]-1;o(`  - Applied constant value to node ${r+1} (element ${n+1}, local node ${i+1})`),e[r]=1,t[r]=s}))}}))}}))}}function j(e,t,n,i){s("Starting front propagation matrix assembly...");let r=1-i+.01;o(`eikonalViscousTerm: ${r}`),o(`eikonalActivationFlag: ${i}`);const{nodesXCoordinates:a,nodesYCoordinates:l,nop:d,boundaryElements:c,totalElements:u,meshDimension:m,elementOrder:h}=e,f=P(e),{residualVector:p,jacobianMatrix:b,localToGlobalMap:g,basisFunctions:y,gaussPoints:E,gaussWeights:v,nodesPerElement:C}=f;for(let e=0;e<u;e++){for(let t=0;t<C;t++)g[t]=d[e][t]-1;for(let e=0;e<E.length;e++)if("1D"===m){errorLog("1D front propagation is not yet supported");let t=y.getBasisFunctions(E[e]);const o=k({basisFunction:t.basisFunction,basisFunctionDerivKsi:t.basisFunctionDerivKsi,nodesXCoordinates:a,localToGlobalMap:g,nodesPerElement:C}),{detJacobian:s,basisFunctionDerivX:i}=o;t.basisFunction;let r=0;for(let e=0;e<C;e++)r+=n[g[e]]*i[e];for(let e=0;e<C;e++){g[e];for(let e=0;e<C;e++)g[e]}}else if("2D"===m)for(let t=0;t<E.length;t++){let o=y.getBasisFunctions(E[e],E[t]);const s=T({basisFunction:o.basisFunction,basisFunctionDerivKsi:o.basisFunctionDerivKsi,basisFunctionDerivEta:o.basisFunctionDerivEta,nodesXCoordinates:a,nodesYCoordinates:l,localToGlobalMap:g,nodesPerElement:C}),{detJacobian:d,basisFunctionDerivX:c,basisFunctionDerivY:u}=s,m=o.basisFunction;let h=0,f=0;for(let e=0;e<C;e++)h+=n[g[e]]*c[e],f+=n[g[e]]*u[e];for(let n=0;n<C;n++){let o=g[n];p[o]+=r*v[e]*v[t]*d*c[n]*h+r*v[e]*v[t]*d*u[n]*f,0!==i&&(p[o]+=i*(v[e]*v[t]*d*m[n]*Math.sqrt(h**2+f**2)-v[e]*v[t]*d*m[n]));for(let s=0;s<C;s++){let a=g[s];b[o][a]+=-r*v[e]*v[t]*d*(c[n]*c[s]+u[n]*u[s]),0!==i&&(b[o][a]+=i*(-d*h*m[n]*v[e]*v[t]/Math.sqrt(h**2+f**2+1e-8))*c[s]-i*(d*f*m[n]*v[e]*v[t]/Math.sqrt(h**2+f**2+1e-8))*u[s])}}}}return new q(t,c,d,m,h).imposeDirichletBoundaryConditions(p,b),s("Front propagation matrix assembly completed"),{jacobianMatrix:b,residualVector:p}}function G({elementIndex:e,nop:t,meshData:n,basisFunctions:o,FEAData:s,solutionVector:i,eikonalActivationFlag:r}){const{gaussPoints:a,gaussWeights:l,nodesPerElement:d}=s,{nodesXCoordinates:c,nodesYCoordinates:u,meshDimension:m}=n;let h=1-r+.01;const f=Array(d).fill().map((()=>Array(d).fill(0))),p=Array(d).fill(0),b=Array(d),g=Array(d);for(let n=0;n<d;n++)b[n]=Math.abs(t[e][n]),g[n]=Math.abs(t[e][n])-1;for(let e=0;e<a.length;e++)if("1D"===m){errorLog("1D front propagation is not yet supported");let t=o.getBasisFunctions(a[e]);const n=k({basisFunction:t.basisFunction,basisFunctionDerivKsi:t.basisFunctionDerivKsi,nodesXCoordinates:c,localToGlobalMap:g,nodesPerElement:d}),{detJacobian:s,basisFunctionDerivX:r}=n;t.basisFunction;let l=0;for(let e=0;e<d;e++)l+=i[g[e]]*r[e];for(let e=0;e<d;e++){g[e];for(let e=0;e<d;e++)g[e]}}else if("2D"===m)for(let t=0;t<a.length;t++){const{basisFunction:n,basisFunctionDerivKsi:s,basisFunctionDerivEta:m}=o.getBasisFunctions(a[e],a[t]),{detJacobian:b,basisFunctionDerivX:y,basisFunctionDerivY:E}=T({basisFunction:n,basisFunctionDerivKsi:s,basisFunctionDerivEta:m,nodesXCoordinates:c,nodesYCoordinates:u,localToGlobalMap:g,nodesPerElement:d});let v=0,C=0;for(let e=0;e<d;e++)v+=i[g[e]]*y[e],C+=i[g[e]]*E[e];for(let o=0;o<d;o++){g[o],p[o]+=h*l[e]*l[t]*b*y[o]*v+h*l[e]*l[t]*b*E[o]*C,0!==r&&(p[o]+=r*(l[e]*l[t]*b*n[o]*Math.sqrt(v**2+C**2)-l[e]*l[t]*b*n[o]));for(let s=0;s<d;s++)f[o][s]-=h*l[e]*l[t]*b*(y[o]*y[s]+E[o]*E[s]),0!==r&&(f[o][s]+=r*(-b*v*n[o]*l[e]*l[t]/Math.sqrt(v**2+C**2+1e-8))*y[s]-r*(b*C*n[o]*l[e]*l[t]/Math.sqrt(v**2+C**2+1e-8))*E[s])}}return{localJacobianMatrix:f,localResidualVector:p,ngl:b}}const K={},J={},L={currentElementIndex:0},H={};let U;function _(e,t,n,r={}){const a=P(t),l=t.nodesXCoordinates.length,d=t.totalElements;!function(e,t){K.nodalNumbering=Array(t).fill().map((()=>Array(e).fill(0))),K.nodeConstraintCode=Array(e).fill(0),K.boundaryValues=Array(e).fill(0),K.globalResidualVector=Array(e).fill(0),K.solutionVector=Array(e).fill(0),K.topologyData=Array(t).fill(0),K.lateralData=Array(t).fill(0),J.writeFlag=0,J.totalNodes=e,J.transformationFlag=0,J.nodesPerElement=Array(t).fill(0),J.determinant=1;const n=Math.max(e,2e3);J.globalSolutionVector=Array(n).fill(0),J.frontDataIndex=0,L.localJacobianMatrix=Array(e).fill().map((()=>Array(e).fill(0))),L.currentElementIndex=0;const o=function(e,t){const n=Math.max(Math.ceil(Math.sqrt(t))*e,2*e);return n*t}(e,t);H.frontValues=Array(o).fill(0),H.columnHeaders=Array(n).fill(0),H.pivotRow=Array(n).fill(0),H.pivotData=Array(o).fill(0)}(a.nodesPerElement,d),s("Solving system using frontal..."),console.time("systemSolving"),U=new w({meshDimension:t.meshDimension,elementOrder:t.elementOrder});for(let e=0;e<t.totalElements;e++)for(let n=0;n<a.nodesPerElement;n++)K.nodalNumbering[e][n]=t.nop[e][n];for(let e=0;e<t.nodesXCoordinates.length;e++)K.nodeConstraintCode[e]=0,K.boundaryValues[e]=0;let c;e===W?(c=new Y(n,t.boundaryElements,t.nop,t.meshDimension,t.elementOrder),c.imposeConstantTempBoundaryConditionsFront(K.nodeConstraintCode,K.boundaryValues)):e===G&&(c=new q(n,t.boundaryElements,t.nop,t.meshDimension,t.elementOrder),c.imposeConstantValueBoundaryConditionsFront(K.nodeConstraintCode,K.boundaryValues));for(let e=0;e<t.nodesXCoordinates.length;e++)K.globalResidualVector[e]=0;J.totalNodes=t.nodesXCoordinates.length,J.writeFlag=0,J.transformationFlag=1,J.determinant=1;for(let e=0;e<t.totalElements;e++)J.nodesPerElement[e]=a.nodesPerElement;J.currentSolutionVector=r.solutionVector,J.eikonalActivationFlag=r.eikonalActivationFlag,function(e,t,n,s){const r=e.totalElements,a=e.nodesXCoordinates.length,l=Math.max(a,J.globalSolutionVector.length);let d,c=Array(t.nodesPerElement).fill(0),u=Array(t.nodesPerElement).fill(0),m=Array(l).fill(0),h=Array(l).fill(0),f=Array(l).fill(0),p=Array(l).fill(0),b=Array(l).fill(0),g=Array(l).fill().map((()=>Array(l).fill(0))),y=Array(a).fill(0),E=Array(a).fill(0),v=Array(a).fill(0),C=1;J.writeFlag++;let M=1,D=1;L.currentElementIndex=0;for(let e=0;e<J.totalNodes;e++)y[e]=0,E[e]=0;if(0!==J.transformationFlag){for(let e=0;e<J.totalNodes;e++)v[e]=0;for(let e=0;e<r;e++){let t=r-e-1;for(let e=0;e<J.nodesPerElement[t];e++){let n=K.nodalNumbering[t][e];0===v[n-1]&&(v[n-1]=1,K.nodalNumbering[t][e]=-K.nodalNumbering[t][e])}}}J.transformationFlag=0;let $=0,F=0;for(let e=0;e<l;e++)for(let t=0;t<l;t++)g[t][e]=0;for(;;){let a=!1,v=0,A=0;if(L.currentElementIndex<r&&(L.currentElementIndex++,a=z(e,t,n,s)),a){const e=L.currentElementIndex;v=J.nodesPerElement[e-1],A=J.nodesPerElement[e-1];for(let t=0;t<A;t++){let n,o,s=K.nodalNumbering[e-1][t];if(0===$)$++,c[t]=$,H.columnHeaders[$-1]=s;else{for(n=0;n<$&&Math.abs(s)!==Math.abs(H.columnHeaders[n]);n++);n===$?($++,c[t]=$,H.columnHeaders[$-1]=s):(c[t]=n+1,H.columnHeaders[n]=s)}if(0===F)F++,u[t]=F,m[F-1]=s;else{for(o=0;o<F&&Math.abs(s)!==Math.abs(m[o]);o++);o===F?(F++,u[t]=F,m[F-1]=s):(u[t]=o+1,m[o]=s)}}if(F>l||$>l)return void i("Error: systemSize not large enough");for(let e=0;e<A;e++){let t=c[e];for(let n=0;n<v;n++){g[u[n]-1][t-1]+=L.localJacobianMatrix[n][e]}}}let x=0;for(let e=0;e<$;e++)H.columnHeaders[e]<0&&(f[x]=e+1,x++);let w=0,S=0;for(let e=0;e<F;e++){let t=m[e];if(t<0){h[S]=e+1,S++;let n=Math.abs(t);1===K.nodeConstraintCode[n-1]&&(p[w]=e+1,w++,K.nodeConstraintCode[n-1]=2,K.globalResidualVector[n-1]=K.boundaryValues[n-1])}}if(w>0)for(let e=0;e<w;e++){let t=p[e]-1,n=Math.abs(m[t]);for(let e=0;e<$;e++){g[t][e]=0,Math.abs(H.columnHeaders[e])===n&&(g[t][e]=1)}}if(x>D||L.currentElementIndex<r){if(0===x)return void i("Error: no more rows fully summed");let e=h[0],t=f[0],n=g[e-1][t-1];if(Math.abs(n)<1e-4){n=0;for(let o=0;o<x;o++){let s=f[o];for(let o=0;o<S;o++){let i=h[o],r=g[i-1][s-1];Math.abs(r)>Math.abs(n)&&(n=r,t=s,e=i)}}}let s=Math.abs(m[e-1]);d=Math.abs(H.columnHeaders[t-1]);let a=s+d+y[s-1]+E[d-1];J.determinant=J.determinant*n*(-1)**a/Math.abs(n);for(let e=0;e<J.totalNodes;e++)e>=s&&y[e]--,e>=d&&E[e]--;if(Math.abs(n)<1e-10&&i(`Matrix singular or ill-conditioned, currentElementIndex=${L.currentElementIndex}, pivotGlobalRowIndex=${s}, pivotColumnGlobalIndex=${d}, pivotValue=${n}`),0===n)return;for(let t=0;t<$;t++)H.pivotRow[t]=g[e-1][t]/n;let l=K.globalResidualVector[s-1]/n;if(K.globalResidualVector[s-1]=l,b[e-1]=n,e>1)for(let n=0;n<e-1;n++){let e=Math.abs(m[n]),o=g[n][t-1];if(b[n]=o,t>1&&0!==o)for(let e=0;e<t-1;e++)g[n][e]-=o*H.pivotRow[e];if(t<$)for(let e=t;e<$;e++)g[n][e-1]=g[n][e]-o*H.pivotRow[e];K.globalResidualVector[e-1]-=o*l}if(e<F)for(let n=e;n<F;n++){let e=Math.abs(m[n]),o=g[n][t-1];if(b[n]=o,t>1)for(let e=0;e<t-1;e++)g[n-1][e]=g[n][e]-o*H.pivotRow[e];if(t<$)for(let e=t;e<$;e++)g[n-1][e-1]=g[n][e]-o*H.pivotRow[e];K.globalResidualVector[e-1]-=o*l}for(let e=0;e<F;e++)H.pivotData[M+e-1]=b[e];M+=F;for(let e=0;e<F;e++)H.pivotData[M+e-1]=m[e];M+=F,H.pivotData[M-1]=e,M++;for(let e=0;e<$;e++)H.frontValues[C-1+e]=H.pivotRow[e];C+=$;for(let e=0;e<$;e++)H.frontValues[C-1+e]=H.columnHeaders[e];C+=$,H.frontValues[C-1]=s,H.frontValues[C]=$,H.frontValues[C+1]=t,H.frontValues[C+2]=n,C+=4;for(let e=0;e<F;e++)g[e][$-1]=0;for(let e=0;e<$;e++)g[F-1][e]=0;if($--,t<$+1)for(let e=t-1;e<$;e++)H.columnHeaders[e]=H.columnHeaders[e+1];if(F--,e<F+1)for(let t=e-1;t<F;t++)m[t]=m[t+1];if(F>1||L.currentElementIndex<r)continue;if(d=Math.abs(H.columnHeaders[0]),e=1,n=g[0][0],s=Math.abs(m[0]),t=1,a=s+d+y[s-1]+E[d-1],J.determinant=J.determinant*n*(-1)**a/Math.abs(n),H.pivotRow[0]=1,Math.abs(n)<1e-10&&i(`Matrix singular or ill-conditioned, currentElementIndex=${L.currentElementIndex}, pivotGlobalRowIndex=${s}, pivotColumnGlobalIndex=${d}, pivotValue=${n}`),0===n)return;K.globalResidualVector[s-1]=K.globalResidualVector[s-1]/n,H.frontValues[C-1]=H.pivotRow[0],C++,H.frontValues[C-1]=H.columnHeaders[0],C++,H.frontValues[C-1]=s,H.frontValues[C]=$,H.frontValues[C+1]=t,H.frontValues[C+2]=n,C+=4,H.pivotData[M-1]=b[0],M++,H.pivotData[M-1]=m[0],M++,H.pivotData[M-1]=e,M++,J.frontDataIndex=C,1===J.writeFlag&&o(`total ecs transfer in matrix reduction=${C}`),Q(C);break}}}(t,a,c,e);for(let e=0;e<t.nodesXCoordinates.length;e++)K.solutionVector[e]=J.globalSolutionVector[e];const{nodesXCoordinates:u,nodesYCoordinates:m}=t;for(let e=0;e<t.nodesXCoordinates.length;e++)"1D"===t.meshDimension?o(`${u[e].toExponential(5)}  ${K.solutionVector[e].toExponential(5)}`):o(`${u[e].toExponential(5)}  ${m[e].toExponential(5)}  ${K.solutionVector[e].toExponential(5)}`);console.timeEnd("systemSolving"),s("System solved successfully");const{nodesXCoordinates:h,nodesYCoordinates:f}=t;return{solutionVector:K.solutionVector.slice(0,l),nodesCoordinates:{nodesXCoordinates:h,nodesYCoordinates:f}}}function z(e,t,n,o){const s=L.currentElementIndex-1;if(s<0||s>=e.totalElements)return i(`Skipping out-of-range elementIndex=${s} (totalElements=${e.totalElements})`),!1;const{localJacobianMatrix:r,localResidualVector:a,ngl:l}=o({elementIndex:s,nop:K.nodalNumbering,meshData:e,basisFunctions:U,FEAData:t,solutionVector:J.currentSolutionVector,eikonalActivationFlag:J.eikonalActivationFlag});let d=Array(t.nodesPerElement).fill().map((()=>Array(t.nodesPerElement).fill(0))),c=Array(t.nodesPerElement).fill(0);if(o===W){let o=!1;for(const t in e.boundaryElements)if("convection"===n.boundaryConditions[t]?.[0]&&e.boundaryElements[t].some((([e,t])=>e===s))){o=!0;break}if(o){const{gaussPoints:o,gaussWeights:i}=t,r=n.imposeConvectionBoundaryConditionsFront(s,e.nodesXCoordinates,e.nodesYCoordinates,o,i,U);d=r.localJacobianMatrix,c=r.localResidualVector}}for(let e=0;e<t.nodesPerElement;e++)for(let n=0;n<t.nodesPerElement;n++)L.localJacobianMatrix[e][n]=r[e][n]+d[e][n];for(let e=0;e<t.nodesPerElement;e++){const t=l[e]-1;K.globalResidualVector[t]+=a[e]+c[e]}return!0}function Q(e){for(let e=0;e<J.totalNodes;e++)J.globalSolutionVector[e]=K.boundaryValues[e];for(let t=1;t<=J.totalNodes;t++){e-=4;let n=H.frontValues[e-1],o=H.frontValues[e],s=H.frontValues[e+1];if(H.frontValues[e+2],1===t)e--,H.columnHeaders[0]=H.frontValues[e-1],e--,H.pivotRow[0]=H.frontValues[e-1];else{e-=o;for(let t=0;t<o;t++)H.columnHeaders[t]=H.frontValues[e-1+t];e-=o;for(let t=0;t<o;t++)H.pivotRow[t]=H.frontValues[e-1+t]}let i=Math.abs(H.columnHeaders[s-1]);if(K.nodeConstraintCode[i-1]>0)continue;let r=0;H.pivotRow[s-1]=0;for(let e=0;e<o;e++)r-=H.pivotRow[e]*J.globalSolutionVector[Math.abs(H.columnHeaders[e])-1];J.globalSolutionVector[i-1]=r+K.globalResidualVector[n-1],K.nodeConstraintCode[i-1]=1}1===J.writeFlag&&o(`value of frontDataCounter after backsubstitution=${e}`)}function Z(e,n={}){let o=0,r=!1,a=0,l=[],d=[],c=[],u=[];const{maxIterations:m=100,tolerance:h=1e-4}=n;let f=n.meshData.nodesXCoordinates.length;for(let e=0;e<f;e++)l[e]=0,d[e]=0;for(n.initialSolution&&n.initialSolution.length===f&&(d=[...n.initialSolution]);a<m&&!r;){for(let e=0;e<d.length;e++)d[e]=Number(d[e])+Number(l[e]);if("frontal"===n.solverMethod){l=_(G,n.meshData,n.boundaryConditions,{solutionVector:d,eikonalActivationFlag:n.eikonalActivationFlag}).solutionVector}else{({jacobianMatrix:c,residualVector:u}=e(n.meshData,n.boundaryConditions,d,n.eikonalActivationFlag));l=A(n.solverMethod,c,u).solutionVector}if(o=t(l),s(`Newton-Raphson iteration ${a+1}: Error norm = ${o.toExponential(4)}`),o<=h)r=!0;else if(o>100){i(`Solution not converged. Error norm: ${o}`);break}a++}return{solutionVector:d,converged:r,iterations:a,jacobianMatrix:c,residualVector:u}}function ee(e,t,n,o,s,i,r){const{nodesXCoordinates:a,nodesYCoordinates:l}=n.nodesCoordinates,d=t.nop[o].length;if(4===d){const d=R(s,i,[[a[t.nop[o][0]-1],l[t.nop[o][0]-1]],[a[t.nop[o][1]-1],l[t.nop[o][1]-1]],[a[t.nop[o][2]-1],l[t.nop[o][2]-1]],[a[t.nop[o][3]-1],l[t.nop[o][3]-1]]]);if(d.inside)return{inside:!0,value:te(e,t,n,o,d.ksi,d.eta,r)}}else if(9===d){const d=R(s,i,[[a[t.nop[o][0]-1],l[t.nop[o][0]-1]],[a[t.nop[o][2]-1],l[t.nop[o][2]-1]],[a[t.nop[o][6]-1],l[t.nop[o][6]-1]],[a[t.nop[o][8]-1],l[t.nop[o][8]-1]]]);if(d.inside)return{inside:!0,value:te(e,t,n,o,d.ksi,d.eta,r)}}return{inside:!1,value:null}}function te(e,t,n,o,s,i,r){const a=n.solutionVector,l=t.nop[o].length;let d,c=r.getBasisFunctions(s,i).basisFunction;d=Array.isArray(a[0])?a.map((e=>e[0])):a;let u=0;for(let e=0;e<l;e++)u+=d[t.nop[o][e]-1]*c[e];return u}function ne(e,t,n){let o=!1;for(let s=0;s<n.length;s++){const[[i,r],[a,l]]=n[s];r>t!=l>t&&e<(a-i)*(t-r)/(l-r)+i&&(o=!o)}return o}e.FEAScriptModel=class{constructor(){var e;this.solverConfig=null,this.meshConfig={},this.boundaryConditions={},this.solverMethod="lusolve",this.coefficientFunctions=null,e="FEAScript is provided “as is” without any warranty. The authors are not responsible for any damages or losses that may result from using the software. See the license for more details: https://github.com/FEAScript/FEAScript-core/blob/main/LICENSE",console.log("%c[WARN] "+e,"color: #FF9800; font-weight: bold;"),s("FEAScriptModel instance created")}setSolverConfig(e,t={}){this.solverConfig=e,t?.coefficientFunctions&&(this.coefficientFunctions=t.coefficientFunctions,o("Coefficient functions set")),void 0!==t?.maxIterations&&(this.maxIterations=t.maxIterations),void 0!==t?.tolerance&&(this.tolerance=t.tolerance),o(`Solver config set to: ${e}`)}setMeshConfig(e){this.meshConfig=e,o(`Mesh config set with dimensions: ${e.meshDimension}`)}addBoundaryCondition(e,t){this.boundaryConditions[e]=t,o(`Boundary condition added for boundary: ${e}, type: ${t[0]}`)}setSolverMethod(e){this.solverMethod=e,o(`Solver method set to: ${e}`)}solve(e={}){this.solverConfig&&this.meshConfig&&this.boundaryConditions||i("Solver config, mesh config, and boundary conditions must be set before solving.");let t=[],n=[],o=[],r=[];s("Preparing mesh...");const a=V(this.meshConfig);s("Mesh preparation completed");const l={nodesXCoordinates:a.nodesXCoordinates,nodesYCoordinates:a.nodesYCoordinates};if(s("Beginning solving process..."),console.time("totalSolvingTime"),s(`Using solver: ${this.solverConfig}`),"heatConductionScript"===this.solverConfig)if("frontal"===this.solverMethod){o=_(W,a,this.boundaryConditions).solutionVector}else{({jacobianMatrix:t,residualVector:n}=B(a,this.boundaryConditions));o=A(this.solverMethod,t,n,{maxIterations:e.maxIterations??this.maxIterations,tolerance:e.tolerance??this.tolerance}).solutionVector}else if("frontPropagationScript"===this.solverConfig){let s=0;const i=5,l={meshData:a,boundaryConditions:this.boundaryConditions,eikonalActivationFlag:s,solverMethod:this.solverMethod,initialSolution:r,maxIterations:e.maxIterations??this.maxIterations,tolerance:e.tolerance??this.tolerance};for(;s<=1;){l.eikonalActivationFlag=s,o.length>0&&(l.initialSolution=[...o]);const e=Z(j,l);t=e.jacobianMatrix,n=e.residualVector,o=e.solutionVector,s+=1/i}}else if("generalFormPDEScript"===this.solverConfig)if("frontal"===this.solverMethod)i("Frontal solver is not yet supported for generalFormPDEScript. Please use 'lusolve' or 'jacobi'.");else{({jacobianMatrix:t,residualVector:n}=function(e,t,n){s("Starting general form PDE matrix assembly...");const{nodesXCoordinates:o,nodesYCoordinates:r,nop:a,boundaryElements:l,totalElements:d,meshDimension:c,elementOrder:u}=e,{A:m,B:h,C:f,D:p}=n,b=P(e),{residualVector:g,jacobianMatrix:y,localToGlobalMap:E,basisFunctions:v,gaussPoints:C,gaussWeights:M,nodesPerElement:D}=b;if("1D"===c)for(let e=0;e<d;e++){for(let t=0;t<D;t++)E[t]=Math.abs(a[e][t])-1;for(let e=0;e<C.length;e++){const{basisFunction:t,basisFunctionDerivKsi:n}=v.getBasisFunctions(C[e]),{detJacobian:s,basisFunctionDerivX:i}=k({basisFunction:t,basisFunctionDerivKsi:n,nodesXCoordinates:o,localToGlobalMap:E,nodesPerElement:D});let r=0;for(let e=0;e<D;e++)r+=o[E[e]]*t[e];const a=m(r),l=h(r),d=f(r),c=p(r);for(let n=0;n<D;n++){const o=E[n];g[o]-=M[e]*s*c*t[n];for(let r=0;r<D;r++){const c=E[r];y[o][c]+=M[e]*s*a*i[n]*i[r],y[o][c]-=M[e]*s*l*i[r]*t[n],y[o][c]-=M[e]*s*d*t[n]*t[r]}}}}else"2D"===c&&i("2D general form PDE is not yet supported in assembleGeneralFormPDEMat.");return new q(t,l,a,c,u).imposeDirichletBoundaryConditions(g,y),s("General form PDE matrix assembly completed"),{jacobianMatrix:y,residualVector:g}}(a,this.boundaryConditions,this.coefficientFunctions));o=A(this.solverMethod,t,n,{maxIterations:e.maxIterations??this.maxIterations,tolerance:e.tolerance??this.tolerance}).solutionVector}return console.timeEnd("totalSolvingTime"),s("Solving process completed"),{solutionVector:o,nodesCoordinates:l}}async solveAsync(e,t={}){this.solverConfig&&this.meshConfig&&this.boundaryConditions||i("Solver config, mesh config, and boundary conditions must be set before solving.");let n=[],o=[],r=[];s("Preparing mesh...");const a=V(this.meshConfig);s("Mesh preparation completed");const l={nodesXCoordinates:a.nodesXCoordinates,nodesYCoordinates:a.nodesYCoordinates};if(s("Beginning solving process..."),console.time("totalSolvingTime"),s(`Using solver: ${this.solverConfig}`),"heatConductionScript"===this.solverConfig&&(({jacobianMatrix:n,residualVector:o}=B(a,this.boundaryConditions)),"jacobi-gpu"===this.solverMethod)){const{solutionVector:s}=await x("jacobi-gpu",n,o,{computeEngine:e,maxIterations:t.maxIterations??this.maxIterations,tolerance:t.tolerance??this.tolerance});r=s}return console.timeEnd("totalSolvingTime"),s("Solving process completed"),{solutionVector:r,nodesCoordinates:l}}},e.FEAScriptWorker=class{constructor(){this.worker=null,this.feaWorker=null,this.isReady=!1,this._initWorker()}async _initWorker(){try{this.worker=new Worker(new URL("./wrapperScript.js","undefined"==typeof document&&"undefined"==typeof location?new(require("url").URL)("file:"+__filename).href:"undefined"==typeof document?location.href:document.currentScript&&"SCRIPT"===document.currentScript.tagName.toUpperCase()&&document.currentScript.src||new URL("feascript.umd.js",document.baseURI).href),{type:"module"}),this.worker.onerror=e=>{console.error("FEAScriptWorker: Worker error:",e)};const e=p(this.worker);this.feaWorker=await new e,this.isReady=!0}catch(e){throw console.error("Failed to initialize worker",e),e}}async _ensureReady(){return this.isReady?Promise.resolve():new Promise(((e,t)=>{let n=0;const o=()=>{n++,this.isReady?e():n>=50?t(new Error("Timeout waiting for worker to be ready")):setTimeout(o,1e3)};o()}))}async setSolverConfig(e){return await this._ensureReady(),s(`FEAScriptWorker: Setting solver config to: ${e}`),this.feaWorker.setSolverConfig(e)}async setMeshConfig(e){return await this._ensureReady(),s("FEAScriptWorker: Setting mesh config"),this.feaWorker.setMeshConfig(e)}async addBoundaryCondition(e,t){return await this._ensureReady(),s(`FEAScriptWorker: Adding boundary condition for boundary: ${e}`),this.feaWorker.addBoundaryCondition(e,t)}async setSolverMethod(e){return await this._ensureReady(),s(`FEAScriptWorker: Setting solver method to: ${e}`),this.feaWorker.setSolverMethod(e)}async solve(){await this._ensureReady(),s("FEAScriptWorker: Requesting solution from worker...");const e=performance.now(),t=await this.feaWorker.solve();return s(`FEAScriptWorker: Solution completed in ${((performance.now()-e)/1e3).toFixed(2)}s`),t}async getModelInfo(){return await this._ensureReady(),this.feaWorker.getModelInfo()}async ping(){return await this._ensureReady(),this.feaWorker.ping()}terminate(){this.worker&&(this.worker.terminate(),this.worker=null,this.feaWorker=null,this.isReady=!1)}},e.importGmshQuadTri=async e=>{let t={nodesXCoordinates:[],nodesYCoordinates:[],nodalNumbering:{quadElements:[],triangleElements:[]},boundaryElements:[],boundaryConditions:[],boundaryNodePairs:{},gmshV:0,ascii:!1,fltBytes:"8",totalNodesX:0,totalNodesY:0,physicalPropMap:[],elementTypes:{}},n=(await e.text()).split("\n").map((e=>e.trim())).filter((e=>""!==e&&" "!==e)),s="",i=0,r=0,a=0,l=0,d={numNodes:0},c=0,u=[],m=0,h=0,f=0,p={dim:0,tag:0,elementType:0,numElements:0},b=0,g={};for(;i<n.length;){const e=n[i];if("$MeshFormat"===e){s="meshFormat",i++;continue}if("$EndMeshFormat"===e){s="",i++;continue}if("$PhysicalNames"===e){s="physicalNames",i++;continue}if("$EndPhysicalNames"===e){s="",i++;continue}if("$Entities"===e){s="entities",i++;continue}if("$EndEntities"===e){s="",i++;continue}if("$Nodes"===e){s="nodes",i++;continue}if("$EndNodes"===e){s="",i++;continue}if("$Elements"===e){s="elements",i++;continue}if("$EndElements"===e){s="",i++;continue}const o=e.split(/\s+/).filter((e=>""!==e));if("meshFormat"===s)t.gmshV=parseFloat(o[0]),t.ascii="0"===o[1],t.fltBytes=o[2];else if("physicalNames"===s){if(o.length>=3){if(!/^\d+$/.test(o[0])){i++;continue}const e=parseInt(o[0],10),n=parseInt(o[1],10);let s=o.slice(2).join(" ");s=s.replace(/^"|"$/g,""),t.physicalPropMap.push({tag:n,dimension:e,name:s})}}else if("nodes"===s){if(0===r){r=parseInt(o[0],10),a=parseInt(o[1],10),t.nodesXCoordinates=new Array(a).fill(0),t.nodesYCoordinates=new Array(a).fill(0),i++;continue}if(l<r&&0===d.numNodes){d={dim:parseInt(o[0],10),tag:parseInt(o[1],10),parametric:parseInt(o[2],10),numNodes:parseInt(o[3],10)},u=[],c=0,m=0,i++;continue}if(c<d.numNodes){for(let e=0;e<o.length&&c<d.numNodes;e++)u.push(parseInt(o[e],10)),c++;if(c<d.numNodes){i++;continue}i++;continue}if(m<d.numNodes){const e=u[m]-1,n=parseFloat(o[0]),s=parseFloat(o[1]);t.nodesXCoordinates[e]=n,t.nodesYCoordinates[e]=s,t.totalNodesX++,t.totalNodesY++,m++,m===d.numNodes&&(l++,d={numNodes:0})}}else if("elements"===s){if(0===h){h=parseInt(o[0],10),parseInt(o[1],10),i++;continue}if(f<h&&0===p.numElements){p={dim:parseInt(o[0],10),tag:parseInt(o[1],10),elementType:parseInt(o[2],10),numElements:parseInt(o[3],10)},t.elementTypes[p.elementType]=(t.elementTypes[p.elementType]||0)+p.numElements,b=0,i++;continue}if(b<p.numElements){parseInt(o[0],10);const e=o.slice(1).map((e=>parseInt(e,10)));if(1===p.elementType||8===p.elementType){const n=p.tag;g[n]||(g[n]=[]),g[n].push(e),t.boundaryNodePairs[n]||(t.boundaryNodePairs[n]=[]),t.boundaryNodePairs[n].push(e)}else 2===p.elementType?t.nodalNumbering.triangleElements.push(e):(3===p.elementType||10===p.elementType)&&t.nodalNumbering.quadElements.push(e);b++,b===p.numElements&&(f++,p={numElements:0})}}i++}return t.physicalPropMap.forEach((e=>{if(1===e.dimension){const n=g[e.tag]||[];n.length>0&&t.boundaryConditions.push({name:e.name,tag:e.tag,nodes:n})}})),o(`Parsed boundary node pairs by physical tag: ${JSON.stringify(t.boundaryNodePairs)}. These pairs will be used to identify boundary elements in the mesh.`),t},e.logSystem=function(e){"basic"!==e&&"debug"!==e?(console.log("%c[WARN] Invalid log level: "+e+". Using basic instead.","color: #FFC107; font-weight: bold;"),n="basic"):(n=e,s(`Log level set to: ${e}`))},e.plotInterpolatedSolution=function(e,t,n,o){console.time("plottingTime");const{nodesXCoordinates:s,nodesYCoordinates:i}=t.nodesCoordinates,r=e.meshConfig.meshDimension,a=V(e.meshConfig),l=new w({meshDimension:e.meshConfig.meshDimension,elementOrder:e.meshConfig.elementOrder});if("1D"===r&&"line"===n);else if("2D"===r&&"contour"===n){const r=[],d=[],c=Math.max(...s)-Math.min(...s),u=Math.max(...i)-Math.min(...i),m=50,h=Math.round(c*m),f=Math.round(u*m),p=c/(h-1),b=u/(f-1);let g=[];r[0]=Math.min(...s),d[0]=Math.min(...i);for(let e=1;e<f;e++)r[e]=r[0],d[e]=d[0]+e*b;for(let e=1;e<h;e++){const t=e*f;r[t]=r[0]+e*p,d[t]=d[0];for(let e=1;e<f;e++)r[t+e]=r[t],d[t+e]=d[t]+e*b}g=new Array(h*f).fill(null);const y=function(e){let t,n=[],o=[],s=0;const{nodesXCoordinates:i,nodesYCoordinates:r,nop:a,boundaryElements:l,meshDimension:d,elementOrder:c}=e;"1D"===d?("linear"===c||"quadratic"===c)&&(t={0:[0],1:[1]}):"2D"===d&&("linear"===c?t={0:[0,2],1:[0,1],2:[1,3],3:[2,3]}:"quadratic"===c&&(t={0:[0,3,6],1:[0,1,2],2:[2,5,8],3:[6,7,8]}));for(let e=0;e<l.length;e++)for(let d=0;d<l[e].length;d++){n[s]=l[e][d],s++;const[c,u]=l[e][d];let m=t[u],h=[],f=[];for(let e=0;e<m.length;e++){const t=a[c][m[e]]-1;h.push(i[t]),f.push(r[t])}for(let e=0;e<h.length-1;e++)o.push([[h[e],f[e]],[h[e+1],f[e+1]]])}return o}(a),{nodeNeighbors:E,neighborCount:v}=function(e){const{nop:t,nodesXCoordinates:n}=e,o=n.length,s=t[0].length,i=Array.from({length:o},(()=>[])),r=Array(o).fill(0);for(let e=0;e<t.length;e++)for(let n=0;n<s;n++){const o=t[e][n]-1;r[o]=r[o]+1,i[o].push(e)}return{nodeNeighbors:i,neighborCount:r}}(a);let C=0;for(let n=0;n<h*f;n++){if(!ne(r[n],d[n],y))continue;let o=!1;for(let s=0;s<a.nop[C].length;s++){let i=a.nop[C][s]-1;for(let s=0;s<v[i];s++){let c=E[i][s];const u=ee(e,a,t,c,r[n],d[n],l);if(u.inside){C=c,g[n]=u.value,o=!0;break}}if(o)break}if(!o)for(let s=0;s<a.nop.length;s++){const i=ee(e,a,t,s,r[n],d[n],l);if(i.inside){C=s,g[n]=i.value,o=!0;break}}}let M=Math.min(window.innerWidth,700),D=Math.max(...s),$=Math.max(...i)/D,F=Math.min(M,600),A=F*$,x={title:`${n} plot (interpolated) - ${e.solverConfig}`,width:F,height:A,xaxis:{title:"x"},yaxis:{title:"y"},margin:{l:50,r:50,t:50,b:50},hovermode:"closest"},w={x:r,y:d,z:g,type:"contour",connectgaps:!1,hoverongaps:!1,line:{smoothing:.85},contours:{coloring:"heatmap",showlabels:!1},colorbar:{title:"Solution"},name:"Interpolated Solution Field"};Plotly.newPlot(o,[w],x,{responsive:!0}),console.timeEnd("plottingTime")}},e.plotSolution=function(e,t,n,o){console.time("plottingTime");const{nodesXCoordinates:s,nodesYCoordinates:i}=t.nodesCoordinates,r=t.solutionVector,a=e.solverConfig,l=e.meshConfig.meshDimension;if(V(e.meshConfig),"1D"===l&&"line"===n){let e;e=r.length>0&&Array.isArray(r[0])?r.map((e=>e[0])):r,Array.from(s);let t={x:s,y:e,mode:"lines",type:"scatter",line:{color:"rgb(219, 64, 82)",width:2},name:"Solution"},n=Math.min(window.innerWidth,700),i={title:`line plot - ${a}`,width:Math.min(n,600),height:300,xaxis:{title:"x"},yaxis:{title:"Solution"},margin:{l:50,r:50,t:50,b:50}};Plotly.newPlot(o,[t],i,{responsive:!0}),console.timeEnd("plottingTime")}else if("2D"===l&&"contour"===n){let e;e=Array.isArray(r[0])?r.map((e=>e[0])):r;let t=Math.min(window.innerWidth,700),l=Math.max(...s),d=Math.max(...i)/l,c=Math.min(t,600),u={title:`${n} plot - ${a}`,width:c,height:c*d,xaxis:{title:"x"},yaxis:{title:"y"},margin:{l:50,r:50,t:50,b:50},hovermode:"closest"},m={x:s,y:i,z:e,type:"contour",line:{smoothing:.85},contours:{coloring:"heatmap",showlabels:!1},colorbar:{title:"Solution"},name:"Solution Field"};Plotly.newPlot(o,[m],u,{responsive:!0}),console.timeEnd("plottingTime")}},e.printVersion="0.2.0 (RC)",Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=feascript.umd.js.map
