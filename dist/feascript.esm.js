import"https://cdn.jsdelivr.net/npm/taichi.js@latest/dist/taichi.esm.js";
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const e=Symbol("Comlink.proxy"),t=Symbol("Comlink.endpoint"),n=Symbol("Comlink.releaseProxy"),s=Symbol("Comlink.finalizer"),o=Symbol("Comlink.thrown"),i=e=>"object"==typeof e&&null!==e||"function"==typeof e,r=new Map([["proxy",{canHandle:t=>i(t)&&t[e],serialize(e){const{port1:t,port2:n}=new MessageChannel;return a(e,t),[n,[n]]},deserialize:e=>(e.start(),d(e))}],["throw",{canHandle:e=>i(e)&&o in e,serialize({value:e}){let t;return t=e instanceof Error?{isError:!0,value:{message:e.message,name:e.name,stack:e.stack}}:{isError:!1,value:e},[t,[]]},deserialize(e){if(e.isError)throw Object.assign(new Error(e.value.message),e.value);throw e.value}}]]);function a(t,n=globalThis,i=["*"]){n.addEventListener("message",(function r(d){if(!d||!d.data)return;if(!function(e,t){for(const n of e){if(t===n||"*"===n)return!0;if(n instanceof RegExp&&n.test(t))return!0}return!1}(i,d.origin))return void console.warn(`Invalid origin '${d.origin}' for comlink proxy`);const{id:h,type:m,path:u}=Object.assign({path:[]},d.data),c=(d.data.argumentList||[]).map(b);let f;try{const n=u.slice(0,-1).reduce(((e,t)=>e[t]),t),s=u.reduce(((e,t)=>e[t]),t);switch(m){case"GET":f=s;break;case"SET":n[u.slice(-1)[0]]=b(d.data.value),f=!0;break;case"APPLY":f=s.apply(n,c);break;case"CONSTRUCT":f=function(t){return Object.assign(t,{[e]:!0})}(new s(...c));break;case"ENDPOINT":{const{port1:e,port2:n}=new MessageChannel;a(t,n),f=function(e,t){return y.set(e,t),e}(e,[e])}break;case"RELEASE":f=void 0;break;default:return}}catch(e){f={value:e,[o]:0}}Promise.resolve(f).catch((e=>({value:e,[o]:0}))).then((e=>{const[o,i]=g(e);n.postMessage(Object.assign(Object.assign({},o),{id:h}),i),"RELEASE"===m&&(n.removeEventListener("message",r),l(n),s in t&&"function"==typeof t[s]&&t[s]())})).catch((e=>{const[t,s]=g({value:new TypeError("Unserializable return value"),[o]:0});n.postMessage(Object.assign(Object.assign({},t),{id:h}),s)}))})),n.start&&n.start()}function l(e){(function(e){return"MessagePort"===e.constructor.name})(e)&&e.close()}function d(e,t){const n=new Map;return e.addEventListener("message",(function(e){const{data:t}=e;if(!t||!t.id)return;const s=n.get(t.id);if(s)try{s(t)}finally{n.delete(t.id)}})),f(e,n,[],t)}function h(e){if(e)throw new Error("Proxy has been released and is not useable")}function m(e){return E(e,new Map,{type:"RELEASE"}).then((()=>{l(e)}))}const u=new WeakMap,c="FinalizationRegistry"in globalThis&&new FinalizationRegistry((e=>{const t=(u.get(e)||0)-1;u.set(e,t),0===t&&m(e)}));function f(e,s,o=[],i=function(){}){let r=!1;const a=new Proxy(i,{get(t,i){if(h(r),i===n)return()=>{!function(e){c&&c.unregister(e)}(a),m(e),s.clear(),r=!0};if("then"===i){if(0===o.length)return{then:()=>a};const t=E(e,s,{type:"GET",path:o.map((e=>e.toString()))}).then(b);return t.then.bind(t)}return f(e,s,[...o,i])},set(t,n,i){h(r);const[a,l]=g(i);return E(e,s,{type:"SET",path:[...o,n].map((e=>e.toString())),value:a},l).then(b)},apply(n,i,a){h(r);const l=o[o.length-1];if(l===t)return E(e,s,{type:"ENDPOINT"}).then(b);if("bind"===l)return f(e,s,o.slice(0,-1));const[d,m]=p(a);return E(e,s,{type:"APPLY",path:o.map((e=>e.toString())),argumentList:d},m).then(b)},construct(t,n){h(r);const[i,a]=p(n);return E(e,s,{type:"CONSTRUCT",path:o.map((e=>e.toString())),argumentList:i},a).then(b)}});return function(e,t){const n=(u.get(t)||0)+1;u.set(t,n),c&&c.register(e,t,e)}(a,e),a}function p(e){const t=e.map(g);return[t.map((e=>e[0])),(n=t.map((e=>e[1])),Array.prototype.concat.apply([],n))];var n}const y=new WeakMap;function g(e){for(const[t,n]of r)if(n.canHandle(e)){const[s,o]=n.serialize(e);return[{type:"HANDLER",name:t,value:s},o]}return[{type:"RAW",value:e},y.get(e)||[]]}function b(e){switch(e.type){case"HANDLER":return r.get(e.name).deserialize(e.value);case"RAW":return e.value}}function E(e,t,n,s){return new Promise((o=>{const i=new Array(4).fill(0).map((()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16))).join("-");t.set(i,o),e.start&&e.start(),e.postMessage(Object.assign({id:i},n),s)}))}class M{constructor({meshDimension:e,elementOrder:t}){this.meshDimension=e,this.elementOrder=t}getGaussPointsAndWeights(){let e=[],t=[];return"linear"===this.elementOrder?(e[0]=.5,t[0]=1):"quadratic"===this.elementOrder&&(e[0]=(1-Math.sqrt(.6))/2,e[1]=.5,e[2]=(1+Math.sqrt(.6))/2,t[0]=5/18,t[1]=8/18,t[2]=5/18),{gaussPoints:e,gaussWeights:t}}}let $="basic";function v(e){"basic"!==e&&"debug"!==e?(console.log("%c[WARN] Invalid log level: "+e+". Using basic instead.","color: #FFC107; font-weight: bold;"),$="basic"):($=e,C(`Log level set to: ${e}`))}function w(e){"debug"===$&&console.log("%c[DEBUG] "+e,"color: #2196F3; font-weight: bold;")}function C(e){console.log("%c[INFO] "+e,"color: #4CAF50; font-weight: bold;")}function N(e){console.log("%c[ERROR] "+e,"color: #F44336; font-weight: bold;")}async function S(){C("Fetching latest FEAScript version information...");try{const e=await fetch("https://api.github.com/repos/FEAScript/FEAScript/commits/main"),t=await e.json(),n=new Date(t.commit.committer.date).toLocaleString();return C(`Latest FEAScript update: ${n}`),n}catch(e){return N("Failed to fetch version information: "+e),"Version information unavailable"}}class D{constructor({meshDimension:e,elementOrder:t}){this.meshDimension=e,this.elementOrder=t}getBasisFunctions(e,t=null){let n=[],s=[],o=[];if("1D"===this.meshDimension)"linear"===this.elementOrder?(n[0]=1-e,n[1]=e,s[0]=-1,s[1]=1):"quadratic"===this.elementOrder&&(n[0]=1-3*e+2*e**2,n[1]=4*e-4*e**2,n[2]=2*e**2-e,s[0]=4*e-3,s[1]=4-8*e,s[2]=4*e-1);else if("2D"===this.meshDimension){if(null===t)return void N("Eta coordinate is required for 2D elements");if("linear"===this.elementOrder){function i(e){return 1-e}n[0]=i(e)*i(t),n[1]=i(e)*t,n[2]=e*i(t),n[3]=e*t,s[0]=-1*i(t),s[1]=-1*t,s[2]=1*i(t),s[3]=1*t,o[0]=-1*i(e),o[1]=1*i(e),o[2]=-1*e,o[3]=1*e}else if("quadratic"===this.elementOrder){function r(e){return 2*e**2-3*e+1}function a(e){return-4*e**2+4*e}function l(e){return 2*e**2-e}function d(e){return 4*e-3}function h(e){return-8*e+4}function m(e){return 4*e-1}n[0]=r(e)*r(t),n[1]=r(e)*a(t),n[2]=r(e)*l(t),n[3]=a(e)*r(t),n[4]=a(e)*a(t),n[5]=a(e)*l(t),n[6]=l(e)*r(t),n[7]=l(e)*a(t),n[8]=l(e)*l(t),s[0]=d(e)*r(t),s[1]=d(e)*a(t),s[2]=d(e)*l(t),s[3]=h(e)*r(t),s[4]=h(e)*a(t),s[5]=h(e)*l(t),s[6]=m(e)*r(t),s[7]=m(e)*a(t),s[8]=m(e)*l(t),o[0]=r(e)*d(t),o[1]=r(e)*h(t),o[2]=r(e)*m(t),o[3]=a(e)*d(t),o[4]=a(e)*h(t),o[5]=a(e)*m(t),o[6]=l(e)*d(t),o[7]=l(e)*h(t),o[8]=l(e)*m(t)}}return{basisFunction:n,basisFunctionDerivKsi:s,basisFunctionDerivEta:o}}}class O{constructor({numElementsX:e=null,maxX:t=null,numElementsY:n=null,maxY:s=null,meshDimension:o=null,elementOrder:i="linear",parsedMesh:r=null}){this.numElementsX=e,this.numElementsY=n,this.maxX=t,this.maxY=s,this.meshDimension=o,this.elementOrder=i,this.parsedMesh=r}generateMesh(){if(this.parsedMesh){if(this.parsedMesh.nodalNumbering&&"object"==typeof this.parsedMesh.nodalNumbering&&!Array.isArray(this.parsedMesh.nodalNumbering)){const e=this.parsedMesh.nodalNumbering.quadElements||[];if(this.parsedMesh.nodalNumbering.triangleElements,w("Initial parsed mesh nodal numbering from GMSH format: "+JSON.stringify(this.parsedMesh.nodalNumbering)),this.parsedMesh.elementTypes[3]||this.parsedMesh.elementTypes[10]){const t=[];for(let n=0;n<e.length;n++){const s=e[n],o=new Array(s.length);4===s.length?(o[0]=s[0],o[1]=s[3],o[2]=s[1],o[3]=s[2]):9===s.length&&(o[0]=s[0],o[1]=s[7],o[2]=s[3],o[3]=s[4],o[4]=s[8],o[5]=s[6],o[6]=s[1],o[7]=s[5],o[8]=s[2]),t.push(o)}this.parsedMesh.nodalNumbering=t}else this.parsedMesh.elementTypes[2];if(w("Nodal numbering after mapping from GMSH to FEAScript format: "+JSON.stringify(this.parsedMesh.nodalNumbering)),this.parsedMesh.physicalPropMap&&this.parsedMesh.boundaryElements){if(Array.isArray(this.parsedMesh.boundaryElements)&&this.parsedMesh.boundaryElements.length>0&&void 0===this.parsedMesh.boundaryElements[0]){const e=[];for(let t=1;t<this.parsedMesh.boundaryElements.length;t++)this.parsedMesh.boundaryElements[t]&&e.push(this.parsedMesh.boundaryElements[t]);this.parsedMesh.boundaryElements=e}if(this.parsedMesh.boundaryNodePairs&&!this.parsedMesh.boundaryElementsProcessed&&(this.parsedMesh.boundaryElements=[],this.parsedMesh.physicalPropMap.forEach((e=>{if(1===e.dimension){const t=this.parsedMesh.boundaryNodePairs[e.tag]||[];t.length>0&&(this.parsedMesh.boundaryElements[e.tag]||(this.parsedMesh.boundaryElements[e.tag]=[]),t.forEach((t=>{const n=t[0],s=t[1];w(`Processing boundary node pair: [${n}, ${s}] for boundary ${e.tag} (${e.name||"unnamed"})`);let o=!1;for(let t=0;t<this.parsedMesh.nodalNumbering.length;t++){const i=this.parsedMesh.nodalNumbering[t];if(4===i.length){if(i.includes(n)&&i.includes(s)){let r;const a=i.indexOf(n),l=i.indexOf(s);w(`  Found element ${t} containing boundary nodes. Element nodes: [${i.join(", ")}]`),w(`  Node ${n} is at index ${a}, Node ${s} is at index ${l} in the element`),0===a&&2===l||2===a&&0===l?(r=0,w(`  These nodes form the BOTTOM side (${r}) of element ${t}`)):0===a&&1===l||1===a&&0===l?(r=1,w(`  These nodes form the LEFT side (${r}) of element ${t}`)):1===a&&3===l||3===a&&1===l?(r=2,w(`  These nodes form the TOP side (${r}) of element ${t}`)):(2===a&&3===l||3===a&&2===l)&&(r=3,w(`  These nodes form the RIGHT side (${r}) of element ${t}`)),this.parsedMesh.boundaryElements[e.tag].push([t,r]),w(`  Added element-side pair [${t}, ${r}] to boundary tag ${e.tag}`),o=!0;break}}else if(9===i.length&&i.includes(n)&&i.includes(s)){let r;const a=i.indexOf(n),l=i.indexOf(s);w(`  Found element ${t} containing boundary nodes. Element nodes: [${i.join(", ")}]`),w(`  Node ${n} is at index ${a}, Node ${s} is at index ${l} in the element`),0===a&&6===l||6===a&&0===l||0===a&&3===l||3===a&&0===l||3===a&&6===l||6===a&&3===l?(r=0,w(`  These nodes form the BOTTOM side (${r}) of element ${t}`)):0===a&&2===l||2===a&&0===l||0===a&&1===l||1===a&&0===l||1===a&&2===l||2===a&&1===l?(r=1,w(`  These nodes form the LEFT side (${r}) of element ${t}`)):2===a&&8===l||8===a&&2===l||2===a&&5===l||5===a&&2===l||5===a&&8===l||8===a&&5===l?(r=2,w(`  These nodes form the TOP side (${r}) of element ${t}`)):(6===a&&8===l||8===a&&6===l||6===a&&7===l||7===a&&6===l||7===a&&8===l||8===a&&7===l)&&(r=3,w(`  These nodes form the RIGHT side (${r}) of element ${t}`)),this.parsedMesh.boundaryElements[e.tag].push([t,r]),w(`  Added element-side pair [${t}, ${r}] to boundary tag ${e.tag}`),o=!0;break}}o||N(`Could not find element containing boundary nodes ${n} and ${s}. Boundary may be incomplete.`)})))}})),this.parsedMesh.boundaryElementsProcessed=!0,this.parsedMesh.boundaryElements.length>0&&void 0===this.parsedMesh.boundaryElements[0])){const e=[];for(let t=1;t<this.parsedMesh.boundaryElements.length;t++)this.parsedMesh.boundaryElements[t]&&e.push(this.parsedMesh.boundaryElements[t]);this.parsedMesh.boundaryElements=e}}}return w("Processed boundary elements by tag: "+JSON.stringify(this.parsedMesh.boundaryElements)),this.parsedMesh}return"1D"===this.meshDimension?null!==this.numElementsX&&null!==this.maxX||N("numElementsX and maxX are required parameters when generating a 1D mesh from geometry"):"2D"===this.meshDimension&&(null!==this.numElementsX&&null!==this.maxX&&null!==this.numElementsY&&null!==this.maxY||N("numElementsX, maxX, numElementsY, and maxY are required parameters when generating a 2D mesh from geometry")),this.generateMeshFromGeometry()}generateMeshFromGeometry(){let e=[],t=[];let n,s,o,i;if("1D"===this.meshDimension){if("linear"===this.elementOrder){n=this.numElementsX+1,o=(this.maxX-0)/this.numElementsX,e[0]=0;for(let t=1;t<n;t++)e[t]=e[t-1]+o}else if("quadratic"===this.elementOrder){n=2*this.numElementsX+1,o=(this.maxX-0)/this.numElementsX,e[0]=0;for(let t=1;t<n;t++)e[t]=e[t-1]+o/2}const t=this.generateNodalNumbering(this.numElementsX,null,n,null,this.elementOrder),s=this.findBoundaryElements();return w("Generated node X coordinates: "+JSON.stringify(e)),{nodesXCoordinates:e,totalNodesX:n,nodalNumbering:t,boundaryElements:s}}if("2D"===this.meshDimension){if("linear"===this.elementOrder){n=this.numElementsX+1,s=this.numElementsY+1,o=(this.maxX-0)/this.numElementsX,i=(this.maxY-0)/this.numElementsY,e[0]=0,t[0]=0;for(let n=1;n<s;n++)e[n]=e[0],t[n]=t[0]+n*i;for(let r=1;r<n;r++){const n=r*s;e[n]=e[0]+r*o,t[n]=t[0];for(let o=1;o<s;o++)e[n+o]=e[n],t[n+o]=t[n]+o*i}}else if("quadratic"===this.elementOrder){n=2*this.numElementsX+1,s=2*this.numElementsY+1,o=(this.maxX-0)/this.numElementsX,i=(this.maxY-0)/this.numElementsY,e[0]=0,t[0]=0;for(let n=1;n<s;n++)e[n]=e[0],t[n]=t[0]+n*i/2;for(let r=1;r<n;r++){const n=r*s;e[n]=e[0]+r*o/2,t[n]=t[0];for(let o=1;o<s;o++)e[n+o]=e[n],t[n+o]=t[n]+o*i/2}}const r=this.generateNodalNumbering(this.numElementsX,this.numElementsY,n,s,this.elementOrder),a=this.findBoundaryElements();return w("Generated node X coordinates: "+JSON.stringify(e)),w("Generated node Y coordinates: "+JSON.stringify(t)),{nodesXCoordinates:e,nodesYCoordinates:t,totalNodesX:n,totalNodesY:s,nodalNumbering:r,boundaryElements:a}}}findBoundaryElements(){const e=[],t="1D"===this.meshDimension?2:4;for(let n=0;n<t;n++)e.push([]);if("1D"===this.meshDimension)e[0].push([0,0]),e[1].push([this.numElementsX-1,1]);else if("2D"===this.meshDimension)for(let t=0;t<this.numElementsX;t++)for(let n=0;n<this.numElementsY;n++){const s=t*this.numElementsY+n;0===n&&e[0].push([s,0]),0===t&&e[1].push([s,1]),n===this.numElementsY-1&&e[2].push([s,2]),t===this.numElementsX-1&&e[3].push([s,3])}return w("Identified boundary elements by side: "+JSON.stringify(e)),e}generateNodalNumbering(e,t,n,s,o){let i=0,r=[];if("1D"===this.meshDimension){if("linear"===o)for(let t=0;t<e;t++){r[t]=[];for(let e=1;e<=2;e++)r[t][e-1]=t+e}else if("quadratic"===o){let t=0;for(let n=0;n<e;n++){r[n]=[];for(let e=1;e<=3;e++)r[n][e-1]=n+e+t;t+=1}}}else if("2D"===this.meshDimension)if("linear"===o){let n=0,s=2;for(let o=0;o<e*t;o++)n+=1,r[o]=[],r[o][0]=o+s-1,r[o][1]=o+s,r[o][2]=o+s+t,r[o][3]=o+s+t+1,n===t&&(s+=1,n=0)}else if("quadratic"===o)for(let n=1;n<=e;n++)for(let e=1;e<=t;e++){r[i]=[];for(let t=1;t<=3;t++){let o=3*t-2;r[i][o-1]=s*(2*n+t-3)+2*e-1,r[i][o]=r[i][o-1]+1,r[i][o+1]=r[i][o-1]+2}i+=1}return r}}class x{constructor(e,t,n,s,o){this.boundaryConditions=e,this.boundaryElements=t,this.nop=n,this.meshDimension=s,this.elementOrder=o}imposeConstantTempBoundaryConditions(e,t){C("Applying constant temperature boundary conditions (Dirichlet type)"),"1D"===this.meshDimension?Object.keys(this.boundaryConditions).forEach((n=>{if("constantTemp"===this.boundaryConditions[n][0]){const s=this.boundaryConditions[n][1];w(`Boundary ${n}: Applying constant temperature of ${s} K (Dirichlet condition)`),this.boundaryElements[n].forEach((([n,o])=>{if("linear"===this.elementOrder){({0:[0],1:[1]})[o].forEach((o=>{const i=this.nop[n][o]-1;w(`  - Applied fixed temperature to node ${i+1} (element ${n+1}, local node ${o+1})`),e[i]=s;for(let n=0;n<e.length;n++)t[i][n]=0;t[i][i]=1}))}else if("quadratic"===this.elementOrder){({0:[0],2:[2]})[o].forEach((o=>{const i=this.nop[n][o]-1;w(`  - Applied fixed temperature to node ${i+1} (element ${n+1}, local node ${o+1})`),e[i]=s;for(let n=0;n<e.length;n++)t[i][n]=0;t[i][i]=1}))}}))}})):"2D"===this.meshDimension&&Object.keys(this.boundaryConditions).forEach((n=>{if("constantTemp"===this.boundaryConditions[n][0]){const s=this.boundaryConditions[n][1];w(`Boundary ${n}: Applying constant temperature of ${s} K (Dirichlet condition)`),this.boundaryElements[n].forEach((([n,o])=>{if("linear"===this.elementOrder){({0:[0,2],1:[0,1],2:[1,3],3:[2,3]})[o].forEach((o=>{const i=this.nop[n][o]-1;w(`  - Applied fixed temperature to node ${i+1} (element ${n+1}, local node ${o+1})`),e[i]=s;for(let n=0;n<e.length;n++)t[i][n]=0;t[i][i]=1}))}else if("quadratic"===this.elementOrder){({0:[0,3,6],1:[0,1,2],2:[2,5,8],3:[6,7,8]})[o].forEach((o=>{const i=this.nop[n][o]-1;w(`  - Applied fixed temperature to node ${i+1} (element ${n+1}, local node ${o+1})`),e[i]=s;for(let n=0;n<e.length;n++)t[i][n]=0;t[i][i]=1}))}}))}}))}imposeConvectionBoundaryConditions(e,t,n,s,o,i,r){C("Applying convection boundary conditions (Robin type)");let a=[],l=[];Object.keys(this.boundaryConditions).forEach((e=>{const t=this.boundaryConditions[e];"convection"===t[0]&&(a[e]=t[1],l[e]=t[2])})),"1D"===this.meshDimension?Object.keys(this.boundaryConditions).forEach((n=>{if("convection"===this.boundaryConditions[n][0]){const s=a[n],o=l[n];w(`Boundary ${n}: Applying convection with heat transfer coefficient h=${s} W/(m²·K) and external temperature T∞=${o} K`),this.boundaryElements[n].forEach((([n,i])=>{let r;"linear"===this.elementOrder?r=0===i?0:1:"quadratic"===this.elementOrder&&(r=0===i?0:2);const a=this.nop[n][r]-1;w(`  - Applied convection boundary condition to node ${a+1} (element ${n+1}, local node ${r+1})`),e[a]+=-s*o,t[a][a]+=s}))}})):"2D"===this.meshDimension&&Object.keys(this.boundaryConditions).forEach((d=>{if("convection"===this.boundaryConditions[d][0]){const h=a[d],m=l[d];w(`Boundary ${d}: Applying convection with heat transfer coefficient h=${h} W/(m²·K) and external temperature T∞=${m} K`),this.boundaryElements[d].forEach((([a,l])=>{if("linear"===this.elementOrder){let d,u,c,f,p;0===l?(d=n[0],u=0,c=0,f=3,p=2):1===l?(d=0,u=n[0],c=0,f=2,p=1):2===l?(d=n[0],u=1,c=1,f=4,p=2):3===l&&(d=1,u=n[0],c=2,f=4,p=1);let y=r.getBasisFunctions(d,u),g=y.basisFunction,b=y.basisFunctionDerivKsi,E=y.basisFunctionDerivEta,M=0,$=0,v=0,C=0;const N=this.nop[a].length;for(let e=0;e<N;e++){const t=this.nop[a][e]-1;0===l||2===l?(M+=o[t]*b[e],$+=i[t]*b[e]):1!==l&&3!==l||(v+=o[t]*E[e],C+=i[t]*E[e])}const S=0===l||2===l?Math.sqrt(M**2+$**2):Math.sqrt(v**2+C**2);for(let n=c;n<f;n+=p){let o=this.nop[a][n]-1;w(`  - Applied convection boundary condition to node ${o+1} (element ${a+1}, local node ${n+1})`),e[o]+=-s[0]*S*g[n]*h*m;for(let e=c;e<f;e+=p){let i=this.nop[a][e]-1;t[o][i]+=-s[0]*S*g[n]*g[e]*h}}}else if("quadratic"===this.elementOrder)for(let d=0;d<3;d++){let u,c,f,p,y;0===l?(u=n[d],c=0,f=0,p=7,y=3):1===l?(u=0,c=n[d],f=0,p=3,y=1):2===l?(u=n[d],c=1,f=2,p=9,y=3):3===l&&(u=1,c=n[d],f=6,p=9,y=1);let g=r.getBasisFunctions(u,c),b=g.basisFunction,E=g.basisFunctionDerivKsi,M=g.basisFunctionDerivEta,$=0,v=0,C=0,N=0;const S=this.nop[a].length;for(let e=0;e<S;e++){const t=this.nop[a][e]-1;0===l||2===l?($+=o[t]*E[e],v+=i[t]*E[e]):1!==l&&3!==l||(C+=o[t]*M[e],N+=i[t]*M[e])}const D=0===l||2===l?Math.sqrt($**2+v**2):Math.sqrt(C**2+N**2);for(let n=f;n<p;n+=y){let o=this.nop[a][n]-1;w(`  - Applied convection boundary condition to node ${o+1} (element ${a+1}, local node ${n+1})`),e[o]+=-s[d]*D*b[n]*h*m;for(let e=f;e<p;e+=y){let i=this.nop[a][e]-1;t[o][i]+=-s[d]*D*b[n]*b[e]*h}}}}))}}))}}class A{constructor(){this.solverConfig=null,this.meshConfig={},this.boundaryConditions={},this.solverMethod="lusolve",C("FEAScriptModel instance created")}setSolverConfig(e){this.solverConfig=e,w(`Solver config set to: ${e}`)}setMeshConfig(e){this.meshConfig=e,w(`Mesh config set with dimensions: ${e.meshDimension}`)}addBoundaryCondition(e,t){this.boundaryConditions[e]=t,w(`Boundary condition added for boundary: ${e}, type: ${t[0]}`)}setSolverMethod(e){this.solverMethod=e,w(`Solver method set to: ${e}`)}solve(){if(!this.solverConfig||!this.meshConfig||!this.boundaryConditions){const e="Solver config, mesh config, and boundary conditions must be set before solving.";throw console.error(e),new Error(e)}let e=[],t=[],n=[],s={};if(C("Beginning matrix assembly..."),console.time("assemblyMatrices"),"solidHeatTransferScript"===this.solverConfig&&(C(`Using solver: ${this.solverConfig}`),({jacobianMatrix:e,residualVector:t,nodesCoordinates:s}=function(e,t){C("Starting solid heat transfer matrix assembly...");const{meshDimension:n,numElementsX:s,numElementsY:o,maxX:i,maxY:r,elementOrder:a,parsedMesh:l}=e;w("Generating mesh...");const d=new O({numElementsX:s,numElementsY:o,maxX:i,maxY:r,meshDimension:n,elementOrder:a,parsedMesh:l}).generateMesh();let h,m,u=d.nodesXCoordinates,c=d.nodesYCoordinates,f=d.totalNodesX,p=d.totalNodesY,y=d.nodalNumbering,g=d.boundaryElements;null!=l?(h=y.length,m=u.length,w(`Using parsed mesh with ${h} elements and ${m} nodes`)):(h=s*("2D"===n?o:1),m=f*("2D"===n?p:1),w(`Using mesh generated from geometry with ${h} elements and ${m} nodes`));let b,E,$,v,N,S,A,F=[],k=[],T=[],X=[],P=[],W=[],Y=[],R=[],j=[],I=[];for(let e=0;e<m;e++){j[e]=0,I.push([]);for(let t=0;t<m;t++)I[e][t]=0}const B=new D({meshDimension:n,elementOrder:a});let q=new M({meshDimension:n,elementOrder:a}).getGaussPointsAndWeights();k=q.gaussPoints,T=q.gaussWeights;const L=y[0].length;for(let e=0;e<h;e++){for(let t=0;t<L;t++)F[t]=y[e][t]-1;for(let e=0;e<k.length;e++)if("1D"===n){let t=B.getBasisFunctions(k[e]);X=t.basisFunction,P=t.basisFunctionDerivKsi,b=0,$=0,A=0;for(let e=0;e<L;e++)b+=u[F[e]]*X[e],$+=u[F[e]]*P[e],A=$;for(let e=0;e<L;e++)Y[e]=P[e]/A;for(let t=0;t<L;t++){let n=F[t];for(let s=0;s<L;s++){let o=F[s];I[n][o]+=-T[e]*A*(Y[t]*Y[s])}}}else if("2D"===n)for(let t=0;t<k.length;t++){let s=B.getBasisFunctions(k[e],k[t]);X=s.basisFunction,P=s.basisFunctionDerivKsi,W=s.basisFunctionDerivEta,b=0,E=0,$=0,v=0,N=0,S=0,A=0;for(let e=0;e<L;e++)b+=u[F[e]]*X[e],E+=c[F[e]]*X[e],$+=u[F[e]]*P[e],v+=u[F[e]]*W[e],N+=c[F[e]]*P[e],S+=c[F[e]]*W[e],A="2D"===n?$*S-v*N:$;for(let e=0;e<L;e++)Y[e]=(S*P[e]-N*W[e])/A,R[e]=($*W[e]-v*P[e])/A;for(let n=0;n<L;n++){let s=F[n];for(let o=0;o<L;o++){let i=F[o];I[s][i]+=-T[e]*T[t]*A*(Y[n]*Y[o]+R[n]*R[o])}}}}w("Applying thermal boundary conditions...");const G=new x(t,g,y,n,a);return G.imposeConvectionBoundaryConditions(j,I,k,T,u,c,B),w("Convection boundary conditions applied"),G.imposeConstantTempBoundaryConditions(j,I),w("Constant temperature boundary conditions applied"),C("Solid heat transfer matrix assembly completed"),{jacobianMatrix:I,residualVector:j,nodesCoordinates:{nodesXCoordinates:u,nodesYCoordinates:c}}}(this.meshConfig,this.boundaryConditions))),console.timeEnd("assemblyMatrices"),C("Matrix assembly completed"),C(`Solving system using ${this.solverMethod}...`),console.time("systemSolving"),"lusolve"===this.solverMethod)n=math.lusolve(e,t);else if("jacobi"===this.solverMethod){const s=async function(e,t,n,s=100,o=1e-7,i=!0){const r=new Worker("./workers/webgpuJacobiWorker.js",{type:"module"}),a=d(r);try{return await a.jacobiMethod(e,t,n,s,o,i)}catch(e){throw console.error("Error in WebGPU Jacobi method:",e),e}finally{r.terminate()}}(e,t,new Array(t.length).fill(0),1e3,1e-6);s.converged?w(`Jacobi method converged in ${s.iterations} iterations`):w(`Jacobi method did not converge after ${s.iterations} iterations`),n=s.solution}return console.timeEnd("systemSolving"),C("System solved successfully"),{solutionVector:n,nodesCoordinates:s}}}const F=async e=>{let t={nodesXCoordinates:[],nodesYCoordinates:[],nodalNumbering:{quadElements:[],triangleElements:[]},boundaryElements:[],boundaryConditions:[],boundaryNodePairs:{},gmshV:0,ascii:!1,fltBytes:"8",totalNodesX:0,totalNodesY:0,physicalPropMap:[],elementTypes:{}},n=(await e.text()).split("\n").map((e=>e.trim())).filter((e=>""!==e&&" "!==e)),s="",o=0,i=0,r=0,a=0,l={numNodes:0},d=0,h=[],m=0,u=0,c=0,f={dim:0,tag:0,elementType:0,numElements:0},p=0,y={};for(;o<n.length;){const e=n[o];if("$MeshFormat"===e){s="meshFormat",o++;continue}if("$EndMeshFormat"===e){s="",o++;continue}if("$PhysicalNames"===e){s="physicalNames",o++;continue}if("$EndPhysicalNames"===e){s="",o++;continue}if("$Entities"===e){s="entities",o++;continue}if("$EndEntities"===e){s="",o++;continue}if("$Nodes"===e){s="nodes",o++;continue}if("$EndNodes"===e){s="",o++;continue}if("$Elements"===e){s="elements",o++;continue}if("$EndElements"===e){s="",o++;continue}const g=e.split(/\s+/).filter((e=>""!==e));if("meshFormat"===s)t.gmshV=parseFloat(g[0]),t.ascii="0"===g[1],t.fltBytes=g[2];else if("physicalNames"===s){if(g.length>=3){if(!/^\d+$/.test(g[0])){o++;continue}const e=parseInt(g[0],10),n=parseInt(g[1],10);let s=g.slice(2).join(" ");s=s.replace(/^"|"$/g,""),t.physicalPropMap.push({tag:n,dimension:e,name:s})}}else if("nodes"===s){if(0===i){i=parseInt(g[0],10),r=parseInt(g[1],10),t.nodesXCoordinates=new Array(r).fill(0),t.nodesYCoordinates=new Array(r).fill(0),o++;continue}if(a<i&&0===l.numNodes){l={dim:parseInt(g[0],10),tag:parseInt(g[1],10),parametric:parseInt(g[2],10),numNodes:parseInt(g[3],10)},h=[],d=0,m=0,o++;continue}if(d<l.numNodes){for(let e=0;e<g.length&&d<l.numNodes;e++)h.push(parseInt(g[e],10)),d++;if(d<l.numNodes){o++;continue}o++;continue}if(m<l.numNodes){const e=h[m]-1,n=parseFloat(g[0]),s=parseFloat(g[1]);t.nodesXCoordinates[e]=n,t.nodesYCoordinates[e]=s,t.totalNodesX++,t.totalNodesY++,m++,m===l.numNodes&&(a++,l={numNodes:0})}}else if("elements"===s){if(0===u){u=parseInt(g[0],10),parseInt(g[1],10),o++;continue}if(c<u&&0===f.numElements){f={dim:parseInt(g[0],10),tag:parseInt(g[1],10),elementType:parseInt(g[2],10),numElements:parseInt(g[3],10)},t.elementTypes[f.elementType]=(t.elementTypes[f.elementType]||0)+f.numElements,p=0,o++;continue}if(p<f.numElements){parseInt(g[0],10);const e=g.slice(1).map((e=>parseInt(e,10)));if(1===f.elementType||8===f.elementType){const n=f.tag;y[n]||(y[n]=[]),y[n].push(e),t.boundaryNodePairs[n]||(t.boundaryNodePairs[n]=[]),t.boundaryNodePairs[n].push(e)}else 2===f.elementType?t.nodalNumbering.triangleElements.push(e):(3===f.elementType||10===f.elementType)&&t.nodalNumbering.quadElements.push(e);p++,p===f.numElements&&(c++,f={numElements:0})}}o++}return t.physicalPropMap.forEach((e=>{if(1===e.dimension){const n=y[e.tag]||[];n.length>0&&t.boundaryConditions.push({name:e.name,tag:e.tag,nodes:n})}})),w(`Parsed boundary node pairs by physical tag: ${JSON.stringify(t.boundaryNodePairs)}. These pairs will be used to identify boundary elements in the mesh.`),t};function k(e,t,n,s,o,i,r="structured"){const{nodesXCoordinates:a,nodesYCoordinates:l}=t;if("1D"===s&&"line"===o){let t;t=e.length>0&&Array.isArray(e[0])?e.map((e=>e[0])):e;let s=Array.from(a),o={x:s,y:t,mode:"lines",type:"scatter",line:{color:"rgb(219, 64, 82)",width:2},name:"Solution"},r=Math.min(window.innerWidth,700),l=Math.max(...s),d=r/l,h={title:`line plot - ${n}`,width:Math.max(d*l,400),height:350,xaxis:{title:"x"},yaxis:{title:"Solution"},margin:{l:70,r:40,t:50,b:50}};Plotly.newPlot(i,[o],h,{responsive:!0})}else if("2D"===s&&"contour"===o){const t="structured"===r,s=new Set(a).size,d=new Set(l).size;let h=Array.isArray(e[0])?e.map((e=>e[0])):e,m=Math.min(window.innerWidth,700),u=Math.max(...a),c=Math.max(...l)/u,f=Math.min(m,600),p={title:`${o} plot - ${n}`,width:f,height:f*c*.8,xaxis:{title:"x"},yaxis:{title:"y"},margin:{l:50,r:50,t:50,b:50},hovermode:"closest"};if(t){const t=s,n=d;math.reshape(Array.from(a),[t,n]);let o=math.reshape(Array.from(l),[t,n]),r=math.reshape(Array.from(e),[t,n]),h=math.transpose(r),m=[];for(let e=0;e<t*n;e+=n){let t=a[e];m.push(t)}let u={z:h,type:"contour",contours:{coloring:"heatmap",showlabels:!1},colorbar:{title:"Solution"},x:m,y:o[0],name:"Solution Field"};Plotly.newPlot(i,[u],p,{responsive:!0})}else{let e={x:a,y:l,z:h,type:"contour",contours:{coloring:"heatmap",showlabels:!1},colorbar:{title:"Solution"},name:"Solution Field"};Plotly.newPlot(i,[e],p,{responsive:!0})}}}class T{constructor(){this.worker=null,this.feaWorker=null,this.isReady=!1,this._initWorker()}async _initWorker(){try{this.worker=new Worker(new URL("./wrapperScript.js",import.meta.url),{type:"module"}),this.worker.onerror=e=>{console.error("FEAScriptWorker: Worker error:",e)};const e=d(this.worker);this.feaWorker=await new e,this.isReady=!0}catch(e){throw console.error("Failed to initialize worker",e),e}}async _ensureReady(){return this.isReady?Promise.resolve():new Promise(((e,t)=>{let n=0;const s=()=>{n++,this.isReady?e():n>=50?t(new Error("Timeout waiting for worker to be ready")):setTimeout(s,1e3)};s()}))}async setSolverConfig(e){return await this._ensureReady(),C(`FEAScriptWorker: Setting solver config to: ${e}`),this.feaWorker.setSolverConfig(e)}async setMeshConfig(e){return await this._ensureReady(),C("FEAScriptWorker: Setting mesh config"),this.feaWorker.setMeshConfig(e)}async addBoundaryCondition(e,t){return await this._ensureReady(),C(`FEAScriptWorker: Adding boundary condition for boundary: ${e}`),this.feaWorker.addBoundaryCondition(e,t)}async setSolverMethod(e){return await this._ensureReady(),C(`FEAScriptWorker: Setting solver method to: ${e}`),this.feaWorker.setSolverMethod(e)}async solve(){await this._ensureReady(),C("FEAScriptWorker: Requesting solution from worker...");const e=performance.now(),t=await this.feaWorker.solve();return C(`FEAScriptWorker: Solution completed in ${((performance.now()-e)/1e3).toFixed(2)}s`),t}async getModelInfo(){return await this._ensureReady(),this.feaWorker.getModelInfo()}async ping(){return await this._ensureReady(),this.feaWorker.ping()}terminate(){this.worker&&(this.worker.terminate(),this.worker=null,this.feaWorker=null,this.isReady=!1)}}export{A as FEAScriptModel,T as FEAScriptWorker,F as importGmshQuadTri,v as logSystem,k as plotSolution,S as printVersion};
//# sourceMappingURL=feascript.esm.js.map
